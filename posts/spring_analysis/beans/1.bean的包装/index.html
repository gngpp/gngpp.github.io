<!doctype html>
<html lang="en-us">
  <head>
    <title>1.Bean的包装 // gngpp</title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.99.1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="gngpp" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://blog.innas.cn/css/main.min.4a7ec8660f9a44b08c4da97c5f2e31b1192df1d4d0322e65c0dbbc6ecb1b863f.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="1.Bean的包装"/>
<meta name="twitter:description" content="1.前言 为什么先从对bean的包装开始阅读源码呢，因为beans包的核心就是BeanFactory 🐶，其作用就是对bean进行管理，那么对bean管理的前提就是对bean进行解析，然后支持属性的set 或 get 操作。那么我们列举一下BeanFactory的主要职责，即使没阅读过源码，也应该知道个大概过程.
 解析xml或者其它配置文件得到 BeanDefinition 实例化 Instance AutoWired自动装配 Bean的依赖  所以，我们先了解如何去得到一个Bean的 “定义” (解析xml那部分先不讲)
2. BeanWrapper接口 这个类的主要作用是解析`Class` 然后获取属性，进一步封装，然后提供修改属性的接口 public interface BeanWrapper extends ConfigurablePropertyAccessor {  // 设置集合属性自增长的长度 	void setAutoGrowCollectionLimit(int autoGrowCollectionLimit); 	 // 获取当前集合属性自增长的长度 	int getAutoGrowCollectionLimit(); 		// 获取包装的Bean的Instance 	Object getWrappedInstance(); 		// 获取Bean的Class 	Class&lt;?&gt; getWrappedClass(); 		// 获取所有属性描述符 	PropertyDescriptor[] getPropertyDescriptors();   // 获取属性描述符 	PropertyDescriptor getPropertyDescriptor(String propertyName) throws InvalidPropertyException;  } 为什么上面会涉及到集合，因为Bean 支持nested (嵌套) 属性读写，也就是pojo"/>

    <meta property="og:title" content="1.Bean的包装" />
<meta property="og:description" content="1.前言 为什么先从对bean的包装开始阅读源码呢，因为beans包的核心就是BeanFactory 🐶，其作用就是对bean进行管理，那么对bean管理的前提就是对bean进行解析，然后支持属性的set 或 get 操作。那么我们列举一下BeanFactory的主要职责，即使没阅读过源码，也应该知道个大概过程.
 解析xml或者其它配置文件得到 BeanDefinition 实例化 Instance AutoWired自动装配 Bean的依赖  所以，我们先了解如何去得到一个Bean的 “定义” (解析xml那部分先不讲)
2. BeanWrapper接口 这个类的主要作用是解析`Class` 然后获取属性，进一步封装，然后提供修改属性的接口 public interface BeanWrapper extends ConfigurablePropertyAccessor {  // 设置集合属性自增长的长度 	void setAutoGrowCollectionLimit(int autoGrowCollectionLimit); 	 // 获取当前集合属性自增长的长度 	int getAutoGrowCollectionLimit(); 		// 获取包装的Bean的Instance 	Object getWrappedInstance(); 		// 获取Bean的Class 	Class&lt;?&gt; getWrappedClass(); 		// 获取所有属性描述符 	PropertyDescriptor[] getPropertyDescriptors();   // 获取属性描述符 	PropertyDescriptor getPropertyDescriptor(String propertyName) throws InvalidPropertyException;  } 为什么上面会涉及到集合，因为Bean 支持nested (嵌套) 属性读写，也就是pojo" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog.innas.cn/posts/spring_analysis/beans/1.bean%E7%9A%84%E5%8C%85%E8%A3%85/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-08-02T11:39:34+00:00" />
<meta property="article:modified_time" content="2021-08-02T11:39:34+00:00" />



  </head>
  <body>
    <header class="app-header">
      <a href="https://blog.innas.cn/"><img class="app-header-avatar" src="/avatar.png" alt="gngpp" /></a>
      <h1>gngpp</h1>
      <nav class="app-header-menu">
          <a class="app-header-menu-item" href="/">Home</a>
             - 
          
          <a class="app-header-menu-item" href="/tags/">Tags</a>
             - 
          
          <a class="app-header-menu-item" href="/categories/">Categories</a>
             - 
          
          <a class="app-header-menu-item" href="/about/">About</a>
      </nav>
      <p>兴趣使然</p>
      <div class="app-header-social">
        
          <a href="https://github.com/gngpp" target="_blank" rel="noreferrer noopener">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>Github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg>
          </a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">1.Bean的包装</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Aug 2, 2021
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          4 min read
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag">
  <title>tag</title>
  <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7.01" y2="7"></line>
</svg>
              <a class="tag" href="https://blog.innas.cn/tags/spring-bean/">Spring-Bean</a>
        </div>
      </div>
    </header>
    <div class="post-content">
      <h3 id="1前言">1.前言</h3>
<p>为什么先从对bean的包装开始阅读源码呢，因为beans包的核心就是<code>BeanFactory</code> 🐶，其作用就是对bean进行管理，那么对bean管理的前提就是对bean进行解析，然后支持属性的<code>set</code> 或 <code>get</code> 操作。那么我们列举一下<code>BeanFactory</code>的主要职责，即使没阅读过源码，也应该知道个大概过程.</p>
<ul>
<li>解析<code>xml</code>或者其它配置文件得到 <code>BeanDefinition</code></li>
<li>实例化 <code>Instance</code></li>
<li><code>AutoWired</code>自动装配 <code>Bean</code>的依赖</li>
</ul>
<p><strong>所以，我们先了解如何去得到一个Bean的 “定义” (解析xml那部分先不讲)</strong></p>
<h3 id="2-beanwrapper接口">2. BeanWrapper接口</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-tex" data-lang="tex"><span style="display:flex;"><span>这个类的主要作用是解析`Class` 然后获取属性，进一步封装，然后提供修改属性的接口
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">BeanWrapper</span> <span style="color:#66d9ef">extends</span> ConfigurablePropertyAccessor <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 设置集合属性自增长的长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setAutoGrowCollectionLimit</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> autoGrowCollectionLimit<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 获取当前集合属性自增长的长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getAutoGrowCollectionLimit</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 获取包装的Bean的Instance
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	Object <span style="color:#a6e22e">getWrappedInstance</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 获取Bean的Class
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	Class<span style="color:#f92672">&lt;?&gt;</span> getWrappedClass<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 获取所有属性描述符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	PropertyDescriptor<span style="color:#f92672">[]</span> <span style="color:#a6e22e">getPropertyDescriptors</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 获取属性描述符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	PropertyDescriptor <span style="color:#a6e22e">getPropertyDescriptor</span><span style="color:#f92672">(</span>String propertyName<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> InvalidPropertyException<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>为什么上面会涉及到<strong>集合</strong>，因为<code>Bean</code> 支持<code>nested (嵌套)</code> 属性读写，也就是<code>pojo</code></p>
<pre tabindex="0"><code class="language-properties" data-lang="properties">bean.setValue(&#34;bean.child.attr&#34;, 1)
</code></pre><h3 id="3-beanwrapperimpl实现">3. <code>BeanWrapperImpl实现</code></h3>
<ol>
<li>
<p>我们从其测试代码中可以看到这样的用法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>GetterBean target <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> GetterBean<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>BeanWrapper accessor <span style="color:#f92672">=</span> createAccessor<span style="color:#f92672">(</span>target<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>accessor<span style="color:#f92672">.</span><span style="color:#a6e22e">setPropertyValue</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;name&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;tom&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>assertThat<span style="color:#f92672">(</span>target<span style="color:#f92672">.</span><span style="color:#a6e22e">getAliasedName</span><span style="color:#f92672">()).</span><span style="color:#a6e22e">isEqualTo</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;tom&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>assertThat<span style="color:#f92672">(</span>accessor<span style="color:#f92672">.</span><span style="color:#a6e22e">getPropertyValue</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;aliasedName&#34;</span><span style="color:#f92672">)).</span><span style="color:#a6e22e">isEqualTo</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;tom&#34;</span><span style="color:#f92672">);</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">protected</span> BeanWrapperImpl <span style="color:#a6e22e">createAccessor</span><span style="color:#f92672">(</span>Object target<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> BeanWrapperImpl<span style="color:#f92672">(</span>target<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">}</span>
</span></span></code></pre></div><p>我们可以看到 <code>createAccessor</code> 就是<code>new BeanWrapperImpl</code>就完成对<code>Bean</code>的封装了， 就可以调用</p>
<ul>
<li><code>setPropertyValue</code>  设置属性值</li>
<li><code>getPropertyValue</code>  获取属性值</li>
</ul>
</li>
<li>
<p>初步看下 <code>BeanWrapperImpl</code>的<code>UML</code> (不用纠结 <code>UML</code> 后面会人肉其运行过程) :happy:</p>
</li>
</ol>
<p><img src="/img/1.bean%E7%9A%84%E5%8C%85%E8%A3%85/image-20191012223223606.png" alt=""></p>
<p><strong>在上面这个图中，着重 <code>AbstractNesablePropertyAccessor</code></strong> 此类是用于支持上文提到的<code>Nested</code> 嵌套属性读写.</p>
<ol start="3">
<li>
<p><code>getPropertyDescriptor</code> 获取属性描述符</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> PropertyDescriptor <span style="color:#a6e22e">getPropertyDescriptor</span><span style="color:#f92672">(</span>String propertyName<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> InvalidPropertyException <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// [1] 先解析嵌套属性，获取最后一个属性的Instance
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		BeanWrapperImpl nestedBw <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>BeanWrapperImpl<span style="color:#f92672">)</span> getPropertyAccessorForPropertyPath<span style="color:#f92672">(</span>propertyName<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>		String finalPath <span style="color:#f92672">=</span> getFinalPath<span style="color:#f92672">(</span>nestedBw<span style="color:#f92672">,</span> propertyName<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// [2] 然后直接获取属性描述符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		PropertyDescriptor pd <span style="color:#f92672">=</span> nestedBw<span style="color:#f92672">.</span><span style="color:#a6e22e">getCachedIntrospectionResults</span><span style="color:#f92672">().</span><span style="color:#a6e22e">getPropertyDescriptor</span><span style="color:#f92672">(</span>finalPath<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>pd <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> InvalidPropertyException<span style="color:#f92672">(</span>getRootClass<span style="color:#f92672">(),</span> getNestedPath<span style="color:#f92672">()</span> <span style="color:#f92672">+</span> propertyName<span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>					<span style="color:#e6db74">&#34;No property &#39;&#34;</span> <span style="color:#f92672">+</span> propertyName <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;&#39; found&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> pd<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">}</span>
</span></span></code></pre></div><ul>
<li>
<p>刚才我们说过其支持<code>nested</code> 嵌套属性，如果我们传入的<code>propertyName</code> 为 <code>bean.child.name</code> ，我们就要先拿到 <code>bean</code> 然后再拿到 <code>child</code> 最后拿到 <code>name</code> 然后才能返回类型描述符. ​ :warning: 第一步我们先不管</p>
</li>
<li>
<p>然后第二步 <code>getCachedIntrospectionResults#getPropertyDescriptor()</code> 来获取属性描述符</p>
</li>
<li>
<p><code>CachedIntrospectionResults</code> 中包含 <code>PropertyDescriptor</code> 信息，跟下去</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> CachedIntrospectionResults <span style="color:#a6e22e">getCachedIntrospectionResults</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>   	<span style="color:#75715e">// [1] 判断是不是有缓存了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">cachedIntrospectionResults</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// [2] 缓存中没有那就 new
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">cachedIntrospectionResults</span> <span style="color:#f92672">=</span> CachedIntrospectionResults<span style="color:#f92672">.</span><span style="color:#a6e22e">forClass</span><span style="color:#f92672">(</span>getWrappedClass<span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">cachedIntrospectionResults</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">}</span>
</span></span></code></pre></div><p>继续跟。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> CachedIntrospectionResults <span style="color:#a6e22e">forClass</span><span style="color:#f92672">(</span>Class<span style="color:#f92672">&lt;?&gt;</span> beanClass<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> BeansException <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// [1] 从一级缓存中获取
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		CachedIntrospectionResults results <span style="color:#f92672">=</span> strongClassCache<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>beanClass<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>results <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> results<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// [2] 从二级缓存中获取
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		results <span style="color:#f92672">=</span> softClassCache<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>beanClass<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>results <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> results<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// [3] 如果都没有，则New一个, 核心还是在这
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		results <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CachedIntrospectionResults<span style="color:#f92672">(</span>beanClass<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>		ConcurrentMap<span style="color:#f92672">&lt;</span>Class<span style="color:#f92672">&lt;?&gt;,</span> CachedIntrospectionResults<span style="color:#f92672">&gt;</span> classCacheToUse<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// [4] 判断使用一级缓存还是二级缓存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// 经调试，发现spring用的是一级缓存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>ClassUtils<span style="color:#f92672">.</span><span style="color:#a6e22e">isCacheSafe</span><span style="color:#f92672">(</span>beanClass<span style="color:#f92672">,</span> CachedIntrospectionResults<span style="color:#f92672">.</span><span style="color:#a6e22e">class</span><span style="color:#f92672">.</span><span style="color:#a6e22e">getClassLoader</span><span style="color:#f92672">())</span> <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>				isClassLoaderAccepted<span style="color:#f92672">(</span>beanClass<span style="color:#f92672">.</span><span style="color:#a6e22e">getClassLoader</span><span style="color:#f92672">()))</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>			classCacheToUse <span style="color:#f92672">=</span> strongClassCache<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>logger<span style="color:#f92672">.</span><span style="color:#a6e22e">isDebugEnabled</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>				logger<span style="color:#f92672">.</span><span style="color:#a6e22e">debug</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Not strongly caching class [&#34;</span> <span style="color:#f92672">+</span> beanClass<span style="color:#f92672">.</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">()</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;] because it is not cache-safe&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>			<span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>			classCacheToUse <span style="color:#f92672">=</span> softClassCache<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// [5] 将新New的放入缓存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		CachedIntrospectionResults existing <span style="color:#f92672">=</span> classCacheToUse<span style="color:#f92672">.</span><span style="color:#a6e22e">putIfAbsent</span><span style="color:#f92672">(</span>beanClass<span style="color:#f92672">,</span> results<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span>existing <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">?</span> existing <span style="color:#f92672">:</span> results<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">}</span>
</span></span></code></pre></div><p>可以看到<code>spring</code> 很善用缓存，这里可以看到，其用了两个缓存 <code>strongClassCache</code> 和 <code>softClassCache</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>  <span style="color:#75715e">/* [DESC] 一级缓存*/</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> ConcurrentMap<span style="color:#f92672">&lt;</span>Class<span style="color:#f92672">&lt;?&gt;,</span> CachedIntrospectionResults<span style="color:#f92672">&gt;</span> strongClassCache <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">new</span> ConcurrentHashMap<span style="color:#f92672">&lt;&gt;(</span>64<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* [DESC] 二级缓存 又称为 SoftCache，因为采用弱引用MAP，所以缓存元素长时间未使用则会被回收*/</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> ConcurrentMap<span style="color:#f92672">&lt;</span>Class<span style="color:#f92672">&lt;?&gt;,</span> CachedIntrospectionResults<span style="color:#f92672">&gt;</span> softClassCache <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">new</span> ConcurrentReferenceHashMap<span style="color:#f92672">&lt;&gt;(</span>64<span style="color:#f92672">);</span>
</span></span></code></pre></div><p><strong>虽然其设置了两层缓存，但实际只用到了 <code>strongClassCache</code></strong> 因为属性这些会常驻内存，所以不需要使用弱引用的<code>Map</code>,实际上控制使用那个缓存是<code>isCacheSafe</code> 来控制的, 继续跟 :hammer:我是最强人肉王子</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">isCacheSafe</span><span style="color:#f92672">(</span>Class<span style="color:#f92672">&lt;?&gt;</span> clazz<span style="color:#f92672">,</span> <span style="color:#a6e22e">@Nullable</span> ClassLoader classLoader<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>   Assert<span style="color:#f92672">.</span><span style="color:#a6e22e">notNull</span><span style="color:#f92672">(</span>clazz<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;Class must not be null&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// [1] 获取该类的ClassLoader
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      ClassLoader target <span style="color:#f92672">=</span> clazz<span style="color:#f92672">.</span><span style="color:#a6e22e">getClassLoader</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// Common cases
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// [2] 如果目标类的ClassLoader == 提供的classLoader
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#75715e">// [NOTICE] 双亲委派原则，只有使用同一个类加载器，加载的数据才能是只有一份，这个缓存才是是有效的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>target <span style="color:#f92672">==</span> classLoader <span style="color:#f92672">||</span> target <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>classLoader <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// [3] 递归classLoader的祖先
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#75715e">// Check for match in ancestors -&gt; positive
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      ClassLoader current <span style="color:#f92672">=</span> classLoader<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>current <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>         current <span style="color:#f92672">=</span> current<span style="color:#f92672">.</span><span style="color:#a6e22e">getParent</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>current <span style="color:#f92672">==</span> target<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>         <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// [4] 递归目标的祖先
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#75715e">// Check for match in children -&gt; negative
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>target <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>         target <span style="color:#f92672">=</span> target<span style="color:#f92672">.</span><span style="color:#a6e22e">getParent</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>target <span style="color:#f92672">==</span> classLoader<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>         <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>SecurityException ex<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// Fall through to loadable check below
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">// Fallback for ClassLoaders without parent/child relationship:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#75715e">// safe if same Class can be loaded from given ClassLoader
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span>classLoader <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> isLoadable<span style="color:#f92672">(</span>clazz<span style="color:#f92672">,</span> classLoader<span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p><strong>这里判断cache是否安全的原理是</strong> ，根据<code>双亲委派</code> 机制，因为一个类被一个加载器加载一次在内存中就会有一份<code>Class</code> , 如果它们的加载器是一样的，那么得到的<code>Class</code> 也是一致的，这样才能确保，我们拿到的目标<code>Class</code> 数据是正确的。</p>
<p>解析完这个，我们继续上面的，如果从缓存拿不到则 <code>new</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>results <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CachedIntrospectionResults<span style="color:#f92672">(</span>beanClass<span style="color:#f92672">);</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#a6e22e">CachedIntrospectionResults</span><span style="color:#f92672">(</span>Class<span style="color:#f92672">&lt;?&gt;</span> beanClass<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> BeansException <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>logger<span style="color:#f92672">.</span><span style="color:#a6e22e">isTraceEnabled</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>				logger<span style="color:#f92672">.</span><span style="color:#a6e22e">trace</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Getting BeanInfo for class [&#34;</span> <span style="color:#f92672">+</span> beanClass<span style="color:#f92672">.</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">()</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;]&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>			<span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 关注 #getBeanInfo
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">beanInfo</span> <span style="color:#f92672">=</span> getBeanInfo<span style="color:#f92672">(</span>beanClass<span style="color:#f92672">);</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> BeanInfo <span style="color:#a6e22e">getBeanInfo</span><span style="color:#f92672">(</span>Class<span style="color:#f92672">&lt;?&gt;</span> beanClass<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> IntrospectionException <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">// [1] 尝试从加载的工厂中获取BeanInfo
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#75715e">// 实际上，spring.beans 只提供一个工厂，而且那个工厂也是从线程上下文中获取
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#75715e">// 所以一定能拿到，这是为了防止spring.beans没有提供工厂而考虑到的细节
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>BeanInfoFactory beanInfoFactory <span style="color:#f92672">:</span> beanInfoFactories<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      BeanInfo beanInfo <span style="color:#f92672">=</span> beanInfoFactory<span style="color:#f92672">.</span><span style="color:#a6e22e">getBeanInfo</span><span style="color:#f92672">(</span>beanClass<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>beanInfo <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">return</span> beanInfo<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">// [2] 如果不提供工厂或者工厂不存在，直接在线程上下文中获取
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span>shouldIntrospectorIgnoreBeaninfoClasses <span style="color:#f92672">?</span>
</span></span><span style="display:flex;"><span>         Introspector<span style="color:#f92672">.</span><span style="color:#a6e22e">getBeanInfo</span><span style="color:#f92672">(</span>beanClass<span style="color:#f92672">,</span> Introspector<span style="color:#f92672">.</span><span style="color:#a6e22e">IGNORE_ALL_BEANINFO</span><span style="color:#f92672">)</span> <span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>         Introspector<span style="color:#f92672">.</span><span style="color:#a6e22e">getBeanInfo</span><span style="color:#f92672">(</span>beanClass<span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>在<code>CachedIntrospectionResults</code> 中，它会加载一个 <code>factory</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">/** [DESC]  在这里加载BeanInfoFactory*/</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 加载 &#34;META-INF/spring.factories&#34; 中指定的工厂类
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> List<span style="color:#f92672">&lt;</span>BeanInfoFactory<span style="color:#f92672">&gt;</span> beanInfoFactories <span style="color:#f92672">=</span> SpringFactoriesLoader<span style="color:#f92672">.</span><span style="color:#a6e22e">loadFactories</span><span style="color:#f92672">(</span>
</span></span><span style="display:flex;"><span>      BeanInfoFactory<span style="color:#f92672">.</span><span style="color:#a6e22e">class</span><span style="color:#f92672">,</span> CachedIntrospectionResults<span style="color:#f92672">.</span><span style="color:#a6e22e">class</span><span style="color:#f92672">.</span><span style="color:#a6e22e">getClassLoader</span><span style="color:#f92672">());</span>
</span></span></code></pre></div><pre tabindex="0"><code class="language-properties" data-lang="properties">org.springframework.beans.BeanInfoFactory=org.springframework.beans.ExtendedBeanInfoFactory
</code></pre><p>发现了，它的默认工厂类是 <code>ExtendedBeanInfoFactory</code></p>
<p>接下来继续看，如果工厂类中不存在 <code>BeanInfo</code>则会调用 <code>Introspector#getBeanInfo()</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> BeanInfo <span style="color:#a6e22e">getBeanInfo</span><span style="color:#f92672">(</span>Class<span style="color:#f92672">&lt;?&gt;</span> beanClass<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">throws</span> IntrospectionException
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>ReflectUtil<span style="color:#f92672">.</span><span style="color:#a6e22e">isPackageAccessible</span><span style="color:#f92672">(</span>beanClass<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> Introspector<span style="color:#f92672">(</span>beanClass<span style="color:#f92672">,</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">,</span> USE_ALL_BEANINFO<span style="color:#f92672">)).</span><span style="color:#a6e22e">getBeanInfo</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>  			<span style="color:#75715e">// 从线程上下文获取已经加载的 Class 信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        ThreadGroupContext context <span style="color:#f92672">=</span> ThreadGroupContext<span style="color:#f92672">.</span><span style="color:#a6e22e">getContext</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        BeanInfo beanInfo<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">synchronized</span> <span style="color:#f92672">(</span>declaredMethodCache<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            beanInfo <span style="color:#f92672">=</span> context<span style="color:#f92672">.</span><span style="color:#a6e22e">getBeanInfo</span><span style="color:#f92672">(</span>beanClass<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>beanInfo <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            beanInfo <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Introspector<span style="color:#f92672">(</span>beanClass<span style="color:#f92672">,</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">,</span> USE_ALL_BEANINFO<span style="color:#f92672">).</span><span style="color:#a6e22e">getBeanInfo</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">synchronized</span> <span style="color:#f92672">(</span>declaredMethodCache<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                context<span style="color:#f92672">.</span><span style="color:#a6e22e">putBeanInfo</span><span style="color:#f92672">(</span>beanClass<span style="color:#f92672">,</span> beanInfo<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> beanInfo<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span></code></pre></div><p>到此就不用追了，这里已经是jdk了，实际上是从 <code>线程上下文</code>获取的 <code>BeanInfo</code> ，这也证明了 <code>BeanFactory</code> 用的是 <code>线程上下文加载器</code></p>
<p><strong>其实上面的 默认工厂 ExtendedBeanInfoFactory</strong> 用的也是<code>上下文加载器</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ExtendedBeanInfoFactory</span> <span style="color:#66d9ef">implements</span> BeanInfoFactory<span style="color:#f92672">,</span> Ordered <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    * Return an {@link ExtendedBeanInfo} for the given bean class, if applicable.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    */</span>
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">@Nullable</span>
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">public</span> BeanInfo <span style="color:#a6e22e">getBeanInfo</span><span style="color:#f92672">(</span>Class<span style="color:#f92672">&lt;?&gt;</span> beanClass<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> IntrospectionException <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span>supports<span style="color:#f92672">(</span>beanClass<span style="color:#f92672">)</span> <span style="color:#f92672">?</span> <span style="color:#66d9ef">new</span> ExtendedBeanInfo<span style="color:#f92672">(</span>Introspector<span style="color:#f92672">.</span><span style="color:#a6e22e">getBeanInfo</span><span style="color:#f92672">(</span>beanClass<span style="color:#f92672">))</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">}</span>
</span></span></code></pre></div><p><strong>总结下，以免跟得太深，回溯不了</strong></p>
</li>
</ul>
<p><img src="/img/1.bean%E7%9A%84%E5%8C%85%E8%A3%85/image-20191013012133042.png" alt=""></p>
<p>目前为止，我们也只是拿到了 <code>BeanInfo</code>
回到 <code>new CachedIntrospectionResults</code> 的地方，我们首先已经有了 <code>BeanInfo</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#a6e22e">CachedIntrospectionResults</span><span style="color:#f92672">(</span>Class<span style="color:#f92672">&lt;?&gt;</span> beanClass<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> BeansException <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 关注 #getBeanInfo
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">beanInfo</span> <span style="color:#f92672">=</span> getBeanInfo<span style="color:#f92672">(</span>beanClass<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">propertyDescriptorCache</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> LinkedHashMap<span style="color:#f92672">&lt;&gt;();</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// [1] 直接获取BeanInfo的 {@link PropertyDescriptor}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      PropertyDescriptor<span style="color:#f92672">[]</span> pds <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">beanInfo</span><span style="color:#f92672">.</span><span style="color:#a6e22e">getPropertyDescriptors</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>PropertyDescriptor pd <span style="color:#f92672">:</span> pds<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>         <span style="color:#75715e">// [2] 某些属性是被保护的，则跳过
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>         <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>Class<span style="color:#f92672">.</span><span style="color:#a6e22e">class</span> <span style="color:#f92672">==</span> beanClass <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>               <span style="color:#f92672">(</span><span style="color:#e6db74">&#34;classLoader&#34;</span><span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>pd<span style="color:#f92672">.</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">())</span> <span style="color:#f92672">||</span>  <span style="color:#e6db74">&#34;protectionDomain&#34;</span><span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>pd<span style="color:#f92672">.</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">())))</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">continue</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>         <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>         <span style="color:#75715e">// [3] 将{@link PropertyDescriptor} 转换为 {@link GenericTypeAwarePropertyDescriptor}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>         pd <span style="color:#f92672">=</span> buildGenericTypeAwarePropertyDescriptor<span style="color:#f92672">(</span>beanClass<span style="color:#f92672">,</span> pd<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>         <span style="color:#75715e">// [4] 丢入缓存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>         <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">propertyDescriptorCache</span><span style="color:#f92672">.</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>pd<span style="color:#f92672">.</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">(),</span> pd<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// [5] 还得判断这些方法是不是java8的接口的默认方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      Class<span style="color:#f92672">&lt;?&gt;</span> currClass <span style="color:#f92672">=</span> beanClass<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>currClass <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> currClass <span style="color:#f92672">!=</span> Object<span style="color:#f92672">.</span><span style="color:#a6e22e">class</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>         introspectInterfaces<span style="color:#f92672">(</span>beanClass<span style="color:#f92672">,</span> currClass<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>         currClass <span style="color:#f92672">=</span> currClass<span style="color:#f92672">.</span><span style="color:#a6e22e">getSuperclass</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">typeDescriptorCache</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ConcurrentReferenceHashMap<span style="color:#f92672">&lt;&gt;();</span>
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>直接从 <code>BeanInfo</code> 拿到属性描述符，并且缓存起来，现在我们就完成了获取 <code>BeanInfo</code> 部分了，那么剩下的就是根据拿到的 <code>PropertyDescriptor</code> 去读写 <code>Property</code> :wink:</p>
</li>
</ol>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
