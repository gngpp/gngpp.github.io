<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CRUD一些常用工具</title>
    <url>/2021/08/02/CRUD%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<ol>
<li>
<p>Objects常用场景</p>
<ul>
<li>重写<code>hashCode</code> 时，使用 <code>Objects.hash(Object ...)</code> 计算所有对象 <code>HashCode</code></li>
<li>使用 <code>Objects.requireNonNull(Object)</code> 代替<code>if(Object == null) throw new NullPointerException()</code></li>
</ul>
</li>
<li>
<p>集合和字符串判空常用方法</p>
<ul>
<li><code>CollectionUtils.isEmpty</code> 这是<code>spring</code>提供的工具类</li>
<li><code>StringUtils.isEmpty</code> 这是 <code>spring</code>提供的工具类</li>
</ul>
</li>
<li>
<p>Optional常用场景</p>
<p>Optinal 简单用法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 若value为null则抛出异常</span></span><br><span class="line">Optional&lt;Object&gt; optional = Optional.of(Object);</span><br><span class="line"></span><br><span class="line"><span class="comment">// value可以为null</span></span><br><span class="line">Optional&lt;Object&gt; optional = Optional.ofNullable(Object);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作值，若值不为null</span></span><br><span class="line">optional.ifPresent(Consumer&lt;T&gt; concumer);</span><br><span class="line">optinal.ifPresent(System.out::print);</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>处理允许为 <code>null</code> 的返回值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;Object&gt; result = Optional.ofNullable(Value);</span><br><span class="line">result.ifPresent((value) -&gt; &#123;</span><br><span class="line">  <span class="comment">// do something if value not null</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">if</span>(value != <span class="literal">null</span>)&#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>处理不允许为<code>null</code>的返回值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;Object&gt; result = Optional.of(Value);</span><br><span class="line">result.ifPresent((value) -&gt; &#123;</span><br><span class="line">  <span class="comment">// do something if value not null</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">if</span>(value != <span class="literal">null</span>)&#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用默认值代替<code>null</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一</span></span><br><span class="line">Optional&lt;Object&gt; result = Optional.ofNullable(Value);</span><br><span class="line"><span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> result.orElse(defaultValue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二，使用 lamdba</span></span><br><span class="line">Optional&lt;Object&gt; result = Optional.ofNullable(Value);</span><br><span class="line"><span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> result.orElseGet(() -&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> defaultValue;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> result == <span class="literal">null</span>? defaultValue : result;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用自定义异常对于 <code>null</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;Object&gt; result = Optional.ofNullable(Value);</span><br><span class="line"><span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> result.orElseThrow(() -&gt; &#123;</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">ResourceNotFoundException</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">if</span>(result != <span class="literal">null</span>)&#123;</span><br><span class="line">  result = value;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ResourceNotFoundException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>过滤值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;Integer&gt; result = Optional.ofNullable(<span class="number">100</span>);</span><br><span class="line">result.filter((value) -&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> value != <span class="number">100</span>;</span><br><span class="line">&#125;).filter((value) -&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> value != <span class="number">200</span>;</span><br><span class="line">&#125;).ifPresent(System.out::print);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">300</span>;</span><br><span class="line"><span class="keyword">if</span>(value != <span class="literal">null</span> &amp;&amp; value != <span class="number">100</span> &amp;&amp; value != <span class="number">200</span>)&#123;</span><br><span class="line">  System.out.print(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用 <code>map</code> 将 值重新映射为 <code>Optional</code>类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ProcessHandle</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Integer id;</span><br><span class="line">  <span class="keyword">private</span> String path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 handle 中的id，将其映射为 Optional类型</span></span><br><span class="line">Optional&lt;ProcessHandle&gt; handle = Optional.ofNullable(value);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">id</span> <span class="operator">=</span> handle.map(ProcessHandle::getId).orElse(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">id</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span>(value != <span class="literal">null</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(value.getId() == <span class="literal">null</span>)&#123;</span><br><span class="line">    id = -<span class="number">1</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    id = value.getId();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>Optional</code> 注意事项</p>
<ul>
<li>容器类型不应该使用 <code>Optinal</code></li>
<li>容器类型不应该是 <code>基本类型</code></li>
<li>不要使用 <code>Optional</code> 作为集合中的元素和键映射</li>
</ul>
</li>
</ul>
</li>
<li>
<p>使用<code>Mapstruct</code>简化后端中<code>BO</code>转<code>VO</code>的操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> DataResult&lt;FooBo&gt; <span class="title function_">fooController</span><span class="params">(<span class="meta">@RequestBody</span> FooVO fooVO)</span>&#123;</span><br><span class="line">  <span class="comment">// 通常需要这样操作</span></span><br><span class="line">  <span class="type">FooDTO</span> <span class="variable">fooDto</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FooDTO</span>();</span><br><span class="line">  fooDto.setxxx(fooVO.getxxx());</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="type">FooBo</span> <span class="variable">bo</span> <span class="operator">=</span> dao.query(fooDto);</span><br><span class="line">  <span class="keyword">return</span> bo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 充斥着许多 set / get 取值赋值的代码，大大降低了代码可读性</span></span><br><span class="line"><span class="comment">// 这个时候用Mapstruct 就可以大大简化代码</span></span><br><span class="line">Mappers.getMapper(Foo.class).voToDto(fooVO);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>skill</category>
      </categories>
      <tags>
        <tag>CRUD</tag>
      </tags>
  </entry>
  <entry>
    <title>Stream用法</title>
    <url>/2021/08/02/Stream%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h2 id="Stream-如何工作">Stream 如何工作</h2>
<p>stream 包含中间和最终两种形式的操作</p>
<ul>
<li>
<p>中间操作（intermediate operations)</p>
<p>对于中间操作来说，其返回值还是一个<code>stream</code>，因此可以通过链式调用将中间操作串联起来。</p>
<p>中间操作又分为两种状态：</p>
<ol>
<li>
<p>无状态 (Stateless)</p>
<p>无状态操作：是指元素的处理不受之前元素的影响</p>
<ul>
<li><code>unordered</code></li>
<li><code>filter</code> 过滤符合断言的元素</li>
<li><code>map</code> 将元素映射为其它类型</li>
<li><code>mapToInt</code> 将元素映射为 <code>Integer</code> 类型`</li>
<li><code>mapToLong</code> 将元素映射为 <code>Long </code></li>
<li><code>mapToDouble</code> 将元素映射为 <code>Double</code></li>
<li><code>flatMap</code> 用于将<code>N</code>维列表，压缩成一维列表, 一个 <code>flatMap</code>只能降一个维度（可多次调用）</li>
<li><code>flatMapToInt</code> 和 <code>flatMap</code>一致，只是将元素转换为 <code>Integer</code> 类型输出</li>
<li><code>flatMapToLong</code> 同上</li>
<li><code>flatMapToDouble</code>  同上</li>
<li><code>peek</code> 调试</li>
</ul>
</li>
<li>
<p>有状态 (Stateful)</p>
<p>有状态操作：是指该操作只有拿到所有元素之后才能继续下去</p>
<ul>
<li><code>distinct</code> 去重</li>
<li><code>sorted</code> 排序</li>
<li><code>limit</code> 返回前 <code>n</code> 个元素</li>
<li><code>skip</code> 跳过/丢掉前 <code>n</code> 个元素</li>
</ul>
</li>
</ol>
</li>
<li>
<p>最终操作  (terminal operation)</p>
<p>对于最终操作来说，只能返回 <code>void</code> 或者一个非 <code>stream</code> 的结果</p>
<p>最终操作又分为两种操作：</p>
<ol>
<li>
<p>非短路操作</p>
<p>非短路操作：是指必须处理所有元素才能得到最终结果</p>
<ul>
<li><code>forEach</code> 单线程的时候是<strong>顺序</strong>执行，多线程的时候是<strong>乱序</strong>执行</li>
<li><code>forEachOrdered</code> 单线程和多线程都是<strong>顺序</strong>操作</li>
<li><code>toArray 转换为数组</code></li>
<li><code>reduce</code> 计算</li>
<li><code>collect 收集器</code></li>
<li><code>max</code> 根据比较条件查找最大元素</li>
<li><code>min</code> 根据比较条件查找最小元素</li>
<li><code>count</code> 计算元素个数</li>
</ul>
</li>
<li>
<p>短路操作</p>
<p>短路操作：是指遇到某些符合条件的元素就可以得到最终结果</p>
<ul>
<li><code>anyMatch</code> 任意一个元素满足断言才返回 <code>true</code></li>
<li><code>allMatch</code> 所有的元素都必须满足断言才返回 <code>true</code> ，流为空时返回 <code>true</code></li>
<li><code>noneMatch</code> 所有的元素都不满足断言才返回 <code>true</code></li>
<li><code>findFirst</code> 返回流中的第一个元素，或者空，返回类型为 <code>Optional</code></li>
<li><code>findAny</code></li>
</ul>
</li>
</ol>
</li>
</ul>
<ol>
<li>
<p>创建Stream</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 集合流</span></span><br><span class="line">Stream.of(Array.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>));</span><br><span class="line"><span class="comment">// 整数流，用于代替 for 循环</span></span><br><span class="line">IntStream.range(<span class="number">1</span>,<span class="number">100</span>);</span><br><span class="line"><span class="comment">// 等价于 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">100</span>; i++);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接调用集合的 stream</span></span><br><span class="line">List.stream();</span><br><span class="line">Set.stream();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 在下面列出 </span></span><br></pre></td></tr></table></figure>
<ul>
<li>Collection.stream</li>
<li>Collection.parallelStream</li>
<li>java.io.BufferedReader.lines</li>
<li>java.util.stream.IntStream</li>
<li>Random.ints</li>
<li>BitSet.Stream</li>
<li>java.util.Spliterator</li>
</ul>
<p>你还可以自己生成流，只需要提供 <code>Supplier</code> 数据提供者即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Supplier&lt;Student&gt; studentSupplier = () -&gt; &#123;<span class="keyword">new</span> <span class="title class_">Student</span>()&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 Steam.generate 即可生成属于自己的流</span></span><br><span class="line">Stream.generate(studentSupplier).forEach(System.out::println);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>流复用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当我们调用 collect 最终操作后流就被关闭了，如果还继续调用流则报异常</span></span><br><span class="line"><span class="comment">// 例如下面例子</span></span><br><span class="line"><span class="keyword">final</span> Stream&lt;Student&gt; stream = students.stream();</span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">isMatched</span> <span class="operator">=</span> stream.anyMatch((stu) -&gt; stu.getSex().equals(<span class="string">&quot;男&quot;</span>));</span><br><span class="line"><span class="comment">// 这个时候流已经关闭, 报异常</span></span><br><span class="line">stream.anyMatch((stu) -&gt; stu.getSex().equals(<span class="string">&quot;男&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复用流很简单，就是用一个 Supplier 提供流就行了</span></span><br><span class="line">Supplier&lt;Stream&lt;Student&gt;&gt; streamSupplier = students::stream;</span><br><span class="line">streamSupplier.get().collect(Collectors.toList());</span><br><span class="line">streamSupplier.get().collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>forEach</code>用法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 其参数是一个消费者，通常可以这么用</span></span><br><span class="line">forEach(Comsumer&lt;T&gt; comsumer);</span><br><span class="line"></span><br><span class="line">forEach((value) -&gt; &#123;</span><br><span class="line">  <span class="comment">// 处理value，无返回值</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于数组遍历</span></span><br><span class="line">Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>).forEach((v) -&gt; &#123;</span><br><span class="line">  System.out.println(v)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配合 IntStream 就是一个 for循环</span></span><br><span class="line">IntStream.range(<span class="number">1</span>,<span class="number">100</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>map/mapToInt/mapToLong</code> 映射对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当我们从数据库查询出一个 pojo列表时，我们想取出其中的某个属性的值，或者利用此值去生成某些值，并且将这些值组成一个链表，可以用 map 方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> String age;</span><br><span class="line">  <span class="comment">//setter / getter...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存在一个已经有数据的list（偷懒不加数据）</span></span><br><span class="line">List&lt;Student&gt; studentList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一个 Student 对象 映射成 String 类型的对象</span></span><br><span class="line"><span class="comment">// 并且利用收集器收集成为List</span></span><br><span class="line">List&lt;String&gt; nameList = studentList.stream()</span><br><span class="line">  .map(Student::getName)</span><br><span class="line">  .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们也可以利用其中的一个字段映射成为其它对象</span></span><br><span class="line"><span class="comment">// 在这里将 student 中的两个字段合并成字符串返回</span></span><br><span class="line">List&lt;String&gt; otherObject = studentList.stream()</span><br><span class="line">  .map((v) -&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> v.getName() + v.getAge();</span><br><span class="line">  &#125;)</span><br><span class="line">  .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同理 mapToInt/mapToLong 也一样</span></span><br><span class="line">List&lt;Integer&gt; ageList = studentList.stream()</span><br><span class="line">  .mapToInt(Student::getAge)</span><br><span class="line">  .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>flatMap / flatMapToInt / flatMapToLong /flatMapToDouble</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当有一个二维List，你需要将其转为一维的时候，可以用此方法映射</span></span><br><span class="line"><span class="comment">// flatMap只需要返回一个 steam对象即可</span></span><br><span class="line">List&lt;List&lt;Object&gt;&gt; list;</span><br><span class="line">List&lt;Object&gt; ls = list.stream()</span><br><span class="line">  .flatMap(Collection::stream)</span><br><span class="line">  .collect(Collector.toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个实在的例子</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassRoom</span>&#123;</span><br><span class="line">  List&lt;Student&gt; studentList;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一个班级列表，并且每个班级里都有一个学生列表</span></span><br><span class="line">List&lt;ClassRoom&gt; classRoomList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果我们要获取所有学生对象, 就可以用到flatMap</span></span><br><span class="line">List&lt;Student&gt; studentList = classRoomList.stream()</span><br><span class="line">  .flatMap((room) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> room.getStudentList().stream();</span><br><span class="line">  &#125;)</span><br><span class="line">  .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">// flatMapToInt ... 同理  </span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>filter</code> 过滤数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个功能不用讲都知道什么意思了，就是用来过滤数据</span></span><br><span class="line"><span class="comment">// filter 中返回 true，那就允许这个数据通过，否则将其过滤掉</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例如获取年龄大于 10 的学生</span></span><br><span class="line">List&lt;Student&gt; studentList;</span><br><span class="line">List&lt;Student&gt; filtedStudentList = studentList.stream()</span><br><span class="line">  .filter((stu) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> stu.getAge() &gt; <span class="number">10</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">  .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>anyMatch / allMatch / noneMatch</code> 判断元素是否满足条件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// anyMatch, 任意一个元素满足条件则返回 true</span></span><br><span class="line">List&lt;Student&gt; studentList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断学生列表中是否存在张三这个学生，若存在返回 true 否则 返回 false</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isExits</span> <span class="operator">=</span> studentList.stream()</span><br><span class="line">  .anyMatch((stu) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> stu.getName().equals(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// allMatch, 所有元素必须满足条件才返回 true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断所有学生的名字是否都为非空，若都为非空则返回 true 否则 返回 false</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> studentList.stream()</span><br><span class="line">  .allMatch((stu) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> !stu.getName().equals(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// noneMatch 和上面那个相反，所有元素都不能满足条件才返回 true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断所有学生的名字是否都为非空，若都为非空返回 true 否则 返回 false</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> studentList.stream()</span><br><span class="line">  .noneMatch((stu) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> stu.getName().equals(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>max / min / average / sum / count</code> 各种信息统计</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// max 用于求最大值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求所有学生的最大年龄</span></span><br><span class="line">studentList.stream()</span><br><span class="line">  .map(Student::getAge)</span><br><span class="line">  .max();</span><br><span class="line"><span class="comment">// min 用于求最小值</span></span><br><span class="line"><span class="comment">// average 用于求平均值</span></span><br><span class="line"><span class="comment">// sum 用于求和</span></span><br><span class="line"><span class="comment">// count 求数量</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>distinct</code> 去重</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于去重数据，如果是对象你必须重写 hashCode 和 equals 方法</span></span><br><span class="line">studentList.stream()</span><br><span class="line">  .distinct()</span><br><span class="line">  .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>sorted</code> 排序</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个和我们常用的 Collections.sort 差不都，也是提供一个比较器</span></span><br><span class="line">studentList.stream()</span><br><span class="line">.sorted((s1, s2) -&gt; s1.getAge() - s2.getAge())</span><br><span class="line">.collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<ol start="11">
<li><code>collect</code> 收集</li>
</ol>
<p><code>collect</code>负责将流中的元素进行收集，收集方式有很多，<code>jdk</code> 定义了许多收集器</p>
<ul>
<li>
<p><code>Collectors.toList</code> 将流中元素收集为 <code>List</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Student&gt; list = studentList.stream().collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>Collectors.toSet </code> 将流中元素收集为 <code>Set</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;Student&gt; set = studentList.stream().collect(Collectors.toSet());</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>Collectors.toMap</code> 将流中元素收集为 <code>Map</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// map 复杂一点</span></span><br><span class="line"><span class="comment">// 将 student 收集为 map ： id -&gt; age</span></span><br><span class="line">Map&lt;Integer,String&gt; mapping = studentList.stream()</span><br><span class="line">  .collect(Collectors.toMap(Student::getId),Student::getAge);</span><br><span class="line"><span class="comment">// 两个Function接口，分别指定 map 的 key 和 value</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>Collectors.groupingBy</code> 将流中元素按照条件分组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个接口蛮常用的，对于数据库中查询出来的集合，很适合用于分组，比如按ID分组</span></span><br><span class="line">Map&lt;Integer,Student&gt; mapping = studentList.stream()</span><br><span class="line">  .collect(Collectors.groupingBy(Student::getId));</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>Collectors.partitioningBy</code> 将流中元素按照条件分区</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 所谓分区就是根据所给条件，将数据分为满足条件和不满足条件两个部分</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面例子将学生信息按照性别分组</span></span><br><span class="line"><span class="keyword">final</span> Map&lt;Boolean, List&lt;Student&gt;&gt; partitionBySex = students.stream()</span><br><span class="line">                .collect(Collectors.partitioningBy((stu) -&gt; &#123;</span><br><span class="line">                    <span class="keyword">return</span> stu.getSex().equals(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">                &#125;));</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 性别为男</span></span><br><span class="line">partitionBySex.get(<span class="literal">true</span>).forEach(System.out::println);</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 性别为女</span></span><br><span class="line">partitionBySex.get(<span class="literal">false</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>Collectors.mapping</code> 将流中元素映射为其它元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一个参数是 Function 接口，第二个参数是 Collector 收集器接口</span></span><br><span class="line"><span class="comment">// 和 map 不一样的是 第二个参数支持 收集器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果第一个参数 返回的是 一个 </span></span><br><span class="line"><span class="comment">// 算了不讲了 根本不会用 ，下次吧</span></span><br><span class="line">studentList.stream()</span><br><span class="line">  .collect(Collectors.mapping())</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>Collectors.joining</code> 将流中元素连接起来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于将元素连接起来，并且 提供 开始前缀 分隔符 结束后缀</span></span><br><span class="line"><span class="comment">// 比如我要将所有的学生名字连接成这种字符 [name1,name2,name3]</span></span><br><span class="line"></span><br><span class="line">studentList.stream()</span><br><span class="line">  .collect(Collectors.joining(<span class="string">&quot;,&quot;</span>,<span class="string">&quot;[&quot;</span>,<span class="string">&quot;]&quot;</span>));</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="12">
<li>
<p><code>limit</code> 截取流中元素，根据<code>limit</code>定义的长度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 截取流中100个元素</span></span><br><span class="line">studentList.stream()</span><br><span class="line">  .limit(<span class="number">100</span>)</span><br><span class="line">  .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>skip</code> 跳过流中的元素，根据<code>skip</code> 定义的个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 跳过流中的100个元素，直接从第101个元素开始处理</span></span><br><span class="line">studentList.stream()</span><br><span class="line">  .skip(<span class="number">100</span>)</span><br><span class="line">  .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>peek</code> 调试</p>
<p>用于调试每一个步骤的元素内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">studentList.stream()</span><br><span class="line">  .peek(System.out::println) <span class="comment">// 这时候流中的元素是 student 类型</span></span><br><span class="line">  .map(Student::getName)</span><br><span class="line">  .peek(System.out::println) <span class="comment">// 这时候流中元素是 string 类型</span></span><br><span class="line">  <span class="comment">// 功能仅仅是用来调试</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>reduce</code> 计算</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 暂时不写</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>CRUD</category>
      </categories>
      <tags>
        <tag>Stream</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS关闭mds_stores进程</title>
    <url>/2022/04/25/mds_stores/</url>
    <content><![CDATA[<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo launchctl unload -w /System/Library/LaunchDaemons/com.apple.metadata.mds.plist</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>macOS</category>
      </categories>
      <tags>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Security 组件解析</title>
    <url>/2021/08/02/spring%20security%20%E7%BB%84%E4%BB%B6%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h3 id="Spring-Security-组件解析">Spring Security 组件解析</h3>
<ol>
<li>
<p>Authentication （用户身份）</p>
<blockquote>
<p>在 spring security 里，用户身份在不同阶段有着不同的含义</p>
<ul>
<li>在校验开始时，用户身份代表用户输入的用户信息，比如账号、密码、验证码</li>
<li>在校验成功后，用户身份代表用户的真实信息，比如账号、密码、权限</li>
</ul>
<hr>
<p><code>Authentication</code> 接口则是 <code>security</code> 提供的用户身份接口，实现类有常用的 <code>UsernamePasswordAuthenticationToken</code>, 这个接口其包含的最基本的信息如下</p>
<ul>
<li>
<p>authorities</p>
<p>用户身份所拥有的所有权限</p>
</li>
<li>
<p>principal</p>
<p>其代表用户的唯一标识，在校验开始阶段其表示<code>账号</code> ，在校验成功后其表示 <code>UserDetails</code> 也就是用户细节</p>
</li>
<li>
<p>credentials</p>
<p>其代表用户凭证，通常是密码</p>
</li>
<li>
<p>details</p>
<p>其代表细节部分, 默认是<strong>SessionID和IP</strong>， 当然如果要做成验证码, 这里我们也可以自定义</p>
</li>
</ul>
</blockquote>
</li>
<li>
<p>AuthenticationManager (验证器管理器)</p>
<blockquote>
<p>验证器管理器的作用仅仅时用来管理验证器而已，真正的验证功能还是靠验证器来实现</p>
<p>该管理器的默认实现类是 <code>ProviderManager</code></p>
<p>其主要负责管理以下组件:</p>
<ul>
<li>
<p>AuthenticationEventPublisher</p>
<p>验证事件公开者，当验证成功或者失败，其会将此类事件公开，如果我们设置了对应事件的 Handler 那我们就可以监听该类事件，比如说<strong>登录成功事件 或 登录失败事件</strong></p>
</li>
<li>
<p>AuthenticationProvider</p>
<p>身份校验器提供者，也就是身份校验器，用于校验用户身份</p>
</li>
</ul>
<p>这个管理器还有一个 <code>parent</code> 字段，意味其类似于一个链表，和 <code>spring beanFactory</code> 有点相似</p>
</blockquote>
</li>
<li>
<p>AuthenticationEventPublisher</p>
<blockquote>
<p>验证事件公开者, 当验证成功或者失败，其会将此类事件公开, 可以看下它的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AuthenticationEventPublisher</span> &#123;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 验证成功事件</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">publishAuthenticationSuccess</span><span class="params">(Authentication authentication)</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 验证失败事件</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">publishAuthenticationFailure</span><span class="params">(AuthenticationException exception,</span></span><br><span class="line"><span class="params">			Authentication authentication)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>它的默认实现类是 <code>DefaultAuthenticationEventPublisher</code>, 里面多了一个  <code>ApplicationEventPublisher</code> 这个是 <code>spring</code> 的事件公开者， 默认只是将这个事件公开给 <code>spring</code> 上下文</p>
<p><code>security</code> 校验事件，有专门的事件处理器去处理</p>
<ul>
<li>AuthenticationSuccessHandler</li>
<li>AuthenticationFailureHandler</li>
</ul>
</blockquote>
</li>
<li>
<p>AuthenticationProvider</p>
<blockquote>
<p>身份验证提供者，也就是身份校验器,  其有两个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AuthenticationProvider</span> &#123;</span><br><span class="line">	Authentication <span class="title function_">authenticate</span><span class="params">(Authentication authentication)</span></span><br><span class="line">			<span class="keyword">throws</span> AuthenticationException;</span><br><span class="line"></span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Class&lt;?&gt; authentication)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>authenticate</p>
<p>这个方法作用就是用来校验用户信息的，它的返回值和参数是一样的，这就是为什么说用户身份这个东西在校验开始和校验成功后代表的含义是不一样的原因。</p>
</li>
<li>
<p>supports</p>
<p>用户返回我们的校验器是否支持此类用户身份</p>
</li>
</ul>
<p>该接口的默认实现类是</p>
<p><code>AbstractUserDetailsAuthenticationProvider</code> 其封装了基本的验证逻辑</p>
<p><code>DaoAuthenticationProvider</code> 默认的校验器</p>
</blockquote>
</li>
<li>
<p>PasswordEncoder</p>
<blockquote>
<p>密码加密和校验器，用于加密和校验密码，暂且看下它的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PasswordEncoder</span> &#123;</span><br><span class="line"></span><br><span class="line">	String <span class="title function_">encode</span><span class="params">(CharSequence rawPassword)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(CharSequence rawPassword, String encodedPassword)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">upgradeEncoding</span><span class="params">(String encodedPassword)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>encode</p>
<p>用于加密密码，算法可以自定义</p>
</li>
<li>
<p>matches</p>
<p>用户校验密码</p>
</li>
<li>
<p>upgradeEncoding</p>
<p>用户更新密码</p>
</li>
</ul>
<p>默认的实现类是 <code>BCryptPasswordEncoder</code></p>
</blockquote>
</li>
<li>
<p>UserDetailsService</p>
<blockquote>
<p>该服务接口用于拿到用户的身份信息，一般从数据库和内存中获取，这个服务提供给 <code>AuthenticationProvider</code> 使用</p>
<p>其只有一个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException;</span><br></pre></td></tr></table></figure>
<p>其中 <code>UserDetails</code> 接口包含了用户的身份信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDetails</span> <span class="keyword">extends</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">	<span class="comment">// 用户的权限</span></span><br><span class="line">	Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities();</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 用户密码</span></span><br><span class="line">	String <span class="title function_">getPassword</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用户名</span></span><br><span class="line">	String <span class="title function_">getUsername</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 账号未过期</span></span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">isAccountNonExpired</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 账号未被锁定</span></span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">isAccountNonLocked</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 账号密码已过期</span></span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">isCredentialsNonExpired</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 账号启用</span></span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">isEnabled</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li>
<p>AbstractAuthenticationProcessingFilter</p>
<blockquote>
<p>万物基于 <code>Filter</code> 这句话没毛病，<code>spring security</code> 也如此，这个类贯穿了整个 <code>sprign security</code> 的验证过程</p>
<p>它有一个重要的参数:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFilterProcessesUrl</span><span class="params">(String filterProcessesUrl)</span></span><br></pre></td></tr></table></figure>
<p>这个 <code>URL</code> 是用于指定身份验证的<code>URL</code>，当拦截器拦截到这个地址时，<code>spring security</code> 就会从里面拿到用户信息然后进行身份验证。</p>
</blockquote>
</li>
<li>
<p>组件依赖关系</p>
<img src="/2021/08/02/spring%20security%20%E7%BB%84%E4%BB%B6%E8%A7%A3%E6%9E%90/1577931074069.png" class="">
</li>
</ol>
]]></content>
      <categories>
        <category>Spring Security</category>
      </categories>
      <tags>
        <tag>Spring Security</tag>
      </tags>
  </entry>
  <entry>
    <title>DB程序员 项目注意点</title>
    <url>/2021/08/02/%E9%A1%B9%E7%9B%AE%E6%B3%A8%E6%84%8F%E7%82%B9/</url>
    <content><![CDATA[<ol>
<li>禁止在循环中查询数据库，应当采用批量查询方式</li>
<li>如果为数据量比较大的表，直接用分页查询插件</li>
<li>表中某些字段为可空的情况下，查出来的数据一定要判空</li>
</ol>
]]></content>
      <tags>
        <tag>DB</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker搭建Gitlab</title>
    <url>/2021/07/31/CI-CD/Docker%E6%90%AD%E5%BB%BAGitlab-docker%E6%90%AD%E5%BB%BAgitlab/</url>
    <content><![CDATA[<ul>
<li>拉取镜像</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker pull gitlab/gitlab-ce:latest</span></span><br></pre></td></tr></table></figure>
<ul>
<li>运行Gitlab容器</li>
</ul>
<blockquote>
<p>使用docker命令运行容器，注意修改hostname为自己喜欢的名字，-v部分挂载目录要修改为自己的目录。<br>
端口映射这里使用的都是安全端口，如果大家的环境没有端口限制或冲突可以使用与容器同端口，如：-p 443:443 -p 80:80 -p 22:22</p>
</blockquote>
<ul>
<li>写一个Shell文件启动配置</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim gitlab-start.sh</span><br><span class="line">sudo docker run --detach \</span><br><span class="line">  --hostname gitlab.example.com \</span><br><span class="line">  --publish 8844:443 --publish 7766:80 --publish 2222:22 \</span><br><span class="line">  --name gitlab \</span><br><span class="line">  --restart always \</span><br><span class="line">  --volume $HOME/gitlab/config:/etc/gitlab \</span><br><span class="line">  --volume $HOME/gitlab/logs:/var/log/gitlab \</span><br><span class="line">  --volume $HOME/gitlab/data:/var/opt/gitlab \</span><br><span class="line">  gitlab/gitlab-ce:latest</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>其中 v 选项将 gitlab 的目录挂载为用户当地目录，以免容器在停止或被删除的时候丢失数据。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sh gitlab-start.sh</span></span><br></pre></td></tr></table></figure>
<ul>
<li>进入容器设置初始化root用户</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it &lt;container id&gt; bash</span><br><span class="line">gitlab-rails console</span><br><span class="line">user = User.where(username: ‘root’).first</span><br><span class="line">user.password = ‘password’</span><br><span class="line">user.save!</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<img src="/2021/07/31/CI-CD/Docker%E6%90%AD%E5%BB%BAGitlab-docker%E6%90%AD%E5%BB%BAgitlab/1BCE4453-3F8A-4EF1-A3F9-DF401148781B-0cc36e63f7744de09f36a03b004a7d4a.png" class="">
]]></content>
      <categories>
        <category>CI/CD</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Drone-ci 入门</title>
    <url>/2020/05/02/CI-CD/Drone-ci%20%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="Drone-CI-基本操作">Drone CI 基本操作</h2>
<h3 id="1-Drone-Server">1. Drone-Server</h3>
<p>Drone-server是整个CI的核心，<code>drone.yml</code>的解析以及与其它各个<code>git</code>平台的集成，还有<code>UI</code>的显示等功能. 其必须运行在<code>docker</code>环境下, 配置文件如下。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">drone-server:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">drone/drone:latest</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">3306</span><span class="string">:80</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">10043</span><span class="string">:443</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/lib/drone:/var/lib/drone</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DRONE_GITHUB_CLIENT_ID=</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DRONE_GITHUB_CLIENT_SECRET=</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DRONE_RPC_SECRET=a7ab0d75fe294718575953b164c12ddf</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DRONE_RPC_PROTO=http</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DRONE_SERVER_HOST=you</span> <span class="string">host</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DRONE_SERVER_PROTO=http</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DRONE_SECRET=462e36f444bd7ba17d2372f2b391ba5f</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DRONE_LOGS_DEBUG=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DRONE_LOGS_TEXT=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DRONE_LOGS_PRETTY=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DRONE_LOGS_COLOR=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DRONE_LOGS_TRACE=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DRONE_RPC_DUMP_HTTP=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DRONE_RPC_DUMP_HTTP_BODY=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DRONE_UI_USERNAME=root</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DRONE_UI_PASSWORD=root</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DRONE_USER_CREATE=username:lyqingye,admin:true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DRONE_OPEN=true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><code>DRONE_RPC_SECRET</code> 为远程调用的秘钥，因为<code>Drone</code>可以是分布式的，其其它组件可以通过远程调用的方式与<code>Server</code>通信。</li>
<li><code>DRONE_SERVER_HOST</code> 为你的主机地址，<code>Drone UI</code>的地址，可以看到在<code>Docker</code>配置中，我做了一个端口映射<code>3306:80</code>, <code>Drone-Server</code> 默认运行在 <code>80</code>端口，所以我的主机地址应该填<code>xxx:3306</code></li>
<li><code>DRONE_GITHUB_CLIENT_ID</code> 和 <code>DRONE_GITHUB_CLIENT_SECRET</code> 在 <code>https://github.com/settings/developers</code> 中申请。</li>
</ul>
<h3 id="2-Drone-runner">2. Drone-runner</h3>
<p>在<code>Drone</code>中支持许多个<code>runner</code>， 其作用是用来执行 <code>pipeline</code> 中的任务。其支持以下几种类型的<code>runner</code></p>
<ul>
<li><code>docker</code> 将 <code>pipeline</code> 放在<code>docker</code>环境中运行</li>
<li><code>exec</code> 将<code>pipeline</code> 以 <code>ssh</code>协议运行在远程服务器中</li>
<li><code>ssh</code> 将<code>pipeline</code> 以 <code>ssh</code>协议运行在远程服务器中</li>
</ul>
<p><code>runner-docker</code>配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"> <span class="attr">drone-runner:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">drone/drone-runner-docker</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">drone-server</span></span><br><span class="line"><span class="comment">#    ports:</span></span><br><span class="line"><span class="comment">#      - 3000:3000</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/run/docker.sock:/var/run/docker.sock</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DRONE_RPC_SECRET=a7ab0d75fe294718575953b164c12ddf</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DRONE_RPC_HOST=:3306</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DRONE_RPC_PROTO=http</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DRONE_LOGS_DEBUG=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DRONE_LOGS_TEXT=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DRONE_LOGS_PRETTY=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DRONE_LOGS_COLOR=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DRONE_LOGS_TRACE=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DRONE_RPC_DUMP_HTTP=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DRONE_RPC_DUMP_HTTP_BODY=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DRONE_UI_USERNAME=root</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DRONE_UI_PASSWORD=root</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DRONE_TRACE=true</span></span><br></pre></td></tr></table></figure>
<p><code>runner-ssh</code> 配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">drone-ssh-runner:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">drone/drone-runner-ssh</span></span><br><span class="line">  <span class="attr">depends_on:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">drone-server</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/var/run/docker.sock:/var/run/docker.sock</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">DRONE_RPC_SECRET=a7ab0d75fe294718575953b164c12ddf</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">DRONE_RPC_HOST=:3306</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">DRONE_RPC_PROTO=http</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">DRONE_LOGS_DEBUG=true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">DRONE_LOGS_TEXT=true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">DRONE_LOGS_PRETTY=true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">DRONE_LOGS_COLOR=true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">DRONE_LOGS_TRACE=true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">DRONE_RPC_DUMP_HTTP=true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">DRONE_RPC_DUMP_HTTP_BODY=true</span></span><br></pre></td></tr></table></figure>
<h3 id="3-pipeline">3.pipeline</h3>
<p><code>pipeline</code>中包含了许多个 <code>step</code> 用来自定义构建步骤，示例一个 <code>runner-docker</code>类型的 <code>.drone.yml</code> 配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">pipeline</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">docker</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">default</span></span><br><span class="line"></span><br><span class="line"><span class="attr">platform:</span></span><br><span class="line">  <span class="attr">os:</span> <span class="string">linux</span></span><br><span class="line">  <span class="attr">arch:</span> <span class="string">amd64</span></span><br><span class="line"></span><br><span class="line"><span class="attr">steps:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">clone_all_projects</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">appleboy/drone-ssh</span></span><br><span class="line">    <span class="attr">settings:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">***</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">***</span></span><br><span class="line">      <span class="attr">script:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">cd</span> <span class="string">/root</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">if</span> [ <span class="string">!</span> <span class="string">-d</span> <span class="string">&quot;wzj-common&quot;</span> ]<span class="string">;then</span> <span class="string">git</span> <span class="string">clone</span> <span class="string">-b</span> <span class="string">dev</span> <span class="string">***.git;</span> <span class="string">else</span> <span class="string">cd</span> <span class="string">wzj-common;</span> <span class="string">git</span> <span class="string">pull</span> <span class="string">origin</span> <span class="string">dev;</span> <span class="string">cd</span> <span class="string">..;</span> <span class="string">fi</span></span><br><span class="line">       </span><br></pre></td></tr></table></figure>
<p>首先在开头可以看到 <code>type: docker</code> 说明这个<code>pipeline</code> 是在<code>runner-docker</code>中运行.<br>
在每一个<code>step</code>中我们可以指定一个镜像去完成我们的构建操作，上面示例中，我用到了<code>drone-ssh</code> 来实现远程执行命令来 <code>clone</code> 源码文件，当然当你编译完后你还可以利用 <code>drone-scp</code> 将目标文件拷贝到远程服务器来进行部署.</p>
]]></content>
      <categories>
        <category>CI/CD</category>
      </categories>
      <tags>
        <tag>Drone-ci</tag>
      </tags>
  </entry>
  <entry>
    <title>Gradle Dependencies Cache CI/CD场景</title>
    <url>/2021/11/05/CI-CD/Gradle%E7%BC%93%E5%AD%98%E4%BE%9D%E8%B5%96%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<h3 id="Gradle是当下最流行的构建工具，下面讲CI-CD场景">Gradle是当下最流行的构建工具，下面讲CI/CD场景</h3>
<blockquote>
<p>Gradle构建可以指定本地maven仓库和远程仓库地址，根据配置优先策略寻找构建所需依赖。</p>
</blockquote>
<ol>
<li>但从远程下载但jar并不是存储在本地maven仓库，而是缓存在目录：<code>~/.gradle/caches/modules-2/files-2.1</code>（一般情况）,<br>
Docker Gradle Image默认缓存目录：<code>/home/gradle/.gradle/caches/modules-2/files-2.1</code></li>
<li>还有就是caches <code>Copy</code>别到的主机上是不能够直接使用的，有验证策略，这里不过多赘述</li>
<li>Gradle构建的依赖来源于<code>~/.gradle/caches/modules-2/files-2.1</code> &gt; 本地maven仓库 &gt; 远程仓库（优先级从左到右）</li>
</ol>
<blockquote>
<p>每次构建都会寻找依赖（从<code>~/.gradle/caches/modules-2/files-2.1</code>查找，一般我们都设置有maven本地仓库），若本地仓库没有依赖，默认从远程仓库下载，而下载的依赖缓存在上述目录。</p>
</blockquote>
<ol start="5">
<li>CI/CD环境下依赖一般不需要重复下载依赖，因此可以提前下载依赖缓存起来（比如Docker环境下利用Docker到缓存机制缓存镜像层）</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// build.gradle</span></span><br><span class="line">task cacheDependencies &#123;</span><br><span class="line">    setDescription <span class="string">&quot;Resolves all projects dependencies from the repository.&quot;</span></span><br><span class="line">    setGroup <span class="string">&quot;Build Server&quot;</span></span><br><span class="line"></span><br><span class="line">    doLast &#123;</span><br><span class="line">        rootProject.allprojects &#123; project -&gt;</span><br><span class="line">            println <span class="string">&quot;&gt;&gt; &quot;</span> + project</span><br><span class="line">            Set&lt;Configuration&gt; configurations =</span><br><span class="line">                    project.buildscript.configurations +</span><br><span class="line">                            project.configurations</span><br><span class="line">            configurations</span><br><span class="line">                    .findAll &#123; it.canBeResolved &#125;</span><br><span class="line">                    .forEach &#123;</span><br><span class="line">                        resolveDependencies(it)</span><br><span class="line">                    &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> cacheDependencies(Configuration it) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Set&lt;File&gt; files = it.resolve()</span><br><span class="line">        DependencySet set = it.allDependencies</span><br><span class="line">        <span class="keyword">if</span> (set.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            println <span class="string">&quot;&gt;&gt;&gt; &quot;</span> + it</span><br><span class="line">            println <span class="string">&quot;&gt;&gt;&gt;&gt; Dependencies &quot;</span></span><br><span class="line">            set.forEach &#123;</span><br><span class="line">                println <span class="string">&quot;&gt;&gt;&gt;&gt;&gt; &quot;</span> +</span><br><span class="line">                        it.group + <span class="string">&quot;:&quot;</span> +</span><br><span class="line">                        it.name + <span class="string">&quot;:&quot;</span> +</span><br><span class="line">                        it.version</span><br><span class="line">            &#125;</span><br><span class="line">            println <span class="string">&quot;&gt;&gt;&gt;&gt; Files&quot;</span></span><br><span class="line">            files.forEach &#123;</span><br><span class="line">                println <span class="string">&quot;&gt;&gt;&gt;&gt;&gt; &quot;</span> + it.canonicalPath</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        println <span class="string">&quot;&gt;&gt;&gt; &quot;</span> + it</span><br><span class="line">        println <span class="string">&quot;&gt;&gt;&gt;&gt; &quot;</span> + e.message</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>当然特殊环境下（比如在公司的项目内网仓库上，并且没有开放权限，只打包缓存依赖包用），上面提到了直接<code>Copy</code>缓存依赖包，Gradle存在验证机制，是不能够使用的</li>
</ol>
<blockquote>
<p>那么解决只能是将缓存的依赖转为maven仓库依赖，它们之间的文件存放方式有稍稍不同，需要手动处理。</p>
</blockquote>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// build.gradle</span></span><br><span class="line">task copy &#123;</span><br><span class="line">    copyDependencies()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">def</span> copyDependencies() &#123;</span><br><span class="line">    <span class="keyword">final</span> String source =  System.getProperty(<span class="string">&quot;user.home&quot;</span>) + <span class="string">&quot;/.gradle/caches/modules-2/files-2.1&quot;</span></span><br><span class="line">    <span class="keyword">final</span> String destRoot = System.getProperty(<span class="string">&quot;user.home&quot;</span>) + <span class="string">&quot;/.m2/repository&quot;</span></span><br><span class="line">    File rootFile = <span class="keyword">new</span> File(source);</span><br><span class="line">    <span class="keyword">for</span> (File <span class="attr">file :</span> rootFile.listFiles()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (file.isDirectory() &amp;&amp; file.getName()) &#123;</span><br><span class="line">            <span class="comment">// Convert package name to file hierarchy</span></span><br><span class="line">            String destDir = file.getName().replace(<span class="string">&quot;.&quot;</span>, File.separator);</span><br><span class="line">            copyDependenciesFiles(file, source + File.separator + file.getName(), destRoot + File.separator + destDir)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">def</span> copyDependenciesFiles(File rootFile, String source, String destRoot) &#123;</span><br><span class="line">    <span class="keyword">for</span> (File <span class="attr">subFile :</span> rootFile.listFiles()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (subFile.getName() != <span class="string">&quot;.DS_Store&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (subFile.isDirectory()) &#123;</span><br><span class="line">                copyDependenciesFiles(subFile, source, destRoot)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                File md5Dir = <span class="keyword">new</span> File(subFile.getParent())</span><br><span class="line">                String copyPath = <span class="keyword">new</span> File(md5Dir.getParent()).getAbsolutePath().replace(source, destRoot)</span><br><span class="line">                File copyDir = <span class="keyword">new</span> File(copyPath);</span><br><span class="line">                <span class="keyword">if</span> (!copyDir.exists()) &#123;</span><br><span class="line">                    copyDir.mkdirs()</span><br><span class="line">                &#125;</span><br><span class="line">                File destFile = <span class="keyword">new</span> File(copyDir, subFile.getName())</span><br><span class="line">                <span class="comment">// When copying, it is found that there may be multiple versions of the same package and the same version.</span></span><br><span class="line">                <span class="comment">// Print out here that there are multiple dependent packages but do not copy</span></span><br><span class="line">                <span class="keyword">if</span> (destFile.exists()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;exists dependencies: &quot;</span> + subFile.getAbsolutePath());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;source dirctrory: &quot;</span> + subFile.getAbsolutePath() + <span class="string">&quot; &gt;&gt;&gt;&gt;&gt; targer dirctrory: &quot;</span> + destFile.getAbsolutePath())</span><br><span class="line">                        Files.copy(subFile.toPath(), destFile.toPath());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Example<br>
<a href="https://github.com/zf1976/vertx-ddns">https://github.com/zf1976/vertx-ddns</a></li>
</ul>
]]></content>
      <categories>
        <category>CI/CD</category>
      </categories>
      <tags>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>LXC容器挂载目录</title>
    <url>/2022/02/02/PVE/LXC%E5%AE%B9%E5%99%A8%E6%8C%82%E8%BD%BD%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<p>  笔者在PVE中跑LXC容器，用来挂网心云，涉及到磁盘分配目录大小。<br>
  LXC容器要挂载磁盘在PVE Web控制台操作起来相当麻烦，必须要先创建存储区，而且文件是使用存raw格式的镜像做存储磁盘。<br>
  并且LXC容器不存在和VM一样的硬盘直通，使用方式更多的像<code>Docker</code>，所以理解磁盘挂在的方式可以用<code>Docker</code>的方式来理解。</p>
<ul>
<li>比如 把PVE宿主机<code>/dev/sda</code>分区磁盘挂在宿主<code>/mnt/wd/wxcloud</code>目录下，那么LXC容器中挂载方式为：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pct set &lt;lxc id&gt; -mp1 /mnt/wd/wxcloud,mp=/root/wxcloud</span><br></pre></td></tr></table></figure>
<p>  左侧<code>/mnt/wd/wxcloud</code>为宿主机目录路径，则右边<code>/root/wxcloud</code>为LXC容器目录路径</p>
<ul>
<li>更多详细操作请参考： <a href="https://pve.proxmox.com/pve-docs/chapter-pct.html#pct_mount_points">文档</a></li>
</ul>
]]></content>
      <categories>
        <category>PVE</category>
      </categories>
      <tags>
        <tag>LXC</tag>
      </tags>
  </entry>
  <entry>
    <title>PVE、Docker macvlan网心云多开方案</title>
    <url>/2022/02/02/PVE/PVE%E3%80%81Docker%E7%BD%91%E5%BF%83%E4%BA%91%E5%A4%9A%E5%BC%80%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h3 id="前言-2">前言</h3>
<p>  最近折腾网络，弄了几条宽带，打算用闲置公网宽带来挂网心云来回本电费。简单讲，网心云群晖什么的搞桥接多开（我没有群晖），或者直接单开，都稍微有点麻烦了。为什么不用x86镜像？肯定是麻烦啊，docker稍微方便点。或许你可以用PVE LXC模版方案套娃来跑docker网心云，但是经过我的测试，没有办法做到。 当然可能有人做到了，说明我菜。</p>
<img src="/2022/02/02/PVE/PVE%E3%80%81Docker%E7%BD%91%E5%BF%83%E4%BA%91%E5%A4%9A%E5%BC%80%E6%96%B9%E6%A1%88/img.png" class="">
<h3 id="Docker跑网心云目前玩过的几种方式">Docker跑网心云目前玩过的几种方式</h3>
<p>  网心云Docker目前只支持<code>host</code>跟<code>macvlan</code>两种网络模式</p>
<ul>
<li>使用host网络模式（Windows、macOS不支持）</li>
</ul>
<p>  缺点就是有点单一了，跟宿主机同一个网络，万一你宿主机是公网DMZ主机（我这里假设是DMZ主机是服务器，你总得搞防火墙端口限制吧，如果你自己搞NAT当我没说）怎么办？Docker网心云含有一个web管理业务页面，而且不带验证的，就意味着有可能被人搞（默认18888端口），你总不能说我走NAT，或者把端口禁了、再或者用个服务把页面给拦截。但是，网心云NAT类型就会识别为全锥型了，那么就会导致收益下降。</p>
<ul>
<li>使用macvlan网络模式
<blockquote>
<p>macvlan支持的两种模式，但是需要牺牲掉一个网卡(可以使用虚拟网卡或物理网卡，下面详细讲)。</p>
</blockquote>
<ol>
<li>Bridge模式：不创建子接口的情况下直接去桥接网卡，可以直接桥接到与宿主级的同网段。</li>
<li>VLAN Bridge模式：创建子接口去桥接物理接口。可划分多个VLAN。</li>
</ol>
</li>
</ul>
<p>  这里只讨论<code>Bridge模式</code>。<br>
  macvlan跟PVE网络vmbr桥接很相似了，可以直接绑定物理或虚拟网卡，比如PVE中LXC容器内的虚拟网卡。同时也可以直接把网卡虚拟出子网卡。支持<code>Bridge模式</code>、<code>VLAN Bridge模式</code>模式，这里就不细说，请查看:<a href="https://docs.docker.com/network/macvlan/">Docker文档</a> ，我们主要使用桥接模式就可以了。</p>
<p>  <code>Bridge模式</code>实际上就是绑定一个网卡进出口，PVE虚拟交换机也是一样。那么docker容器指定这个macvlan网络就可以成为网段内设备，网口线拉到路由所在交换机交给软路由去分流，亦或者直接桥接到宿主机内部虚拟机交换机的接到虚拟机路由也可以，多条宽带也是可以的。开启upnp就完事了。</p>
<h2 id="虚拟网卡、物理网卡，创建macvlan网络">虚拟网卡、物理网卡，创建macvlan网络</h2>
<h3 id="物理网卡篇">物理网卡篇</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker network create -d macvlan --subnet=192.168.1.1/24 --gateway=192.168.1.1 -o parent=ensxxx macvlan_net</span><br></pre></td></tr></table></figure>
<ul>
<li>-d macvlan 指定网络驱动程序为macvlan</li>
<li>–subnet 指定一个子网段</li>
<li>–gateway 路由网关</li>
<li>-o parent=ensxxx 绑定物理网卡</li>
<li>macvlan_net 自定义网络名称</li>
</ul>
<blockquote>
<p>物理网卡id怎么看？</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看网卡设备</span></span><br><span class="line">ifconfig -a</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看的是已启用的网卡设备</span></span><br><span class="line">ifcofnig </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启用网卡，开机启用就不多说了，自行百度</span></span><br><span class="line">ifconfig wlp4s0 up</span><br></pre></td></tr></table></figure>
<ul>
<li>下面可以看到我的无线Wi-Fi网卡识别为<code>wlp4s0</code>，这个就是物理网卡标识符</li>
</ul>
<img src="/2022/02/02/PVE/PVE%E3%80%81Docker%E7%BD%91%E5%BF%83%E4%BA%91%E5%A4%9A%E5%BC%80%E6%96%B9%E6%A1%88/img_1.png" class="">
<h3 id="虚拟网卡篇">虚拟网卡篇</h3>
<blockquote>
<p>使用的PVE下的OVS Bride桥接虚拟网卡(依赖openvswitch-switch)，需要安装openvswitch-switch。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install openvswitch-switch</span><br></pre></td></tr></table></figure>
<ul>
<li>创建OVS Bridge</li>
</ul>
<img src="/2022/02/02/PVE/PVE%E3%80%81Docker%E7%BD%91%E5%BF%83%E4%BA%91%E5%A4%9A%E5%BC%80%E6%96%B9%E6%A1%88/1.png" class="">
<blockquote>
<p>上图创建了名为vmbr1的OVS Bridge虚拟交换机。</p>
</blockquote>
<ul>
<li>创建OVS IntPort</li>
</ul>
<img src="/2022/02/02/PVE/PVE%E3%80%81Docker%E7%BD%91%E5%BF%83%E4%BA%91%E5%A4%9A%E5%BC%80%E6%96%B9%E6%A1%88/2.png" class="">
<blockquote>
<p>上图中创建名为internal的OVS IntPort是绑定到名为vmbr1的OVS Bridge虚拟交换机中。</p>
</blockquote>
<ul>
<li>创建macvlan</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker network create -d macvlan --subnet=192.168.1.1/24 --gateway=192.168.1.1 -o parent=internal macvlan_net</span><br></pre></td></tr></table></figure>
<ul>
<li>-d macvlan 指定网络驱动程序为macvlan</li>
<li>–subnet 指定一个子网段</li>
<li>–gateway 路由网关</li>
<li>-o parent=internal 绑定虚拟网卡网卡</li>
<li>macvlan_net 自定义网络名称</li>
</ul>
<h2 id="总结">总结</h2>
<blockquote>
<p>虚拟网卡多开的好处是不需要牺牲掉一个物理网口，同时OVS Bridge也可以绑定物理网卡端口，可以支持多开的网心云网络连接到内部（虚拟机路由网络）或外部的路由网络。</p>
</blockquote>
<ol>
<li>如果需要访问网心云容器，需要将桥接网络设置为与宿主级相同网络。</li>
<li>单个网卡只能绑定一次（可以绑定虚拟网卡）。</li>
<li>并且每个容器都有一个独立ip，也就是说可以多开网心云了</li>
</ol>
<ul>
<li>通信测试</li>
</ul>
<p>  笔者使用的是pve搭建的ikuai路由虚拟机，lan口桥接到了vmbr1。</p>
<img src="/2022/02/02/PVE/PVE%E3%80%81Docker%E7%BD%91%E5%BF%83%E4%BA%91%E5%A4%9A%E5%BC%80%E6%96%B9%E6%A1%88/3.png" class="">
<p>  下面可以看到指定容器ip为 <code>192.168.1.100</code>,已经ping通网关。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it --rm --net macvlan_net --ip=192.168.1.100 alpine ping 192.168.1.1</span><br></pre></td></tr></table></figure>
<img src="/2022/02/02/PVE/PVE%E3%80%81Docker%E7%BD%91%E5%BF%83%E4%BA%91%E5%A4%9A%E5%BC%80%E6%96%B9%E6%A1%88/img_2.png" class="">
]]></content>
      <categories>
        <category>PVE</category>
      </categories>
      <tags>
        <tag>网心云、docker</tag>
      </tags>
  </entry>
  <entry>
    <title>PVE、使用hostapd创建无线AP</title>
    <url>/2022/02/04/PVE/PVE%E3%80%81%E4%BD%BF%E7%94%A8hostapd%E5%88%9B%E5%BB%BA%E6%97%A0%E7%BA%BFAP/</url>
    <content><![CDATA[<h1>hostapd介绍</h1>
<p>  Hostapd（Host access point daemon）是一个用户空间软件接入点，能够将普通的网络接口卡变成接入点和认证服务器。当前版本支持 Linux（主机 AP、madwifi、基于 mac80211 的驱动程序）和 FreeBSD（net80211)</p>
<h3 id="它能做什么？">它能做什么？</h3>
<ul>
<li>创建一个AP</li>
<li>在同一张卡上创建多个AP（如果卡支持，通常最多8个）</li>
<li>在一个卡上创建一个 AP，在第二个卡上创建另一个 AP，所有这些都在一个 Hostapd 实例中</li>
<li>在同一张卡上同时使用 2.4GHz 和 5GHz。这需要一张支持两种无线频率Wi-Fi网卡，这非常罕见（但 hostapd 支持它）——如果卡创建了两个 wlanX 接口，你可能会很幸运</li>
</ul>
<h3 id="它不能做什么">它不能做什么?</h3>
<ul>
<li>在同一张卡的不同通道上创建多个 AP。同一张卡上的多个AP将共享同一个信道</li>
<li>创建一个双频 AP，即使有两张卡。但它可以创建两个具有相同 SSID 的 AP</li>
<li>为连接到 AP 的设备分配 IP，为此需要 dhcp 服务器</li>
<li>为 AP 本身分配 IP，这不是 hostapd 的工作</li>
</ul>
<h3 id="IP、DHCP-和路由">IP、DHCP 和路由</h3>
<p>  Hostapd 只创建无线以太网交换机，它不知道 IP 协议或路由。</p>
<h1>PVE（Debian）应用hostapd</h1>
<p>  使用hostapd将无线网卡创建为无线AP可以方便连接到pve内部网络进行管理。</p>
<ul>
<li>PVE安装hostapd<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt install hostapd -y</span><br></pre></td></tr></table></figure>
</li>
<li>查看默认配置文件路径<br>
  安装好hostapd，查看<code>/etc/default/hostapd</code>，默认DAEMON_CONF配置路径</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /ect/default/hostapd</span><br></pre></td></tr></table></figure>
<img src="/2022/02/04/PVE/PVE%E3%80%81%E4%BD%BF%E7%94%A8hostapd%E5%88%9B%E5%BB%BA%E6%97%A0%E7%BA%BFAP/img.png" class="">
<ul>
<li>编辑默认配置文件<br>
  用vim编辑<code>/etc/hostapd/hostapd.conf</code>添加以下内容后保存</li>
</ul>
<blockquote>
<p>2.4GHz</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pve bridge</span></span><br><span class="line">bridge=vmbr0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">AP netdevice name (without <span class="string">&#x27;ap&#x27;</span> postfix, i.e., wlan0 uses wlan0ap <span class="keyword">for</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">management frames); ath0 <span class="keyword">for</span> madwifi</span></span><br><span class="line">interface=wlp4s0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Driver interface <span class="built_in">type</span> (hostap/wired/madwifi/test/none/nl80211/bsd);</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">default: hostap). nl80211 is used with all Linux mac80211 drivers.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Use driver=none <span class="keyword">if</span> building hostapd as a standalone RADIUS server that does</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">not control any wireless/wired driver.</span></span><br><span class="line">driver=nl80211</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">SSID to be used <span class="keyword">in</span> IEEE 802.11 management frames</span></span><br><span class="line">ssid=wifi_anme</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Operation mode (a = IEEE 802.11a, b = IEEE 802.11b, g = IEEE 802.11g,</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ad = IEEE 802.11ad (60 GHz); a/g options are used with IEEE 802.11n, too, to</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">specify band)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Default: IEEE 802.11b</span></span><br><span class="line">hw_mode=b</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Channel number (IEEE 802.11)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(default: 0, i.e., not <span class="built_in">set</span>)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Please note that some drivers <span class="keyword">do</span> not use this value from hostapd and the</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">channel will need to be configured separately with iwconfig.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># If CONFIG_ACS build option is enabled, the channel can be selected</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">automatically at run time by setting channel=acs_survey or channel=0, both of</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">which</span> will <span class="built_in">enable</span> the ACS survey based algorithm.</span></span><br><span class="line">channel=1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Station MAC address -based authentication</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Please note that this kind of access control requires a driver that uses</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hostapd to take care of management frame processing and as such, this can be</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">used with driver=hostap or driver=nl80211, but not with driver=madwifi.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">0 = accept unless <span class="keyword">in</span> deny list</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1 = deny unless <span class="keyword">in</span> accept list</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2 = use external RADIUS server (accept/deny lists are searched first)</span></span><br><span class="line">macaddr_acl=0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">IEEE 802.11 specifies two authentication algorithms. hostapd can be</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">configured to allow both of these or only one. Open system authentication</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">should be used with IEEE 802.1X.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Bit fields of allowed authentication algorithms:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bit 0 = Open System Authentication</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bit 1 = Shared Key Authentication (requires WEP)</span></span><br><span class="line">auth_algs=3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Send empty SSID <span class="keyword">in</span> beacons and ignore probe request frames that <span class="keyword">do</span> not</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">specify full SSID, i.e., require stations to know SSID.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">default: disabled (0)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1 = send empty (length=0) SSID <span class="keyword">in</span> beacon and ignore probe request <span class="keyword">for</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">    broadcast SSID</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2 = clear SSID (ASCII 0), but keep the original length (this may be required</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">    with some clients that <span class="keyword">do</span> not support empty SSID) and ignore probe</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">    requests <span class="keyword">for</span> broadcast SSID</span></span><br><span class="line">ignore_broadcast_ssid=0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Enable WPA. Setting this variable configures the AP to require WPA (either</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">WPA-PSK or WPA-RADIUS/EAP based on other configuration). For WPA-PSK, either</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">wpa_psk or wpa_passphrase must be <span class="built_in">set</span> and wpa_key_mgmt must include WPA-PSK.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Instead of wpa_psk / wpa_passphrase, wpa_psk_radius might suffice.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">For WPA-RADIUS/EAP, ieee8021x must be <span class="built_in">set</span> (but without dynamic WEP keys),</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">RADIUS authentication server must be configured, and WPA-EAP must be included</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">in</span> wpa_key_mgmt.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">This field is a bit field that can be used to <span class="built_in">enable</span> WPA (IEEE 802.11i/D3.0)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">and/or WPA2 (full IEEE 802.11i/RSN):</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bit0 = WPA</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bit1 = IEEE 802.11i/RSN (WPA2) (dot11RSNAEnabled)</span></span><br><span class="line">wpa=2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">WPA pre-shared keys <span class="keyword">for</span> WPA-PSK. This can be either entered as a 256-bit</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">secret <span class="keyword">in</span> hex format (64 hex digits), wpa_psk, or as an ASCII passphrase</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(8..63 characters) that will be converted to PSK. This conversion uses SSID</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">so the PSK changes when ASCII passphrase is used and the SSID is changed.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">wpa_psk (dot11RSNAConfigPSKValue)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">wpa_passphrase (dot11RSNAConfigPSKPassPhrase)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">wpa_psk=0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef</span></span><br><span class="line">wpa_passphrase=wifi_password</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Set of accepted key management algorithms (WPA-PSK, WPA-EAP, or both). The</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">entries are separated with a space. WPA-PSK-SHA256 and WPA-EAP-SHA256 can be</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">added to <span class="built_in">enable</span> SHA256-based stronger algorithms.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(dot11RSNAConfigAuthenticationSuitesTable)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">wpa_key_mgmt=WPA-PSK WPA-EAP</span></span><br><span class="line">wpa_key_mgmt=WPA-PSK</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Set of accepted cipher suites (encryption algorithms) <span class="keyword">for</span> pairwise keys</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(unicast packets). This is a space separated list of algorithms:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CCMP = AES <span class="keyword">in</span> Counter mode with CBC-MAC [RFC 3610, IEEE 802.11i/D7.0]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">TKIP = Temporal Key Integrity Protocol [IEEE 802.11i/D7.0]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Group cipher suite (encryption algorithm <span class="keyword">for</span> broadcast and multicast frames)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">is automatically selected based on this configuration. If only CCMP is</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">allowed as the pairwise cipher, group cipher will also be CCMP. Otherwise,</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">TKIP will be used as the group cipher.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(dot11RSNAConfigPairwiseCiphersTable)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Pairwise cipher <span class="keyword">for</span> WPA (v1) (default: TKIP)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">wpa_pairwise=TKIP CCMP</span></span><br><span class="line">wpa_pairwise=TKIP</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Pairwise cipher <span class="keyword">for</span> RSN/WPA2 (default: use wpa_pairwise value)</span></span><br><span class="line">rsn_pairwise=CCMP</span><br></pre></td></tr></table></figure>
<blockquote>
<p>5.0GHz</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pve bridge</span></span><br><span class="line">bridge=vmbr0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">AP netdevice name (without <span class="string">&#x27;ap&#x27;</span> postfix, i.e., wlan0 uses wlan0ap <span class="keyword">for</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">management frames); ath0 <span class="keyword">for</span> madwifi</span></span><br><span class="line">interface=wlp4s0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Driver interface <span class="built_in">type</span> (hostap/wired/madwifi/test/none/nl80211/bsd);</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">default: hostap). nl80211 is used with all Linux mac80211 drivers.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Use driver=none <span class="keyword">if</span> building hostapd as a standalone RADIUS server that does</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">not control any wireless/wired driver.</span></span><br><span class="line">driver=nl80211</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">SSID to be used <span class="keyword">in</span> IEEE 802.11 management frames</span></span><br><span class="line">ssid=AP</span><br><span class="line">require_vht=1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Operation mode (a = IEEE 802.11a, b = IEEE 802.11b, g = IEEE 802.11g,</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ad = IEEE 802.11ad (60 GHz); a/g options are used with IEEE 802.11n, too, to</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">specify band)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Default: IEEE 802.11b</span></span><br><span class="line">hw_mode=a</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Channel number (IEEE 802.11)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(default: 0, i.e., not <span class="built_in">set</span>)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Please note that some drivers <span class="keyword">do</span> not use this value from hostapd and the</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">channel will need to be configured separately with iwconfig.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># If CONFIG_ACS build option is enabled, the channel can be selected</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">automatically at run time by setting channel=acs_survey or channel=0, both of</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">which</span> will <span class="built_in">enable</span> the ACS survey based algorithm.</span></span><br><span class="line">channel=44</span><br><span class="line">ieee80211n=1</span><br><span class="line">ieee80211ac=1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Station MAC address -based authentication</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Please note that this kind of access control requires a driver that uses</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hostapd to take care of management frame processing and as such, this can be</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">used with driver=hostap or driver=nl80211, but not with driver=madwifi.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">0 = accept unless <span class="keyword">in</span> deny list</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1 = deny unless <span class="keyword">in</span> accept list</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2 = use external RADIUS server (accept/deny lists are searched first)</span></span><br><span class="line">macaddr_acl=0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">IEEE 802.11 specifies two authentication algorithms. hostapd can be</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">configured to allow both of these or only one. Open system authentication</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">should be used with IEEE 802.1X.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Bit fields of allowed authentication algorithms:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bit 0 = Open System Authentication</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bit 1 = Shared Key Authentication (requires WEP)</span></span><br><span class="line">auth_algs=1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Send empty SSID <span class="keyword">in</span> beacons and ignore probe request frames that <span class="keyword">do</span> not</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">specify full SSID, i.e., require stations to know SSID.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">default: disabled (0)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1 = send empty (length=0) SSID <span class="keyword">in</span> beacon and ignore probe request <span class="keyword">for</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">    broadcast SSID</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2 = clear SSID (ASCII 0), but keep the original length (this may be required</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">    with some clients that <span class="keyword">do</span> not support empty SSID) and ignore probe</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">    requests <span class="keyword">for</span> broadcast SSID</span></span><br><span class="line">ignore_broadcast_ssid=0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Enable WPA. Setting this variable configures the AP to require WPA (either</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">WPA-PSK or WPA-RADIUS/EAP based on other configuration). For WPA-PSK, either</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">wpa_psk or wpa_passphrase must be <span class="built_in">set</span> and wpa_key_mgmt must include WPA-PSK.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Instead of wpa_psk / wpa_passphrase, wpa_psk_radius might suffice.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">For WPA-RADIUS/EAP, ieee8021x must be <span class="built_in">set</span> (but without dynamic WEP keys),</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">RADIUS authentication server must be configured, and WPA-EAP must be included</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">in</span> wpa_key_mgmt.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">This field is a bit field that can be used to <span class="built_in">enable</span> WPA (IEEE 802.11i/D3.0)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">and/or WPA2 (full IEEE 802.11i/RSN):</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bit0 = WPA</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bit1 = IEEE 802.11i/RSN (WPA2) (dot11RSNAEnabled)</span></span><br><span class="line">wpa=2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">WPA pre-shared keys <span class="keyword">for</span> WPA-PSK. This can be either entered as a 256-bit</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">secret <span class="keyword">in</span> hex format (64 hex digits), wpa_psk, or as an ASCII passphrase</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(8..63 characters) that will be converted to PSK. This conversion uses SSID</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">so the PSK changes when ASCII passphrase is used and the SSID is changed.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">wpa_psk (dot11RSNAConfigPSKValue)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">wpa_passphrase (dot11RSNAConfigPSKPassPhrase)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">wpa_psk=0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef</span></span><br><span class="line">wpa_passphrase=123456789</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Set of accepted key management algorithms (WPA-PSK, WPA-EAP, or both). The</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">entries are separated with a space. WPA-PSK-SHA256 and WPA-EAP-SHA256 can be</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">added to <span class="built_in">enable</span> SHA256-based stronger algorithms.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(dot11RSNAConfigAuthenticationSuitesTable)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">wpa_key_mgmt=WPA-PSK WPA-EAP</span></span><br><span class="line">wpa_key_mgmt=WPA-PSK</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Set of accepted cipher suites (encryption algorithms) <span class="keyword">for</span> pairwise keys</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(unicast packets). This is a space separated list of algorithms:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CCMP = AES <span class="keyword">in</span> Counter mode with CBC-MAC [RFC 3610, IEEE 802.11i/D7.0]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">TKIP = Temporal Key Integrity Protocol [IEEE 802.11i/D7.0]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Group cipher suite (encryption algorithm <span class="keyword">for</span> broadcast and multicast frames)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">is automatically selected based on this configuration. If only CCMP is</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">allowed as the pairwise cipher, group cipher will also be CCMP. Otherwise,</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">TKIP will be used as the group cipher.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(dot11RSNAConfigPairwiseCiphersTable)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Pairwise cipher <span class="keyword">for</span> WPA (v1) (default: TKIP)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">wpa_pairwise=TKIP CCMP</span></span><br><span class="line">wpa_pairwise=TKIP</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Pairwise cipher <span class="keyword">for</span> RSN/WPA2 (default: use wpa_pairwise value)</span></span><br><span class="line">rsn_pairwise=CCMP</span><br></pre></td></tr></table></figure>
<p>  <code>hw_mode=a</code>这里是网卡驱动支持的模式，笔者的网卡<code>BCM943602CS</code>是支持2.4G/5G频的(<code>iw list</code> 可以查看频段通道数)。如果你不知道你网卡在Linux下的驱动能支持什么模式，自己看文档注释，挨个试就知道了。<br>
  更多信息请查看：<a href="https://wireless.wiki.kernel.org/en/users/documentation/hostapd">hostapd文档</a></p>
<h3 id="测试配置文件">测试配置文件</h3>
<p>  做好配置文件后，要测试配置是否能正常使用。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hostapd /etc/hostapd/hostapd.conf</span><br></pre></td></tr></table></figure>
<p>  如果能正常连接成功后下会输出类似下面的日志。</p>
<img src="/2022/02/04/PVE/PVE%E3%80%81%E4%BD%BF%E7%94%A8hostapd%E5%88%9B%E5%BB%BA%E6%97%A0%E7%BA%BFAP/img_1.png" class="">
<h3 id="hostapd服务基本操作">hostapd服务基本操作</h3>
<p>  如果您启停hostapd服务出现类似<code>Failed to start hostapd.service: Unit hostapd.service is masked.</code>等错误，请执行下面命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl unmask hostapd</span><br><span class="line">sudo systemctl enable hostapd</span><br><span class="line">sudo systemctl start hostapd</span><br></pre></td></tr></table></figure>
<p>  更多有关信息请查看GitHub Issues：<a href="https://github.com/raspberrypi/documentation/issues/1018">issue</a>。</p>
]]></content>
      <categories>
        <category>PVE</category>
      </categories>
      <tags>
        <tag>hostapd</tag>
      </tags>
  </entry>
  <entry>
    <title>PVE使用Wi-Fi网卡联网</title>
    <url>/2022/02/14/PVE/PVE%E4%BD%BF%E7%94%A8WIFI%E7%BD%91%E5%8D%A1%E8%81%94%E7%BD%91/</url>
    <content><![CDATA[<ol>
<li>打开终端</li>
<li>vim编辑文件<code>/etc/network/interfaces</code></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/network/interfaces</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>添加以下内容</li>
</ol>
<blockquote>
<p><code>wlan0</code>是网卡的标识名称，可以用<code>ifconfig</code>命令查看</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">allow-hotplug wlan0</span><br><span class="line">auto wlan0</span><br><span class="line">iface wlan0 inet dhcp</span><br><span class="line">wpa-conf /etc/wpa.conf</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>创建<code>/etc/wpa.conf文件</code></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch /etc/wpa.conf</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>写入Wi-Fi连接配置</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装wpa_passphrase命令工具</span></span><br><span class="line">apt-get install wpasupplicant</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">写入配置</span></span><br><span class="line">wpa_passphrase wifi名称 wifi密码 &gt;&gt; /etc/wpa.conf</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="6">
<li>启动网卡</li>
</ol>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">ifup wla<span class="symbol">n0</span></span><br></pre></td></tr></table></figure>
<img src="/2022/02/14/PVE/PVE%E4%BD%BF%E7%94%A8WIFI%E7%BD%91%E5%8D%A1%E8%81%94%E7%BD%91/img.png" class="">]]></content>
      <categories>
        <category>PVE</category>
      </categories>
      <tags>
        <tag>Wi-Fi</tag>
      </tags>
  </entry>
  <entry>
    <title>PVE使用自定义HTTPS证书</title>
    <url>/2022/02/10/PVE/PVE%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89HTTPS%E8%AF%81%E4%B9%A6/</url>
    <content><![CDATA[<h2 id="前言-3">前言</h2>
<p>  PVE需要使用https来访问，默认使用的是自带的SSL自签证书浏览器是不认可的，所以会爆红访问提示不安全，这里笔者为大家提供配置免费证书的方法，让你的PVE访问变得安全，而且关键时只有配置证书了的PVE才能外网访问控制台。</p>
<h2 id="SSL证书申请">SSL证书申请</h2>
<ul>
<li>证书申请可以在：<code>https://freessl.cn</code> 申请</li>
</ul>
<blockquote>
<p>最方便是使用DNS验证(文件验证不支持域名带端口验证)，添加一个CNAME/TXT记录验证即可颁发证书，之后进入FreeSSL控制台下载证书，或者把证书保存到本地的KeyManager（<code>https://keymanager.org</code>支持多平台）后查看证书</p>
</blockquote>
<img src="/2022/02/10/PVE/PVE%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89HTTPS%E8%AF%81%E4%B9%A6/img.png" class="">
<blockquote>
<p>查看PEM</p>
</blockquote>
<img src="/2022/02/10/PVE/PVE%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89HTTPS%E8%AF%81%E4%B9%A6/img_1.png" class="">
<h2 id="PVE配置证书">PVE配置证书</h2>
<blockquote>
<p>上传自定义证书</p>
</blockquote>
<img src="/2022/02/10/PVE/PVE%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89HTTPS%E8%AF%81%E4%B9%A6/img_2.png" class="">
<img src="/2022/02/10/PVE/PVE%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89HTTPS%E8%AF%81%E4%B9%A6/img_3.png" class="">
<blockquote>
<p>如果是不小心把自带证书删掉了，或者自定义证书也没了，可以重启pveproxy服务，重新生成自带证书。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart pveproxy</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PVE</category>
      </categories>
      <tags>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title>PVE单臂软路由ikuai多拨家庭组网</title>
    <url>/2022/01/30/PVE/PVE%E5%8D%95%E8%87%82%E8%BD%AF%E8%B7%AF%E7%94%B1ikuai%E5%A4%9A%E6%8B%A8%E5%AE%B6%E5%BA%AD%E7%BB%84%E7%BD%91/</url>
    <content><![CDATA[<h3 id="介绍">介绍</h3>
<blockquote>
<p>具体PVE、ikuai虚拟机怎么安装，这里就不过多赘述了，相信网上都有教程。<br>
笔者家庭组网：PVE单网口主机安装ikuai软路由虚拟机单线多拨，外带一个物理交换机（无网管功能）。</p>
</blockquote>
<h3 id="PVE配置ikuai软路由网口">PVE配置ikuai软路由网口</h3>
<ul>
<li>配置<code>vmbr0</code>虚拟网桥</li>
</ul>
<blockquote>
<p>vmbr0是pve默认创建的，这里使用软路由网关<code>192.168.3.1</code>（软路由需要改LAN地址，默认是<code>192.168.1.1</code>），并且绑定网卡和设置静态ip：<code>192.168.3.2</code>作为访问pve的ip。</p>
</blockquote>
<blockquote>
<p>若没有安装软路由，或者软路由崩了的情况下。用将客户机网线插到单臂网口，或者单臂网口连的交换机端口上，设置静态ip（<code>192.168.3.1/24</code>网段内）进行访问pve。</p>
</blockquote>
<img src="/2022/01/30/PVE/PVE%E5%8D%95%E8%87%82%E8%BD%AF%E8%B7%AF%E7%94%B1ikuai%E5%A4%9A%E6%8B%A8%E5%AE%B6%E5%BA%AD%E7%BB%84%E7%BD%91/img.png" class="">
<ul>
<li>分配ikuai网卡</li>
</ul>
<blockquote>
<p>在安装前ikuai路由前分配两个虚拟网卡<code>eth0</code>、<code>eth1</code>，并且都接到<code>vmbr0</code>虚拟网桥。</p>
</blockquote>
<img src="/2022/01/30/PVE/PVE%E5%8D%95%E8%87%82%E8%BD%AF%E8%B7%AF%E7%94%B1ikuai%E5%A4%9A%E6%8B%A8%E5%AE%B6%E5%BA%AD%E7%BB%84%E7%BD%91/img_1.png" class="">
<ul>
<li>ikuai绑定WAN、LAN口</li>
</ul>
<blockquote>
<p>安装完ikuai后，此时外部<code>192.168.3.1/24</code>段的网络设备是无法访问ikuai路由的。只能从<br>
pve的web控制台访问ikuai虚拟机，选择-设置网卡绑定</p>
</blockquote>
<img src="/2022/01/30/PVE/PVE%E5%8D%95%E8%87%82%E8%BD%AF%E8%B7%AF%E7%94%B1ikuai%E5%A4%9A%E6%8B%A8%E5%AE%B6%E5%BA%AD%E7%BB%84%E7%BD%91/img_2.png" class="">
<ul>
<li>ikuai设置LAN口ip</li>
</ul>
<blockquote>
<p>修改LAN默认ip地址，选择-设置LAN/WAN地址-设置LAN1地址，WAN口的暂时不用管。<br>
LAN1修改为：<code>192.168.3.1</code></p>
</blockquote>
<img src="/2022/01/30/PVE/PVE%E5%8D%95%E8%87%82%E8%BD%AF%E8%B7%AF%E7%94%B1ikuai%E5%A4%9A%E6%8B%A8%E5%AE%B6%E5%BA%AD%E7%BB%84%E7%BD%91/img_3.png" class="">]]></content>
      <categories>
        <category>PVE</category>
      </categories>
      <tags>
        <tag>ikuai</tag>
      </tags>
  </entry>
  <entry>
    <title>破解烽火HG2543C1光猫</title>
    <url>/2022/01/26/PVE/%E7%A0%B4%E8%A7%A3%E7%83%BD%E7%81%ABHG2543C1%E5%85%89%E7%8C%AB/</url>
    <content><![CDATA[<h3 id="前言-4">前言</h3>
<blockquote>
<p>笔者在PVE中搭建ikuai/openwrt软路由，正好家里有一条千兆公网宽带。<br>
为了更好利用这个<code>公网</code>，决定把光猫破解改桥接。(超级密码拉网的师傅一般是不会告诉你的)</p>
</blockquote>
<h3 id="破解烽火HG2543C1光猫">破解烽火HG2543C1光猫</h3>
<ul>
<li>打开光猫telnet功能</li>
</ul>
<blockquote>
<p>别问为什么不用ssh，浏览器访问：<code>http://192.168.1.1:8080/cgi-bin/telnetenable.cgi?telnetenable=1</code></p>
</blockquote>
<blockquote>
<p>打开后会有telnet开启提示字样</p>
</blockquote>
<img src="/2022/01/26/PVE/%E7%A0%B4%E8%A7%A3%E7%83%BD%E7%81%ABHG2543C1%E5%85%89%E7%8C%AB/img_2.png" class="">
<ul>
<li>telnet登录连接到光猫获取telecomadmin</li>
</ul>
<blockquote>
<p>登录用户名默认root，就是超级管理员。</p>
</blockquote>
<blockquote>
<p>telnet命令登录：<code>telnet 192.168.1.1</code></p>
</blockquote>
<blockquote>
<p>登录密码：默认的光猫Wi-Fi密码跟默认的useradmin密码，光猫背面就可以看到了</p>
</blockquote>
<blockquote>
<p>查看telecomadmin密码：<code>cat /flash/cfg/agentconf/factory.conf</code></p>
</blockquote>
<img src="/2022/01/26/PVE/%E7%A0%B4%E8%A7%A3%E7%83%BD%E7%81%ABHG2543C1%E5%85%89%E7%8C%AB/img_3.png" class="">
<blockquote>
<p>查看宽带账号和密码：<code>cat /flash/cfg/app_conf/pppoe/chap-secrets</code></p>
</blockquote>
<img src="/2022/01/26/PVE/%E7%A0%B4%E8%A7%A3%E7%83%BD%E7%81%ABHG2543C1%E5%85%89%E7%8C%AB/img.png" class="">
<ul>
<li>使用telecomadmin账号登录管理后台</li>
</ul>
<blockquote>
<p>那么经过上面的操作，已经得到<code>telecomadmin</code>的电信管理员密码了</p>
</blockquote>
<blockquote>
<p>浏览器访问：<code>http://192.168.1.1:8080/cgi-bin/login.htm.cgi</code>登录</p>
</blockquote>
<blockquote>
<p>打开网络-宽带设置-网络连接选项<code>2_INTERNET_R_VID_41</code>连接方式为桥接，具体见下图，不同猫一般都不一样，认准含有<code>INTERNET</code>字段就可以了</p>
</blockquote>
<img src="/2022/01/26/PVE/%E7%A0%B4%E8%A7%A3%E7%83%BD%E7%81%ABHG2543C1%E5%85%89%E7%8C%AB/img_1.png" class="">
<blockquote>
<p>一定要记得选绑定桥接的LAN口</p>
</blockquote>
<h3 id="华为路由TC7102的IPTV使用"><code>华为路由TC7102</code>的IPTV使用</h3>
<p>  光猫破解后，把千兆口连接到交换机上，使用软路由或者硬路由拨号（百兆口就不考虑了）。但是<code>IPTV</code>跟猫绑定了，目前<code>IPTV</code>走的硬路由器：<code>华为路由TC7102</code>拨号不支持<code>IPTV</code>流转发（支持功能，但是被绑定再猫上了，也懒得折腾修改什么。不知道电信师傅干了什么），必须要用猫拨号，路由下去开启<code>IPTV</code>桥接绑定LAN端口和VLAN-ID（接电视机顶盒或二级路由），不过可以通过<code>IPTV</code>线直接连接到交换机上，机顶盒就可以自动接入<code>IPTV</code>网络了。</p>
<blockquote>
<p>下面就是猫拨号情况下，一级路由设置，二级路由也是如此，同时二级路由可以上网（不同路由器一般不同）</p>
</blockquote>
<img src="/2022/01/26/PVE/%E7%A0%B4%E8%A7%A3%E7%83%BD%E7%81%ABHG2543C1%E5%85%89%E7%8C%AB/img_4.png" class="">
<p>   LAN口就是连电视机的路由器或者电视，桥接路由下去一般不用开启<code>IPTV</code>了（具体看情况）。<br>
   如果不走猫拨号，路由器设置AP模式直接连到交换机上。比如TP的路由器，直接把wan口拔了，电视线跟交换机接的线都插到LAN口上。</p>
<blockquote>
<p>当然电视也可以直接插猫的<code>iTV</code>口，默认搞了桥接。如果猫拨号，并且路由器支持<code>IPTV</code>默认也是可以看电视。</p>
</blockquote>
<img src="/2022/01/26/PVE/%E7%A0%B4%E8%A7%A3%E7%83%BD%E7%81%ABHG2543C1%E5%85%89%E7%8C%AB/img_5.png" class="">
<h3 id="总结-2">总结</h3>
<p>  路由器同样的<code>IPTV</code>设置情况下，由猫拨号，路由器开启<code>IPTV</code>桥接并绑定LAN口和VLAN-ID，下面接二级路由器连接电视跟上网正常。改猫桥接，路由器拨号，二级路由下面<code>IPTV</code>功能不生效。应该地区限制，必须要用光猫拨号或者直接（或接个交换机单线服用）连接光猫才能使用<code>IPTV</code>。</p>
<blockquote>
<p>更详细设置请看：<a href="https://consumer.huawei.com/cn/support/content/zh-cn00977421/">华为路由IPTV文档</a></p>
</blockquote>
]]></content>
      <categories>
        <category>PVE</category>
      </categories>
      <tags>
        <tag>烽火HG2543C1光猫</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 安装配置Spring cloud 微服务开箱即用</title>
    <url>/2021/06/03/docker/Docker%20%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AESpring%20cloud%20%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E7%AE%B1%E5%8D%B3%E7%94%A8/</url>
    <content><![CDATA[<h3 id="Nacos">Nacos</h3>
<ul>
<li>拉下镜像</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull nacos/nacos-server</span><br></pre></td></tr></table></figure>
<ul>
<li>启动</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8848:8848 --env MODE=standalone --name nacos --restart=always nacos/nacos-server</span><br></pre></td></tr></table></figure>
<h2 id="Sentinel">Sentinel</h2>
<ul>
<li>拉下镜像</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull bladex/sentinel-dashboard</span><br></pre></td></tr></table></figure>
<ul>
<li>启动</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name sentinel --restart=always -d -p 8858:8858 -d bladex/sentinel-dashboard</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker创建网络错误提示</title>
    <url>/2022/02/08/docker/Docker%E5%88%9B%E5%BB%BA%E7%BD%91%E7%BB%9C%E9%94%99%E8%AF%AF%E6%8F%90%E7%A4%BA/</url>
    <content><![CDATA[<p>  笔者插的USB网口给Docker网心云用，由于网络测试原因多次删除和创建macvlan网络，遇到了以下坑，重启docker并不能解决。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker network create -d macvlan --subnet=192.168.3.0/24 --gateway=192.168.3.1 -o parent=enx00e04c680011  macvlan_net</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">Error response from daemon: network dm-04589cecfc96 is already using parent interface enx00e04c680011</span><br></pre></td></tr></table></figure>
<blockquote>
<p>解决参考，删除以下文件并重启docker</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rm</span> /var/lib/docker/network/files/local-kv.db</span> </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">restart docker</span></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里还有个issue参考：<a href="https://github.com/moby/libnetwork/issues/1743">https://github.com/moby/libnetwork/issues/1743</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker、network</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker快速入门</title>
    <url>/2021/08/01/docker/Docker%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="docker笔记">docker笔记</h2>
<p>docker的用处简单来说，就是将软件（mysql，redis）配置好后，将其打包成镜像，然后可以快速的部署的各个服务器，只需要配置一次即可。</p>
<h3 id="1-docker-安装配置docker">1. docker 安装配置docker</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew cask install docker</span><br></pre></td></tr></table></figure>
<p>安装完后，配置镜像源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvim ~/.docker/daemon.json</span><br></pre></td></tr></table></figure>
<p>然后添加上这一行 <code>registry-mirrors: [http://hub-mirror.c.163.com]</code></p>
<p>添加完后记得重启docker</p>
<h3 id="2-docker-搜索镜像">2. docker 搜索镜像</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker search redis</span><br></pre></td></tr></table></figure>
<h3 id="3-docker-拉取镜像">3. docker 拉取镜像</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull redis: version</span><br></pre></td></tr></table></figure>
<h3 id="4-docker-显示已经安装的镜像">4. docker 显示已经安装的镜像</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>
<h3 id="5-docker删除已经安装的镜像">5. docker删除已经安装的镜像</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker rmi imageId</span><br><span class="line"><span class="string">&#x27;imageId可以用下面命令拿到</span></span><br><span class="line"><span class="string">docker images</span></span><br><span class="line"><span class="string">&#x27;</span>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line"><span class="string">&#x27;redis               latest              01a52b3b5cd1        2 weeks ago         98.2MB</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;</span>01a52b3b5cd1就是 imageId<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="6-docker运行容器">6. docker运行容器</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE[:TAG|@DIGEST] [COMMAND] [ARG...]</span><br><span class="line"><span class="string">&#x27;例子 docker run tomcat&#x27;</span></span><br></pre></td></tr></table></figure>
<p>docker run的额外参数</p>
<ul>
<li>
<p>–name  给当前运行的容器起一个名字</p>
<p><code>docker run --name mytomcat -d tomcat</code></p>
</li>
<li>
<p>-d 后台运行容器</p>
</li>
<li>
<p>-p 用于端口映射，下面有讲解</p>
</li>
</ul>
<h3 id="7-docker查看正在运行的容器">7. docker查看正在运行的容器</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>
<h3 id="8-docker停止正在运行的容器">8. docker停止正在运行的容器</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker stop containerId </span><br><span class="line"><span class="string">&#x27;containerId 通过 docker ps命令获取&#x27;</span></span><br></pre></td></tr></table></figure>
<p>###9. docker启动容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;你可以当作是run命令，但这个相当于我们再次运行我们之前运行过的run命令，当我们参数很多的时候这很有用&#x27;</span></span><br><span class="line">docker start containerId</span><br></pre></td></tr></table></figure>
<h3 id="10-docker删除容器">10. docker删除容器</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;rmi 事情删除镜像，rm是删除容器&#x27;</span></span><br><span class="line">docker <span class="built_in">rm</span> containerId</span><br></pre></td></tr></table></figure>
<h3 id="11-docker-映射端口到容器">11. docker 映射端口到容器</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;srcport:destport &#x27;</span></span><br><span class="line"><span class="string">&#x27;srcport 为物理主机的端口&#x27;</span></span><br><span class="line"><span class="string">&#x27;destport 为容器的端口&#x27;</span></span><br><span class="line"><span class="string">&#x27;例如 8088:8080 就是将物理机器的端口映射到容器的8080端口中，这样就可以访问容器中的tomcat了&#x27;</span></span><br><span class="line">docker run -d -p 8088:8080 tomcat</span><br></pre></td></tr></table></figure>
<h3 id="12-docker查看容器启动的日志">12. docker查看容器启动的日志</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker logs containerId</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker配置Postgres MySQL Redis(随容器重启)</title>
    <url>/2021/03/26/docker/Docker%E9%85%8D%E7%BD%AEPostgres%20MySQL%20Redis(%E9%9A%8F%E5%AE%B9%E5%99%A8%E9%87%8D%E5%90%AF)/</url>
    <content><![CDATA[<h3 id="MySQL">MySQL</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -itd --name mysql --restart=always -p 3306:3306 -e MYSQL_ROOT_PASSWORD=itcast mysql</span><br></pre></td></tr></table></figure>
<h3 id="Redis">Redis</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -itd --name redis --restart=always -p 6379:6379 redis</span><br></pre></td></tr></table></figure>
<h3 id="Postgres">Postgres</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run --name postgres --restart=always -e POSTGRES_PASSWORD=itcast -p 5432:5432 -d postgres:latest</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Nacos安装</title>
    <url>/2021/03/12/docker/Nacos%E5%AE%89%E8%A3%85-nacos%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="Nacos安装">Nacos安装</h2>
<p>服务（Service）是Nacos 世界的一等公民。Nacos支持几乎所有主流类型的“服务”的发现、配置和管理。</p>
<h4 id="1-Docker安装Nacos">1.Docker安装Nacos</h4>
<p><strong>拉取镜像</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull nacos/nacos-server</span><br></pre></td></tr></table></figure>
<p><strong>启动容器并且添加映射</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8848:8848 --<span class="built_in">env</span> MODE=standalone --name nacos --restart=always nacos/nacos-server</span><br></pre></td></tr></table></figure>
<p><strong>查看容器是否启动</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>
<p><strong>检查nacos服务是否正常</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">浏览器打开 http://localhost:8848/nacos 用户名密码默认为nacos</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
  </entry>
  <entry>
    <title>Docker 国内镜像源</title>
    <url>/2021/04/05/docker/docker%20%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F%E6%BA%90-docker%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F%E6%BA%90/</url>
    <content><![CDATA[<blockquote>
<p>网易<br>
<a href="http://hub-mirror.c.163.com">http://hub-mirror.c.163.com</a><br>
Docker中国区官方镜像<br>
<a href="https://registry.docker-cn.com">https://registry.docker-cn.com</a><br>
中国科技大学<br>
<a href="https://docker.mirrors.ustc.edu.cn">https://docker.mirrors.ustc.edu.cn</a><br>
阿里云容器  服务<br>
<a href="https://cr.console.aliyun.com/">https://cr.console.aliyun.com/</a><br>
首页点击“创建我的容器镜像”  得到一个专属的镜像加速地址，类似于“<a href="https://1234abcd.mirror.aliyuncs.com">https://1234abcd.mirror.aliyuncs.com</a>”</p>
</blockquote>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker-compose基本使用</title>
    <url>/2021/11/08/docker/docker-compose%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="前言-5">前言</h3>
<blockquote>
<p>docker-compose工作做的就是容器编排，说白了就是自动化部署容器的工作，其中可以利用Dockerfile构建自定义容器打包部署，也可以利用现有的仓库镜像进行部署。</p>
</blockquote>
<h3 id="docker-compose常用命令">docker- compose常用命令</h3>
<p><strong>基本命令</strong></p>
<ul>
<li><strong>ps</strong>：列出所有运行容器</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose ps</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>port</strong>：打印绑定的公共端口，下面命令可以输出 eureka 服务 8761 端口所绑定的公共端口</li>
</ul>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker</span>-compose port eureka <span class="number">8761</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>build</strong>：构建或者重新构建服务</li>
</ul>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker-compose build</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>start</strong>：启动指定服务已存在的容器</li>
</ul>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">docker-compose <span class="literal">start</span> eureka</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>stop</strong>：停止已运行的服务的容器</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">docker-compose stop eureka</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>rm</strong>：删除服务的容器</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose <span class="built_in">rm</span> eureka </span><br><span class="line"><span class="comment"># 不指定，则删除所有</span></span><br><span class="line">docker-compose <span class="built_in">rm</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>up</strong>：构建、启动容器</li>
</ul>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker-compose up</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>kill</strong>：通过发送 SIGKILL 信号来停止指定服务的容器</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose <span class="built_in">kill</span> eureka</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>pull</strong>：下载服务镜像</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose pull</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>scale</strong>：设置指定服务运气容器的个数，以 service=num 形式指定</li>
</ul>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">docker-compose scale <span class="attribute">user</span>=3 <span class="attribute">movie</span>=3</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>run</strong>：在一个服务上执行一个命令</li>
</ul>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">docker-compose <span class="built_in">run</span> web bash</span><br></pre></td></tr></table></figure>
<p><strong>进阶用法</strong></p>
<ul>
<li>指定docker-compose文件</li>
</ul>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker-compose -f file_path</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker-compose</tag>
      </tags>
  </entry>
  <entry>
    <title>Elasticsearch 安装配置</title>
    <url>/2021/08/02/elasticsearch/1.%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="elasticsearch-安装配置">elasticsearch 安装配置</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install elastic/tap/elasticsearch-full</span><br><span class="line">brew install elastic/tap/kibana-full</span><br></pre></td></tr></table></figure>
<p><code>elasticsearch</code> 默认地址和端口号 <code>http://localhost:9200/?pretty</code></p>
<p><code>kibana</code> 默认地址和端口号 <code>http://localhost:5601/app/kibana#/dev_tools/console?_g=()</code></p>
<h3 id="启动elasticsearch">启动elasticsearch</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">elasticsearch</span><br><span class="line">kibana</span><br></pre></td></tr></table></figure>
<h3 id="elasticsearch-目录">elasticsearch 目录</h3>
<ul>
<li>home  <code>/usr/local/var/homebrew/linked/elasticsearch-full</code></li>
<li>bin <code>/usr/local/var/homebrew/linked/elasticsearch-full/bin</code></li>
<li>conf <code>/usr/local/etc/elasticsearch</code></li>
<li>data <code>/usr/local/var/lib/elasticsearch</code></li>
<li>logs <code>/usr/local/var/log/elasticsearch</code></li>
<li>plugins <code>/usr/local/var/homebrew/linked/elasticsearch/plugins</code></li>
</ul>
]]></content>
      <categories>
        <category>Elasticsearch</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>Elasticsearch利用kibana进行可视化操作</title>
    <url>/2021/08/02/elasticsearch/%E5%88%A9%E7%94%A8kibana%E8%BF%9B%E8%A1%8C%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="利用kibana进行可视化操作">利用kibana进行可视化操作</h2>
<h3 id="基本命令">基本命令</h3>
<ol>
<li>
<p>查看<code>elasticsearch</code>的状态</p>
<p><code>GET /_cat/health?v</code></p>
</li>
<li>
<p>查看<code>elasticsearch</code>的索引</p>
<p><code>GET /_cat/indices?v</code></p>
</li>
<li>
<p>添加索引</p>
<p><code>PUT indexName</code></p>
</li>
<li>
<p>删除索引</p>
<p><code>DELETE indexName</code></p>
</li>
</ol>
<h3 id="对文档进行CRUD操作">对文档进行CRUD操作</h3>
<ol>
<li>
<p>添加document</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最后面跟的是id</span></span><br><span class="line"><span class="variable constant_">PUT</span> /school/_doc/<span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span> : <span class="string">&quot;xuf&quot;</span>,</span><br><span class="line">  <span class="string">&quot;age&quot;</span> : <span class="string">&quot;2&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查询document</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">GET</span> /school/_doc/<span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>更新document</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">POST</span> /school/_update/<span class="number">1</span>/</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;doc&quot;</span>:&#123;</span><br><span class="line">      <span class="string">&quot;name&quot;</span> : <span class="string">&quot;modify1&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>删除document</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">DELETE</span> /school/_doc/<span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用脚本更新值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在原有的值上加上2</span></span><br><span class="line"><span class="variable constant_">POST</span> /school/_update/<span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;script&quot;</span>: <span class="string">&quot;ctx._source.age += 2&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>Elasticsearch</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo主题nexT显示错误解决</title>
    <url>/2021/08/02/hexo/Hexo%E4%B8%BB%E9%A2%98next%E6%98%BE%E7%A4%BA%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<ul>
<li>原因是hexo在5.0之后把swig给删除了需要自己手动安装</li>
</ul>
<blockquote>
<p>npm i hexo-renderer-swig</p>
</blockquote>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>nexT</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux后台运行hexo</title>
    <url>/2021/08/02/hexo/Linux%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8Chexo/</url>
    <content><![CDATA[<blockquote>
<p>hexo是一个非常高效的博客，但由于其设计特点，目的是为了转换为静态页面，<br>
因此不必要一直在后台运行，但是我想随时随地写博客同步到github，<br>
使用hexo admin编辑器，这就需要hexo一直在后台运行，于是在网上找到了pm2托管的方式。</p>
</blockquote>
<ul>
<li>安装pm2</li>
</ul>
<blockquote>
<p>npm  install -g pm2</p>
</blockquote>
<ul>
<li>在博客根目录创建一个js脚本</li>
</ul>
<blockquote>
<p>$ vim hexo_run.js</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js脚本文件</span></span><br><span class="line"><span class="keyword">const</span> &#123; exec &#125; = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>)</span><br><span class="line"><span class="title function_">exec</span>(<span class="string">&#x27;hexo server -p &lt;IP端口，不使用则使用默认4000端口&gt;&#x27;</span>,<span class="function">(<span class="params">error, stdout, stderr</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(error)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;exec error: $&#123;error&#125;&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;stdout: $&#123;stdout&#125;&#x27;</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;stderr: $&#123;stderr&#125;&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>在博客根目录运行脚本</li>
</ul>
<blockquote>
<p>$ pm2 hexo_run.js</p>
</blockquote>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>解决Hexo博客新版本Next主题不支持auto_excerpt配置问题</title>
    <url>/2021/08/02/hexo/%E8%A7%A3%E5%86%B3Hexo%E5%8D%9A%E5%AE%A2%E6%96%B0%E7%89%88%E6%9C%ACNext%E4%B8%BB%E9%A2%98%E4%B8%8D%E6%94%AF%E6%8C%81auto-excerpt%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<ul>
<li>使用npm安装hexo-excerpt</li>
</ul>
<blockquote>
<p>npm install hexo-excerpt --save</p>
</blockquote>
<ul>
<li>在站点配置文件中添加</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">excerpt:</span><br><span class="line">depth: 5  </span><br><span class="line">excerpt_excludes: []</span><br><span class="line">more_excludes: []</span><br><span class="line">hideWholePostExcerpts: true</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>ReentrantLock</title>
    <url>/2021/08/02/jdk/ReentrantLock/</url>
    <content><![CDATA[<h3 id="前言-6">前言</h3>
<p><code>ReentrantLock</code>作为 <code>AQS</code>的实现类之一，其是基于 <code>CAS</code>实现的锁，此锁为<strong>独占锁</strong>，并且用一个阻塞队列来阻塞前来拿锁的线程。队列为<strong>CLH 队列</strong></p>
<p>其使用两种策略，一种是<strong>非公平</strong>，一种是<strong>公平</strong>，默认是 <strong>非公平锁</strong>。在这里先讨论<strong>非公平锁</strong></p>
<hr>
<ol>
<li>
<p>先来看一下 用于阻塞线程的<strong>CLH</strong> 队列</p>
<img src="/2021/08/02/jdk/ReentrantLock/image-20191105180820841.png" class="">
<p>看一下该节点的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line">        <span class="keyword">volatile</span> Node prev;</span><br><span class="line">        <span class="keyword">volatile</span> Node next;</span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">  			Node nextWaiter;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>waitStatus</p>
<blockquote>
<p><strong>等待状态</strong></p>
<ol>
<li>
<p>CANCELLED</p>
<p>节点由于超时或者被中断而被取消.</p>
</li>
<li>
<p>SIGNAL</p>
<p>节点正在被阻塞并且等待信号的到来</p>
</li>
<li>
<p>CONDITION</p>
<p>用于条件队列中</p>
</li>
<li>
<p>PROPAGATE</p>
<p>用于共享锁</p>
</li>
</ol>
</blockquote>
</li>
<li>
<p>prev <strong>指向上一个节点</strong></p>
</li>
<li>
<p>next <strong>指向下一个节点</strong></p>
</li>
<li>
<p>thread <strong>表示请求锁的线程</strong></p>
</li>
<li>
<p>nextWaiter</p>
<blockquote>
<p>​	<strong>锁的占用模式</strong></p>
<ul>
<li>SHARED 代表共享模式</li>
<li>EXCLUSIVE 代表独占模式</li>
</ul>
</blockquote>
</li>
</ul>
<hr>
</li>
<li>
<p><strong>AbstractQueuedSynchronizer</strong>实现锁的策略</p>
<p>其使用了一个<code>state</code>字段用来表示资源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state; </span><br></pre></td></tr></table></figure>
<p>并且使用一个 <code>thread</code>字段来表示当前已经占用该资源的线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> Thread thread;</span><br></pre></td></tr></table></figure>
<p>如果为<strong>独占锁</strong>，我们只需要用这两个字段来表示<strong>资源</strong>和<strong>占用资源的线程</strong>，没有得到资源的线程，这个时候我们就可以用<strong>CLH</strong>队列去记录它们。</p>
<hr>
</li>
<li>
<p>获取锁 <code>lock</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">  					<span class="comment">// 利用 CAS判断状态是否为0，若为0则说明资源还没被占用则将其设置为1表示占用资源</span></span><br><span class="line">  					<span class="comment">// 则表示拿到锁</span></span><br><span class="line">           <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">               <span class="comment">// 拿到锁后利用CAS设置资源占有者，也就是当前线程</span></span><br><span class="line">               setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               <span class="comment">// 如果没有拿到锁，则尝试排队</span></span><br><span class="line">               acquire(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>这里首先就开始尝试获取锁，如果 <code>state</code> 为 <code>0</code> 则说明资源还没有被占用，这个时候就可以获取资源，获取资源成功后就设置占用该资源的线程。</p>
<p>如果资源已经被占用，则尝试排队</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; <span class="comment">// 尝试获取锁</span></span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) <span class="comment">// 加入队列</span></span><br><span class="line">            <span class="comment">// 中断自身, 这里是不会执行的，若执行到这里，线程就会被中断, 下面会详解</span></span><br><span class="line">            selfInterrupt(); </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>其思路很简单，尝试获取锁（公平机制和非公平机制），如果没拿到则将其加入队列，并且将线程 <code>park</code></p>
<p>当有线程释放锁的时候，则会唤醒正在队列等待的线程，并会再次调用<code>acquire</code>去获取锁，所以 <code>selfInterrupt</code>不会被执行，若被执行，那线程将被结束。（正常情况下）</p>
<p>来下 <strong>非公平策略</strong>下的获取锁操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">  					<span class="comment">// 当前线程</span></span><br><span class="line">           <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">  					<span class="comment">// 先资源是否为 0</span></span><br><span class="line">           <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">           <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">             	<span class="comment">// 占用资源，并且设置 资源占用线程，获取资源成功</span></span><br><span class="line">               <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                   setExclusiveOwnerThread(current);</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">  					<span class="comment">// 资源已经被占用，无法获取资源</span></span><br><span class="line">  					<span class="comment">// 判断是否是当前线程占用的资源</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">             	<span class="comment">// 当前线程占用的资源，则资源++</span></span><br><span class="line">               <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">             	<span class="comment">// 检测资源数是否溢出，若溢出直接报 Error</span></span><br><span class="line">               <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">             	<span class="comment">// 设置资源</span></span><br><span class="line">               setState(nextc);</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>这里实现很简单，也就是判断一下资源是否被占用，然后处理下那两个变量。</p>
<p>值得思考的地方是，其之所以是不公平的，是因为其直接去尝试获取锁，而不去考虑队列的情况，如果是此时队列中有等待的线程，则其不会去检测队列中是否有等待的线程而主动去排队，它直接去获取锁，所以这是<strong>不公平的策略</strong></p>
<p>我们可以来看一下<strong>公平锁的策略</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Fair version of tryAcquire.  Don&#x27;t grant access unless</span></span><br><span class="line"><span class="comment">         * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>显然，其多了一句 <code>hasQueuedPredecessors</code>，用来判断是否有正在等待的线程。所以这就是 <strong>公平锁</strong>和<strong>非公平锁</strong>的区别。</p>
<ul>
<li>公平锁优先考虑队列中是否有正在等待的线程，如果有，则会将自身加入队列</li>
<li>非公平锁不考虑队列中是否有正在等待的线程，而是直接去获取锁</li>
</ul>
<p>下面继续看其，如何加入队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br></pre></td></tr></table></figure>
<p>首先是添加 <code>waiter</code>，这个<code>waiter</code>就是队列中的节点，因为此锁为<strong>独占锁</strong>，所以节点类型为 <code>EXCLUSIVE</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">  			<span class="comment">// 新建一个节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">  			<span class="comment">// 队列尾部不为空则直接插入</span></span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">            node.prev = pred;</span><br><span class="line">          	<span class="comment">// 设置 tail</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  			<span class="comment">// 尾部为空</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">          	<span class="comment">// 尾部为空则直接new一个</span></span><br><span class="line">            <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              	<span class="comment">// 尾部不为空则直接插入</span></span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个很简单，就判断 <code>tail</code>是否为 <code>null</code>，如果为 <code>null</code> 则直接插入一个 <code>空node</code>，否则则直接插入到 <code>tail</code>后面，并且设置 <code>tail</code>为新插入的节点。</p>
<p><code>enq</code> 方法值得注意的地方是，如果 <code>tail</code>为 <code>null</code>，其会新建一个<code>空node</code> 并且，将<code>node</code>接入到 <code>空node</code> 后面。</p>
<p>如图所示：</p>
 <img src="/2021/08/02/jdk/ReentrantLock/image-20191105194516665.png" class="">
<p>其头节点始终是空的。</p>
<p>将节点插入到队尾后，则尝试获取锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">              	<span class="comment">// 获取当前尾节点的前一个节点</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">              	<span class="comment">// 如果队头，并且尝试获取锁</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                  	<span class="comment">// 如果拿到锁，则设置node 为头部</span></span><br><span class="line">                    <span class="comment">// 记住 头部节点作废的。</span></span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">// 判断节点信号是否为SIGNAL 如果为 此信号说明该节点正在等待信号，则将其 park</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt()) <span class="comment">// park 线程</span></span><br><span class="line">                    interrupted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>首先其死循环，获取<code>node</code> 的前一个节点 <code>p</code>，然后判断 <code>p</code>是否为 <code>head</code>头节点，如果为 <code>head</code>，因为头节点是无效的，所以这个时候队列中只有一个线程在排队，也就是有两个节点，此时若能获取到锁，则将<code>p.next= null</code>，并且设置 <code>node 为 head</code>，此时队列只有一个节点，这个节点是作废的。</p>
<p>因为队列为空的时候，它会一次性添加两个节点，每次拿到锁它会作废掉头节点，这个到 <code>release</code> 锁的时候就看出来了。</p>
<p>调用 <code>shouldParkAfterFailedAcquire</code>，设置 <code>p</code>的信号为 <code>SIGNAL</code> 然后 <code>parkAndCheckInterrupt</code>让线程 <code>park</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> pred.waitStatus;</span><br><span class="line">  			<span class="comment">// p为SIGNAL 则直接返回true，就会调用 park掉线程</span></span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 在这里跳过已经被取消的线程，超时或者被中断 都会被标记为 取消状态</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          	<span class="comment">// 若p不为SIGNAL 则设置其状态为 SIGNAL</span></span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">  			<span class="comment">// LockSupport 支持</span></span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>至此，获取锁就完毕了。</p>
</li>
<li>
<p>下面来看 <code>unlock</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">     sync.release(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">  			<span class="comment">// 释放锁</span></span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">          	<span class="comment">// 然后判断 队列头部是否存在需要唤醒的节点</span></span><br><span class="line">            <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 若存在节点则直接唤醒</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>释放锁很简单，首先是<code>tryRelease</code> 尝试去释放资源，如果释放资源成功，则从队头开始唤醒正在阻塞的线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">  					<span class="comment">// 获取锁的线程必须和释放锁的线程一样，这没什么毛病，否则其它线程也能释放锁，那就违反其设计了 </span></span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  					<span class="comment">// c 为 资源，因为一个线程拿到锁后还可以再获取锁，state就会++，所以释放锁的时候要对应</span></span><br><span class="line">  					<span class="comment">// c 为 0的时候才能释放锁</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                free = <span class="literal">true</span>;</span><br><span class="line">              	<span class="comment">// 释放占用线程</span></span><br><span class="line">                setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">  					<span class="comment">// 设置 资源</span></span><br><span class="line">            setState(c);</span><br><span class="line">            <span class="keyword">return</span> free;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>释放锁的线程必须要和获取锁的线程一样</li>
<li>并且<code>lock</code> 和 <code>unlock</code> 调用次数要一样</li>
<li>state 为 0 ，则设置 thread 为 null 则为释放资源成功</li>
</ul>
<p>下面看下其如何唤醒线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line">  	<span class="comment">// 设置等待状态为 0</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">		</span><br><span class="line">  <span class="comment">// 头节点是作废的，所以直接拿其下一个节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">  	<span class="comment">// 跳过取消的节点, 找到未取消的节点</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 调用 unpark唤醒线程</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>先设置节点等待状态为 0</li>
<li>跳过取消的节点，或者 状态为 0的节点，之所以要这样，因为释放锁的时候我们并不会删除节点，我们只是将其等待状态设置为0，这个时候我们就可以跳过这些节点，从后继节点中继续寻找到 已经阻塞的节点</li>
<li>调用 unpark 唤醒线程</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>ReentrantLock</category>
      </categories>
      <tags>
        <tag>ReentrantLock</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx在Docker中自动反向代理</title>
    <url>/2021/08/02/nginx/nginx%E5%9C%A8docker%E4%B8%AD%E8%87%AA%E5%8A%A8%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h2 id="nginx在docker中自动反向代理">nginx在docker中自动反向代理</h2>
<blockquote>
<p><a href="http://jasonwilder.com/blog/2014/03/25/automated-nginx-reverse-proxy-for-docker/">http://jasonwilder.com/blog/2014/03/25/automated-nginx-reverse-proxy-for-docker/</a></p>
</blockquote>
<p>一个反向代理服务器通常在其它服务器的前面，用以提供额外web服务器自身不能提供的功能。比如说，一个反向代理服务器可以提供SSL终端、负载均衡、路由请求、缓存、压缩或A/B测试。当我们运行web服务在docker容器中时，nginx可以运行在容器的前面，这对于简单部署来说很有用。</p>
<h2 id="为什么对docker使用反向代理">为什么对docker使用反向代理</h2>
<p>docker容器随机分配IP和ports，其生成很多来自于客户端的复杂地址。默认的，ips和ports是本地私有的且不能被外部访问，除非它们绑定了host。</p>
<p>绑定容器的本地端口能防止多容器运行在同一个主机。例如，现在只有一个容器能绑定80端口，当不停机的推出新的容器版本这是很复杂的，因为旧的容器必须在新的容器启动之前停止。反向代理能够帮组我们解决这个问题并且改善0停机部署。</p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx的安装</title>
    <url>/2021/08/02/nginx/nginx%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="nginx的安装">nginx的安装</h2>
<h3 id="1-使用brew-安装">1. 使用<code>brew</code> 安装</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install nginx</span><br></pre></td></tr></table></figure>
<h3 id="2-命令参数">2. 命令参数</h3>
<table>
<thead>
<tr>
<th><code>-?, -h</code></th>
<th>Print help.</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-v</code></td>
<td>Print version.</td>
</tr>
<tr>
<td><code>-V</code></td>
<td>打印<code>NGINX</code>版本、编译版本和配置参数</td>
</tr>
<tr>
<td><code>-t</code></td>
<td>不会运行<code>NGINX</code>,只会测试配置文件. <code>NGINX</code>检查配置文件的指令正确性，并且尝试去尝试打开在配置中被关联的文件.</td>
</tr>
<tr>
<td><code>-q</code></td>
<td>在测试配置的时候抑制<strong>非错误信息</strong></td>
</tr>
<tr>
<td><code>-s signal</code></td>
<td>Send signal to a master process: stop, quit, reopen, reload. (version &gt;= 0.7.53)</td>
</tr>
<tr>
<td><code>-p prefix</code></td>
<td>设置路径前缀 (<code>default:/usr/local/nginx/</code>)</td>
</tr>
<tr>
<td><code>-c filename</code></td>
<td>Specify which configuration file NGINX should use instead of the default.</td>
</tr>
<tr>
<td><code>-g directives</code></td>
<td>设置全局指令</td>
</tr>
</tbody>
</table>
<blockquote>
<p>全局指令：<a href="https://nginx.org/en/docs/http/ngx_http_core_module.html">https://nginx.org/en/docs/http/ngx_http_core_module.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx的使用</title>
    <url>/2021/08/02/nginx/nginx%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="nginx-的使用">nginx 的使用</h2>
<h3 id="1-停止运行">1. 停止运行</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;方法1: 使用 -s 发送指令 -s means signal 记得带上你的配置，否则它就会从默认配置中读取pid&#x27;</span></span><br><span class="line">sudo nginx -s stop -c /etc/nginx/nginx.conf</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;方法2: 使用系统命令，nginx会在运行的时候创建一个pid文件，文件里面有nginx的pid&#x27;</span></span><br><span class="line"><span class="string">&#x27;后面这个路径可以修改的，讲配置文件的时候会讲&#x27;</span></span><br><span class="line">sudo <span class="built_in">kill</span> -QUIT $( <span class="built_in">cat</span> /usr/local/nginx/logs/nginx.pid )</span><br><span class="line"><span class="string">&#x27;下面这个是我常用的&#x27;</span></span><br><span class="line">sudo <span class="built_in">kill</span> -QUIT $( <span class="built_in">cat</span> /etc/nginx/logs/nginx.pid)</span><br></pre></td></tr></table></figure>
<p>对于<code>方法2</code> 还可以使用一些别的参数（好像没什么用）:joy:</p>
<table>
<thead>
<tr>
<th>TERM, INT</th>
<th>快速关闭</th>
</tr>
</thead>
<tbody>
<tr>
<td>QUIT</td>
<td>Graceful shutdown</td>
</tr>
<tr>
<td>KILL</td>
<td>Halts a stubborn process</td>
</tr>
<tr>
<td>HUP</td>
<td>优雅的关闭并使用新的配置文件去重新启动<code>nginx</code></td>
</tr>
<tr>
<td>USR1</td>
<td>Reopen the log files</td>
</tr>
<tr>
<td>USR2</td>
<td>立马升级可执行文件</td>
</tr>
<tr>
<td>WINCH</td>
<td>完美的结束进程</td>
</tr>
</tbody>
</table>
<h3 id="2-运行-nginx">2. 运行 <code>nginx</code></h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nginx -s start -c /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure>
<h3 id="3-测试配置文件">3.测试配置文件</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nginx -t -c /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure>
<h3 id="4-重新加载配置文件">4. 重新加载配置文件</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nginx -s reload -c /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>配置Nginx反向代理服务器</title>
    <url>/2021/08/02/nginx/nginx%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="配置nginx反向代理服务器">配置nginx反向代理服务器</h2>
<h3 id="直接在-etc-nxing-nginx-conf-中配置">直接在 <code>/etc/nxing/nginx.conf</code> 中配置</h3>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">http</span> <span class="string">&#123;</span></span><br><span class="line"><span class="comment">  # 反向代理服务器</span></span><br><span class="line">	<span class="attr">server&#123;</span></span><br><span class="line"><span class="comment">	  # 配置代理服务器</span></span><br><span class="line">		<span class="attr">listen</span>	<span class="string">80;</span></span><br><span class="line">		<span class="attr">server_name</span> <span class="string">http://127.0.0.1;</span></span><br><span class="line">		<span class="attr">access_log</span>	<span class="string">logs/server1.log main;</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">		# 目标真实服务器</span></span><br><span class="line">		<span class="attr">localtion</span> <span class="string">/ &#123;</span></span><br><span class="line">			<span class="attr">proxy_pass</span>	<span class="string">http://127.0.0.1:8080;</span></span><br><span class="line">		<span class="attr">&#125;</span></span><br><span class="line">	<span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>
<p>从上面的配置，我们就可以完成将访问 <code>http://127.0.0.1：80</code>的请求转发给 <code>http://127.0.0.1:8080</code></p>
<p><strong>我们也可以配置多台真实服务器</strong>，也就是所谓的集群</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">  <span class="comment"># 反向代理服务器</span></span><br><span class="line">	server&#123;</span><br><span class="line">	  <span class="comment"># 配置代理服务器</span></span><br><span class="line">		listen	80;</span><br><span class="line">		server_name http://127.0.0.1;</span><br><span class="line">		access_log	logs/server1.<span class="built_in">log</span> main;</span><br><span class="line">		</span><br><span class="line">		<span class="comment"># 目标真实服务器</span></span><br><span class="line">		localtion / &#123;</span><br><span class="line">		<span class="comment"># 这里采用集群方式</span></span><br><span class="line">			proxy_pass	http://tomcats;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment"># tomcats 集群</span></span><br><span class="line">	upstream tomcats &#123;</span><br><span class="line">		server 127.0.0.1:8080;</span><br><span class="line">		server 127.0.0.1:8081;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot使用Swagger2</title>
    <url>/2021/08/02/springboot/%E4%BD%BF%E7%94%A8Swagger2/</url>
    <content><![CDATA[<p>1.使用Swagger2需要进行配置 (配置运行后-&gt;<a href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a>)</p>
<p>创建配置Swagger配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerConfig</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建bean交给spring管理</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">createRestApi</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())  <span class="comment">//构建api文档的详细信息</span></span><br><span class="line">                .select() </span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(Api.class)) <span class="comment">//这里选择被Api注解的类</span></span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构建api文档详细信息</span></span><br><span class="line">    <span class="keyword">private</span> ApiInfo <span class="title function_">apiInfo</span><span class="params">()</span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span></span><br><span class="line">                 .title(<span class="string">&quot;设置文档标题&quot;</span>)</span><br><span class="line">                 .description(<span class="string">&quot;设置接口描述&quot;</span>)</span><br><span class="line">                 .contact(<span class="string">&quot;设置联系方式&quot;</span>)</span><br><span class="line">                 .version(<span class="string">&quot;设置版本&quot;</span>)</span><br><span class="line">                 .build(); <span class="comment">//构建</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.Swagger2注解的使用<br>
实体类注解：@ApiModel (用于类上注解，用于参数用实体类接收)<br>
方法注解：@ApiModelProperty (用于类方法的注解，对model属性进行说明或者对数据对修改)</p>
<p>控制器类注解：@Api (注解用于类上，表示标识这个类是 swagger 的资源)<br>
方法注解：@ApiOperation ( 注解用于方法，表示一个 http 请求的操作)<br>
参数注解：@Param (注解用于参数上，用来标明参数信息)</p>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot数据源</title>
    <url>/2021/08/02/springboot/%E6%95%B0%E6%8D%AE%E6%BA%90/</url>
    <content><![CDATA[<h2 id="spring-boot-配置-druid数据源">spring boot 配置 druid数据源</h2>
<p>druid有许多优点，所以用druid当数据源比较合适，在网上有一个druid的自定配置项目</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://github.com/drtrang/druid-spring-boot</span><br></pre></td></tr></table></figure>
<h3 id="1-首先在pom文件中引入依赖项">1. 首先在pom文件中引入依赖项</h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.drtrang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot2-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.drtrang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot2-actuator-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-最后在application-yaml配置">2. 最后在<code>application.yaml</code>配置</h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="comment"># 使用阿里的Druid连接池</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="comment"># 填写你数据库的url、登录名、密码和数据库名</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/test?useSSL=false&amp;characterEncoding=utf8</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456789</span></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="comment"># 连接池的配置信息</span></span><br><span class="line">      <span class="comment"># 初始化大小，最小，最大</span></span><br><span class="line">      <span class="attr">initial-size:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">min-idle:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">maxActive:</span> <span class="number">20</span></span><br><span class="line">      <span class="comment"># 配置获取连接等待超时的时间</span></span><br><span class="line">      <span class="attr">maxWait:</span> <span class="number">60000</span></span><br><span class="line">      <span class="comment"># 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒</span></span><br><span class="line">      <span class="attr">timeBetweenEvictionRunsMillis:</span> <span class="number">60000</span></span><br><span class="line">      <span class="comment"># 配置一个连接在池中最小生存的时间，单位是毫秒</span></span><br><span class="line">      <span class="attr">minEvictableIdleTimeMillis:</span> <span class="number">300000</span></span><br><span class="line">      <span class="attr">validationQuery:</span> <span class="string">SELECT</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">testWhileIdle:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">testOnBorrow:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">testOnReturn:</span> <span class="literal">false</span></span><br><span class="line">      <span class="comment"># 打开PSCache，并且指定每个连接上PSCache的大小</span></span><br><span class="line">      <span class="attr">poolPreparedStatements:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">maxPoolPreparedStatementPerConnectionSize:</span> <span class="number">20</span></span><br><span class="line">      <span class="comment"># 配置监控统计拦截的filters，去掉后监控界面sql无法统计，&#x27;wall&#x27;用于防火墙</span></span><br><span class="line">      <span class="attr">filters:</span> <span class="string">stat,wall,slf4j</span></span><br><span class="line">      <span class="comment"># 通过connectProperties属性来打开mergeSql功能；慢SQL记录</span></span><br><span class="line">      <span class="attr">connectionProperties:</span> <span class="string">druid.stat.mergeSql\=true;druid.stat.slowSqlMillis\=5000</span></span><br><span class="line">      <span class="comment"># 配置DruidStatFilter</span></span><br><span class="line">      <span class="attr">web-stat-filter:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">url-pattern:</span> <span class="string">&quot;/*&quot;</span></span><br><span class="line">        <span class="attr">exclusions:</span> <span class="string">&quot;*.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,/druid/*&quot;</span></span><br><span class="line">      <span class="comment"># 配置DruidStatViewServlet</span></span><br><span class="line">      <span class="attr">stat-view-servlet:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">url-pattern:</span> <span class="string">&quot;/druid/*&quot;</span></span><br><span class="line">        <span class="comment"># IP白名单(没有配置或者为空，则允许所有访问)</span></span><br><span class="line">        <span class="attr">allow:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">        <span class="comment">#  禁用HTML页面上的“Reset All”功能</span></span><br><span class="line">        <span class="attr">reset-enable:</span> <span class="literal">false</span></span><br><span class="line">        <span class="comment"># 登录名</span></span><br><span class="line">        <span class="attr">login-username:</span> <span class="string">admin</span></span><br><span class="line">        <span class="comment"># 登录密码</span></span><br><span class="line">        <span class="attr">login-password:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure>
<h3 id="3-最后在浏览器访问">3. 最后在浏览器访问</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">localhost:8080/druid</span><br><span class="line"><span class="string">&#x27;账号在上面为：admin&#x27;</span></span><br><span class="line"><span class="string">&#x27;密码在上面为：123456&#x27;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot 日志配置</title>
    <url>/2021/08/02/springboot/%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h2 id="spring-boot-日志配置">spring boot 日志配置</h2>
<p>POM文件引入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="1-修改日志输出级别">1.修改日志输出级别</h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">debug:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">trace:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<ul>
<li>debug 模式会将INFO 、ERROR、WARN 信息给输出</li>
<li>trace 级别会更详细，能囊括springboot的全部log输出</li>
</ul>
<p>还可以设置其它的日志系统</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">root:</span> <span class="string">warn</span></span><br></pre></td></tr></table></figure>
<h3 id="2-使用彩色日志编码输出">2.使用彩色日志编码输出</h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">output:</span></span><br><span class="line">    <span class="attr">ansi:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure>
<h3 id="3-传统方式配置logback">3. 传统方式配置logback</h3>
<p>新建文件conf/logback-prod.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 控制台打印日志的相关配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;STDOUT&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 日志格式 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss&#125; %highlight(%-4relative) [%thread] %highlight(%-5level) %logger&#123;35&#125; - %msg %n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FILE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 保存日志文件的路径 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>.logs/log.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 日志格式 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss&#125; %highlight(%-4relative) [%thread] %-5level %logger&#123;35&#125; - %msg %n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 循环政策：基于时间创建日志文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 日志文件名格式 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>.logs/%d&#123;yyyy-MM-dd&#125;.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 最大保存时长--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>10<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--日志文件最大大小--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>10MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--日志上限--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">totalSizeCap</span>&gt;</span>1GB<span class="tag">&lt;/<span class="name">totalSizeCap</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!---在启动的时候清除历史日志--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">cleanHistoryOnStart</span>&gt;</span>false<span class="tag">&lt;/<span class="name">cleanHistoryOnStart</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--处理日志--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILE&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后在<code>application-prod.yaml</code>中写入</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">config:</span> <span class="string">classpath:conf/logback-prod.xml</span></span><br></pre></td></tr></table></figure>
<p>最后可以在 <code>application.yaml</code> 指定启动的profile</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">prod</span></span><br></pre></td></tr></table></figure>
<p>###4. 使用springProfile配置logback</p>
<p>首先新建<code>/conf/logback-spring.xml</code>，然后在<code>application.yaml</code> 指定</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">config:</span> <span class="string">classpath:conf/logback-spring.xml</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--可以引入环境变量--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProperty</span> <span class="attr">scope</span>=<span class="string">&quot;context&quot;</span> <span class="attr">name</span>=<span class="string">&quot;FILE_PATH&quot;</span> <span class="attr">source</span>=<span class="string">&quot;logging.path&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">defaultValue</span>=<span class="string">&quot;.logs&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开发环境配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;dev&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;STDOUT&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 日志格式 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss&#125; %highlight(%-4relative) [%thread] %highlight(%-5level) %logger&#123;35&#125; - %msg %n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--生产环境配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;prod&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FILE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 保存日志文件的路径 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;FILE_PATH&#125;/log.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 日志格式 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss&#125; %highlight(%-4relative) [%thread] %-5level %logger&#123;35&#125; - %msg %n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 循环政策：基于大小和时间创建日志文件 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 日志文件名格式 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;FILE_PATH&#125;/%d&#123;yyyy-MM-dd&#125;_%i.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 最大保存时长--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>10<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--日志文件最大大小--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>10MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--日志上限--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">totalSizeCap</span>&gt;</span>1GB<span class="tag">&lt;/<span class="name">totalSizeCap</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!---在启动的时候清除历史日志--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">cleanHistoryOnStart</span>&gt;</span>false<span class="tag">&lt;/<span class="name">cleanHistoryOnStart</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILE&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面我们可以用 <code>springProperty</code> 引入环境变量，之后我们就可以在 <code>application.yaml</code>中设置我们的环境变量</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">config:</span> <span class="string">classpath:conf/logback-spring.xml</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">./logs</span></span><br></pre></td></tr></table></figure>
<h3 id="5-添加-logstash-elk-进行日志可视化">5. 添加 logstash + elk 进行日志可视化</h3>
<ol>
<li>首先安装ELK:</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;elsticsearch&#x27;</span></span><br><span class="line">brew install elastic/tap/elasticsearch-full</span><br><span class="line"><span class="string">&#x27;logstash&#x27;</span></span><br><span class="line">brew install elastic/tap/logstash-full</span><br><span class="line"><span class="string">&#x27;kibana&#x27;</span></span><br><span class="line">brew install elastic/tap/kibana-full</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>
<p>然后配置<code>logback-spring.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;STASH&quot;</span> <span class="attr">class</span>=<span class="string">&quot;net.logstash.logback.appender.LogstashTcpSocketAppender&quot;</span>&gt;</span></span><br><span class="line">           <span class="comment">&lt;!--配置logStash 服务地址--&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">destination</span>&gt;</span>localhost:4560<span class="tag">&lt;/<span class="name">destination</span>&gt;</span></span><br><span class="line">           <span class="comment">&lt;!-- 日志输出编码 --&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">class</span>=<span class="string">&quot;net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder&quot;</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">providers</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">timestamp</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">timeZone</span>&gt;</span>UTC<span class="tag">&lt;/<span class="name">timeZone</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;/<span class="name">timestamp</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">pattern</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">pattern</span>&gt;</span></span><br><span class="line">                           &#123;</span><br><span class="line">                           &quot;logLevel&quot;: &quot;%level&quot;,</span><br><span class="line">                           &quot;serviceName&quot;: &quot;$&#123;springAppName:-&#125;&quot;,</span><br><span class="line">                           &quot;pid&quot;: &quot;$&#123;PID:-&#125;&quot;,</span><br><span class="line">                           &quot;thread&quot;: &quot;%thread&quot;,</span><br><span class="line">                           &quot;class&quot;: &quot;%logger&#123;40&#125;&quot;,</span><br><span class="line">                           &quot;rest&quot;: &quot;%message&quot;</span><br><span class="line">                           &#125;</span><br><span class="line">                       <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">providers</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STASH&quot;</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后添加<code>logstash</code>依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.logstash.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logstash-logback-encoder<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>3.接下来新建一个<code>logstash.conf</code>的配置文件，这个文件可以放在任意位置</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  tcp &#123;</span><br><span class="line">    mode =&gt; &quot;server&quot;</span><br><span class="line">    host =&gt; &quot;localhost&quot;</span><br><span class="line">    port =&gt; 4560</span><br><span class="line">    codec =&gt; json_lines</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    hosts =&gt; &quot;localhost:9200&quot;</span><br><span class="line">    index =&gt; &quot;springboot-logstash-%&#123;+YYYY.MM.dd&#125;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>其中<code>input</code>代表<code>logstash</code>的配置信息，包括端口号什么的</p>
<p>然后<code>output</code>代表<code>elasticsearch</code> 的地址</p>
<ol start="3">
<li>
<p>最后依次启动服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">elasticsearch</span><br><span class="line">kibana</span><br><span class="line">logstash -f logstash.conf</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>然后进入<code>kibana</code>的主页即可看到数据信息（前提我得会elaticsearch）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">http://localhost:5601/app/kibana#/discover</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot配置使用</title>
    <url>/2021/08/02/springboot/%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="spring-boot-外部配置">spring boot  外部配置</h2>
<h3 id="1-使用配置bean的属性">1.使用配置bean的属性</h3>
<p>bean的定义:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix=&quot;bean&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestBean</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; list;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Integer&gt; mapper;</span><br><span class="line">  	<span class="comment">// setter &amp; getter ... 必须要提供setter 和 getter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>yml文件:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">bean:</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">inject</span> <span class="string">property</span></span><br></pre></td></tr></table></figure>
<ul>
<li>利用 <code>@ConfigurationPropertyes</code> 注解可以将yml中的数据对象注入到bean里面，其中<code>prefix</code> 为数据对象的名称</li>
</ul>
<h4 id="集合类型的属性配置">集合类型的属性配置</h4>
<p>首先是list</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">bean:</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">inject</span> <span class="string">property</span></span><br><span class="line">  <span class="attr">list:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">1</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">2</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<ul>
<li>用 <code>-</code> 来作为集合中的每一个数据</li>
</ul>
<p>最后是map</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">bean:</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">inject</span> <span class="string">property</span></span><br><span class="line">  <span class="attr">list:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">1</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">2</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">mapper:</span></span><br><span class="line">    <span class="attr">key1:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">key2:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>yaml本身就会从properties转换为map，所以它本身就是一个map，和定义其它数据对象一样，也就是用key-value的方式定义.</li>
</ul>
<h4 id="配置springboot">配置springboot</h4>
<p>配置web服务器端口号</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>
<p>在生产过程中我们肯能需要有多种环境，比如生产环境，测试环境，开发环境，我们可以采用profile方式进行配置，新建三个文件</p>
<ol>
<li>Application-dev.yaml</li>
<li>Application-prod.yaml</li>
<li>Application-test.yaml</li>
</ol>
<p>然后在上面的文件中配置不同的端口号，然后在application.yaml中</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">test</span></span><br></pre></td></tr></table></figure>
<p>用这个属性就可以随意切换配置文件了</p>
<h3 id="2-使用properties配置">2.使用properties配置</h3>
<p>新建一个properties文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">testbean.name</span>=<span class="string">fafa</span></span><br><span class="line"><span class="attr">testbean.age</span>=<span class="string">12223</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8081</span></span><br></pre></td></tr></table></figure>
<p>然后在bean上面利用注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;testbean&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(value=&quot;classpath:bean.properties&quot;)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>利用 <code>@PropertySource </code> 可以引入properties文件</li>
<li>然后用 <code>@ConfigurationProperties</code> 可以将配置文件的对象注入到bean中</li>
</ul>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Idea-vim 快捷键</title>
    <url>/2020/05/02/vim/Idea-vim%20%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<h2 id="IDEAVIM-常用快捷键">IDEAVIM 常用快捷键</h2>
<ol>
<li>跳转</li>
</ol>
<ul>
<li><code>ctrl-]</code> 跳转到实现</li>
<li><code>ctrl-o</code> 返回上一次编辑地方</li>
<li><code>ctrl-i</code> 跳到上一个跳转到的地方, 用 上面的跳回来，用这个再跳过去</li>
</ul>
<ol start="2">
<li>
<p>修改</p>
<ul>
<li>
<p><code>c-i-w</code> 修改整个句子</p>
</li>
<li>
<p><code>c-i-W</code> 修改整行</p>
</li>
<li>
<p><code>c-i-(</code> 修改整个括号里面的内容</p>
</li>
<li>
<p><code>c-i-&quot;</code> 修改双引号里面的内容</p>
</li>
<li>
<p><code>C</code> 从当前光标的位置修改至行尾</p>
</li>
</ul>
</li>
<li>
<p>复制</p>
<ul>
<li><code>y-i-w</code> 复制整个句子</li>
<li><code>y-i-W</code> 复制整行，不包括换行符</li>
<li><code>yy</code> 复制整行，包括换行符</li>
<li><code>y-i-(</code> 复制括号里面的内容</li>
<li><code>y-i-&quot;</code> 复制双引号里面的内容</li>
<li><code>Y</code>  复制整行，包括换行符</li>
</ul>
</li>
<li>
<p>删除</p>
<ul>
<li>
<p><code>d-i-w</code> 删除整个句子</p>
</li>
<li>
<p><code>d-i-W</code> 删除整行</p>
</li>
<li>
<p><code>d-i-(</code> 删除整个括号里面的内容</p>
</li>
<li>
<p><code>d-i-&quot;</code> 删除双引号里面的内容</p>
</li>
<li>
<p><code>D</code> 从当前光标的位置删除至行尾</p>
</li>
<li>
<p><code>dd</code> 删除整行数据</p>
</li>
</ul>
</li>
<li>
<p>搜索</p>
<ul>
<li><code>:? 搜索的内容</code></li>
<li><code>n</code> 上一个</li>
<li><code>N</code> 下一个</li>
</ul>
</li>
<li>
<p>技巧</p>
<ul>
<li><code>shif-~</code> 将小写字母转换为大写，将大写字母转换为小写</li>
</ul>
</li>
<li>
<p><code>idea</code> 专属<code>VIM</code>快捷键</p>
<ul>
<li><code>fa (find action)</code></li>
<li><code>fc (find class)</code></li>
<li><code>ff (find file)</code></li>
<li><code>fs (find symbol)</code></li>
<li><code>fu (find usage)</code></li>
<li><code>gi (goto implementation)</code></li>
<li><code>gt (goto test)</code></li>
<li><code>gd (goto declaration)</code></li>
<li><code>gb (go back)</code></li>
<li><code>gf (go forward)</code></li>
<li><code>gn (goto generate)</code></li>
<li><code>re (refactor element)</code></li>
<li><code>rf (fefactor file name)</code></li>
<li><code>su (show usage)</code></li>
<li><code>term (show terminal)</code></li>
<li><code>nc (new class)</code></li>
<li><code>nf (new file)</code></li>
<li><code>nhtml (new html)</code></li>
<li><code>format (reformat code)</code></li>
<li><code>cleanimport (clean optimize imports)</code></li>
</ul>
<blockquote>
<p>更多action <a href="https://gist.github.com/zchee/9c78f91cc5ad771c1f5d">https://gist.github.com/zchee/9c78f91cc5ad771c1f5d</a></p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>Vim</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Debian安装code-server</title>
    <url>/2021/09/14/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Debian%E5%AE%89%E8%A3%85code-server/</url>
    <content><![CDATA[<ul>
<li>拉取安装包</li>
<li>Release地址：<a href="https://github.com/cdr/code-server/releases">https://github.com/cdr/code-server/releases</a></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里使用了加速镜像</span></span><br><span class="line">curl -fOL https://github.91chifun.workers.dev/https://github.com//cdr/code-server/releases/download/v3.11.1/code-server_3.11.1_amd64.deb</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压安装</span></span><br><span class="line">sudo dpkg -i code-server_3.11.1_amd64.deb</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">随系统启动</span></span><br><span class="line">sudo systemctl enable --now code-server@$USER</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启服务，我这里用户名是root</span></span><br><span class="line">systemctl restart code-server@root.service</span><br></pre></td></tr></table></figure>
<ul>
<li>编辑配置</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认配置路径~/.config/code-server/config.yaml</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">字段为绑定地址跟端口，IP:Port,其中允许任何IP访问，设置ip为0.0.0.0</span></span><br><span class="line">bind-addr: 127.0.0.1:8080</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">auth字段，password为密码认证，none为无认证</span></span><br><span class="line">auth: password</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">password字段，密码</span></span><br><span class="line">password: xxxx</span><br></pre></td></tr></table></figure>
<ul>
<li>详细文档：<a href="https://coder.com/docs/code-server/v3.11.1">https://coder.com/docs/code-server/v3.11.1</a></li>
</ul>
]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Gateway与服务间跨域的坑</title>
    <url>/2021/03/25/%E8%AE%B0%E5%BD%95%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/Spring%20Gateway%E4%B8%8E%E6%9C%8D%E5%8A%A1%E9%97%B4%E8%B7%A8%E5%9F%9F%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<blockquote>
<p>gateway设置一次cors即可，微服务不需要再进行设置跨域，否则前端XMLHttpRequest上传文件显示报错，实际上后端已经接收到文件并且正常写入。</p>
</blockquote>
<img src="/2021/03/25/%E8%AE%B0%E5%BD%95%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/Spring%20Gateway%E4%B8%8E%E6%9C%8D%E5%8A%A1%E9%97%B4%E8%B7%A8%E5%9F%9F%E7%9A%84%E5%9D%91/34499454-77B7-4A97-ADE7-3007A2D30E49-33843ac69b264069a9eba75efdf707ef.png" class="" title="image">]]></content>
      <categories>
        <category>开发的坑</category>
      </categories>
      <tags>
        <tag>Spring Gateway</tag>
      </tags>
  </entry>
  <entry>
    <title>踩坑</title>
    <url>/2021/10/27/%E8%AE%B0%E5%BD%95%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<ul>
<li>2021-10-27</li>
</ul>
<blockquote>
<p>从Spring项目源码构建到成品Docker镜像过程中，遇到jdeps --multi-release的坑。总结：这基本上使得多版本jar无法与模块一起使用。</p>
</blockquote>
]]></content>
      <categories>
        <category>开发的坑</category>
      </categories>
  </entry>
  <entry>
    <title>项目打包Docker镜像遇到默认ANSI-X3-4-1968编码的坑</title>
    <url>/2021/08/16/%E8%AE%B0%E5%BD%95%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BADocker%E9%95%9C%E5%83%8F%E9%81%87%E5%88%B0%E9%BB%98%E8%AE%A4ANSI-X3-4-1968%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<ul>
<li>笔者在一次做项目的Runtime环境，自制精简Jre Docker image过程中替换base镜像遇到到编码问题</li>
</ul>
<img src="/2021/08/16/%E8%AE%B0%E5%BD%95%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BADocker%E9%95%9C%E5%83%8F%E9%81%87%E5%88%B0%E9%BB%98%E8%AE%A4ANSI-X3-4-1968%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/question.png" class="" title="question">
<ul>
<li>Dockerfile文件</li>
</ul>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> eclipse-temurin:16.0.2_7-jdk as jre-build</span><br><span class="line"><span class="comment"># Create a custom Java runtime</span></span><br><span class="line"><span class="built_in">RUN</span> <span class="variable">$JAVA_HOME</span>/bin/jlink \</span><br><span class="line">         --add-modules java.base,java.compiler,java.logging,java.desktop,java.management,java.naming,java.net.http,java.rmi,java.scripting,java.security.jgss,java.sql,java.xml,jdk.jdi,jdk.unsupported \</span><br><span class="line">         --strip-<span class="built_in">debug</span> \</span><br><span class="line">         --no-man-pages \</span><br><span class="line">         --no-header-files \</span><br><span class="line">         <span class="attribute">--compress</span>=2 \</span><br><span class="line">         --output /javaruntime</span><br><span class="line"></span><br><span class="line"><span class="comment"># Define your base image</span></span><br><span class="line"><span class="keyword">FROM</span> debian:buster-slim<span class="built_in"></span></span><br><span class="line"><span class="built_in">USER </span>root</span><br><span class="line">LABEL <span class="attribute">name</span>=vertx-ddns</span><br><span class="line">LABEL <span class="attribute">url</span>=https://github.com/zf1976/vertx-ddns</span><br><span class="line"></span><br><span class="line">ENV <span class="attribute">JAVA_HOME</span>=/opt/java/openjdk</span><br><span class="line">ENV PATH <span class="string">&quot;<span class="variable">$&#123;JAVA_HOME&#125;</span>/bin:<span class="variable">$&#123;PATH&#125;</span>&quot;</span></span><br><span class="line">COPY <span class="attribute">--from</span>=jre-build /javaruntime <span class="variable">$JAVA_HOME</span></span><br><span class="line"><span class="comment">#COPY --from=jre-build /usr/share/fonts /usr/share/fonts</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Continue with your application deployment</span></span><br><span class="line"><span class="built_in">RUN</span> mkdir /opt/app</span><br><span class="line">ARG <span class="attribute">JAR_FILE</span>=build/libs/vertx-ddns-latest-all.jar</span><br><span class="line">COPY <span class="variable">$&#123;JAR_FILE&#125;</span> /opt/app/vertx-ddns.jar</span><br><span class="line">ENV <span class="attribute">JVM_XMS</span>=<span class="string">&quot;256m&quot;</span> \</span><br><span class="line">    <span class="attribute">JVM_XMX</span>=<span class="string">&quot;256m&quot;</span> \</span><br><span class="line">    <span class="attribute">JVM_OPTS</span>=<span class="string">&quot;-Xmx256m -Xms256m&quot;</span> \</span><br><span class="line">    <span class="attribute">TZ</span>=Asia/Shanghai</span><br><span class="line"></span><br><span class="line">CMD exec java -Xms<span class="variable">$&#123;JVM_XMS&#125;</span> -Xmx<span class="variable">$&#123;JVM_XMX&#125;</span> <span class="variable">$&#123;JVM_OPTS&#125;</span> -Djdk.reflect.<span class="attribute">allowGetCallerClass</span>=<span class="literal">true</span> -Djava.security.<span class="attribute">egd</span>=file:/dev/./urandom -jar /opt/app/vertx-ddns.jar</span><br></pre></td></tr></table></figure>
<ul>
<li>途中替换多种base镜像,譬如debian:buster-slim，系统编码都默认是ANSI_X3.4-1968，这算是个坑吧，不知为何官方不喜欢用UTF-8<img src="/2021/08/16/%E8%AE%B0%E5%BD%95%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BADocker%E9%95%9C%E5%83%8F%E9%81%87%E5%88%B0%E9%BB%98%E8%AE%A4ANSI-X3-4-1968%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/console.png" class="" title="console">
</li>
<li>最后在Dockerfile配置文件加上 LANG C.UTF-8，设置系统编码为UTF-8可以解决程序字符乱码问题</li>
</ul>
]]></content>
      <categories>
        <category>开发的坑</category>
      </categories>
      <tags>
        <tag>Docker Build</tag>
      </tags>
  </entry>
  <entry>
    <title>Gradle阿里云镜像</title>
    <url>/2020/03/26/%E9%85%8D%E7%BD%AE/Gradle%E9%98%BF%E9%87%8C%E4%BA%91%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<h4 id="build-gradle">build.gradle</h4>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">repositories</span> &#123; <span class="keyword">maven</span>&#123; url&#x27;http<span class="operator">:</span><span class="comment">//maven.aliyun.com/nexus/content/groups/public/&#x27;&#125; &#125;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>Gradle项目打包Jar插件简单使用</title>
    <url>/2021/08/04/%E9%85%8D%E7%BD%AE/Gradle%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85Jar%E6%8F%92%E4%BB%B6%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<p>笔者在折腾自己的普通Java项目打包（并非Spring项目）<br>
从6.x升级了Gradle7.0版本，下面这种打包方式似乎已经不支持了（暂时没研究api是否已经变化）</p>
</blockquote>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">jar &#123;</span><br><span class="line">    manifest &#123;</span><br><span class="line">        attributes(</span><br><span class="line">                <span class="string">&quot;Manifest-Version&quot;</span>: <span class="number">1.0</span>,</span><br><span class="line">                <span class="string">&#x27;Main-Class&#x27;</span>:<span class="string">&#x27;com.zf1976.ddns.Application&#x27;</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">from</span> &#123; <span class="keyword">configurations</span>.<span class="keyword">compile</span>.<span class="keyword">collect</span> &#123; it.isDirectory() ? it : zipTree(it) &#125; &#125;</span><br><span class="line">    <span class="keyword">into</span>(<span class="string">&#x27;assets&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">from</span> <span class="string">&#x27;assets&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>时间关系懒得折腾，经测试使用shadow插件能解决大部分Java项目打包</li>
</ul>
<blockquote>
<p>详细请移步Github：<a href="https://github.com/johnrengelman/shadow">https://github.com/johnrengelman/shadow</a></p>
<p>配置跟上面方式差不多</p>
</blockquote>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//打jar包需要的配置</span></span><br><span class="line">jar &#123;</span><br><span class="line">    manifest &#123;</span><br><span class="line">        attributes(</span><br><span class="line">                <span class="string">&quot;Manifest-Version&quot;</span>: <span class="number">1.0</span>,</span><br><span class="line">                &#x27;Main-Class&#x27;:&#x27;com.zf<span class="number">1976</span>.ddns.Application&#x27;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux发行版设置OpenWrt网易云音乐解锁参数</title>
    <url>/2022/03/29/%E9%85%8D%E7%BD%AE/Linux%E8%AE%BE%E7%BD%AEOpenWrt%20%E7%BD%91%E6%98%93%E4%BA%91%E8%A7%A3%E9%94%81/</url>
    <content><![CDATA[<blockquote>
<p>Linux 客户端 (1.2 版本以上需要自签证书 MITM，启动客户端需要增加 –ignore-certificate-errors 参数)</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vi /usr/share/applications/netease-cloud-music.desktop</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在<code>Exec</code>行末尾增加<code>--ignore-certificate-errors</code>参数</p>
</blockquote>
]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven阿里云镜像</title>
    <url>/2020/03/26/%E9%85%8D%E7%BD%AE/Maven%E9%98%BF%E9%87%8C%E4%BA%91%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<h4 id="重写settings-xml">重写settings.xml</h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">                          https://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirror</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>          </span><br><span class="line">        <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>配置</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL修改密码</title>
    <url>/2021/03/18/%E9%85%8D%E7%BD%AE/MySQL%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<h3 id="MySQL5-7版本">MySQL5.7版本</h3>
<blockquote>
<p>查看当前版本密码策略</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;validate_password%&#x27;;</span><br><span class="line">+--------------------------------------+--------+</span><br><span class="line">| Variable_name                        | Value  |</span><br><span class="line">+--------------------------------------+--------+</span><br><span class="line">| validate_password_check_user_name    | OFF    |</span><br><span class="line">| validate_password_dictionary_file    |        |</span><br><span class="line">| validate_password_length             | 8      |</span><br><span class="line">| validate_password_mixed_case_count   | 1      |</span><br><span class="line">| validate_password_number_count       | 1      |</span><br><span class="line">| validate_password_policy             | MEDIUM |</span><br><span class="line">| validate_password_special_char_count | 1      |</span><br><span class="line">+--------------------------------------+--------+</span><br></pre></td></tr></table></figure>
<blockquote>
<p>密码策略级别(简单密码可以按需求设置)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set global validate_password_policy=LOW;</span><br><span class="line">set global validate_password_policy=6;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>修改密码</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use mysql;</span><br><span class="line">update user set authentication_string = password(&#x27;your_password&#x27;) where User=&#x27;root&#x27;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>刷新权限</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL策略备份SQL文件（逻辑备份）</title>
    <url>/2021/03/18/%E9%85%8D%E7%BD%AE/MySQL%E7%AD%96%E7%95%A5%E5%A4%87%E4%BB%BD/</url>
    <content><![CDATA[<blockquote>
<p>笔者用的是MySQL5.7版本，如果是在macOS or Linux<br>
配置策略文件用户名密码</p>
</blockquote>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">vim编辑文件： sudo vim /etc/my.cnf</span><br><span class="line"></span><br><span class="line">新增内容：</span><br><span class="line">[client]</span><br><span class="line"><span class="attribute">user</span>=your_username</span><br><span class="line"><span class="attribute">password</span>=your_password</span><br><span class="line"></span><br><span class="line">:wq退出</span><br><span class="line">终端输入：mysqldump <span class="attribute">--defaults-extra-file</span>=/etc/my.cnf your_database &gt; /your_path</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：macOS or Linux 可以使用man page查询相关命令 如：man --defaults-extra-file</p>
</blockquote>
]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenJ9 优化参数以及IDEA 使用OpenJ9作为Runtime</title>
    <url>/2021/03/26/%E9%85%8D%E7%BD%AE/OpenJ9%20%E4%BC%98%E5%8C%96%E5%8F%82%E6%95%B0%E4%BB%A5%E5%8F%8AIDEA%20%E4%BD%BF%E7%94%A8OpenJ9%E4%BD%9C%E4%B8%BARuntime/</url>
    <content><![CDATA[<h1>优化后叠buff</h1>
<ul>
<li>优化参数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:+UseShenandoahGC -Xshareclasses:name=(随便整个) -Xquickstart -Xscmx512M</span><br></pre></td></tr></table></figure>
<ul>
<li>IDEA使用OpenJ9作为Runtime</li>
</ul>
<blockquote>
<p>下载Choose Runtime插件</p>
</blockquote>
<img src="/2021/03/26/%E9%85%8D%E7%BD%AE/OpenJ9%20%E4%BC%98%E5%8C%96%E5%8F%82%E6%95%B0%E4%BB%A5%E5%8F%8AIDEA%20%E4%BD%BF%E7%94%A8OpenJ9%E4%BD%9C%E4%B8%BARuntime/4A5B7A91-A6A4-40B9-9256-8F992B01FE89-ab0e0ba9920943429c45bb523343caa4.png" class="">
<p>切换OpenJ9作为Runtime</p>
<ul>
<li>注：openj9下载地址：<a href="http://injdk.cn">JDK Download</a></li>
</ul>
]]></content>
      <categories>
        <category>配置</category>
      </categories>
  </entry>
  <entry>
    <title>1.Bean的包装</title>
    <url>/2021/08/02/spring_analysis/beans/1.bean%E7%9A%84%E5%8C%85%E8%A3%85/</url>
    <content><![CDATA[<h3 id="1-前言">1.前言</h3>
<p>为什么先从对bean的包装开始阅读源码呢，因为beans包的核心就是<code>BeanFactory</code> 🐶，其作用就是对bean进行管理，那么对bean管理的前提就是对bean进行解析，然后支持属性的<code>set</code> 或 <code>get</code> 操作。那么我们列举一下<code>BeanFactory</code>的主要职责，即使没阅读过源码，也应该知道个大概过程.</p>
<ul>
<li>解析<code>xml</code>或者其它配置文件得到 <code>BeanDefinition</code></li>
<li>实例化 <code>Instance</code></li>
<li><code>AutoWired</code>自动装配 <code>Bean</code>的依赖</li>
</ul>
<p><strong>所以，我们先了解如何去得到一个Bean的 “定义” (解析xml那部分先不讲)</strong></p>
<h3 id="2-BeanWrapper接口">2. BeanWrapper接口</h3>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">这个类的主要作用是解析`Class` 然后获取属性，进一步封装，然后提供修改属性的接口</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanWrapper</span> <span class="keyword">extends</span> <span class="title class_">ConfigurablePropertyAccessor</span> &#123;</span><br><span class="line">  <span class="comment">// 设置集合属性自增长的长度</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">setAutoGrowCollectionLimit</span><span class="params">(<span class="type">int</span> autoGrowCollectionLimit)</span>;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// 获取当前集合属性自增长的长度</span></span><br><span class="line">	<span class="type">int</span> <span class="title function_">getAutoGrowCollectionLimit</span><span class="params">()</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 获取包装的Bean的Instance</span></span><br><span class="line">	Object <span class="title function_">getWrappedInstance</span><span class="params">()</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 获取Bean的Class</span></span><br><span class="line">	Class&lt;?&gt; getWrappedClass();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 获取所有属性描述符</span></span><br><span class="line">	PropertyDescriptor[] getPropertyDescriptors();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 获取属性描述符</span></span><br><span class="line">	PropertyDescriptor <span class="title function_">getPropertyDescriptor</span><span class="params">(String propertyName)</span> <span class="keyword">throws</span> InvalidPropertyException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么上面会涉及到<strong>集合</strong>，因为<code>Bean</code> 支持<code>nested (嵌套)</code> 属性读写，也就是<code>pojo</code></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">bean.setValue(&quot;bean.child.attr&quot;,</span> <span class="string">1)</span></span><br></pre></td></tr></table></figure>
<h3 id="3-BeanWrapperImpl实现">3. <code>BeanWrapperImpl实现</code></h3>
<ol>
<li>
<p>我们从其测试代码中可以看到这样的用法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">GetterBean</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetterBean</span>();</span><br><span class="line"><span class="type">BeanWrapper</span> <span class="variable">accessor</span> <span class="operator">=</span> createAccessor(target);</span><br><span class="line">accessor.setPropertyValue(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;tom&quot;</span>);</span><br><span class="line">assertThat(target.getAliasedName()).isEqualTo(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">assertThat(accessor.getPropertyValue(<span class="string">&quot;aliasedName&quot;</span>)).isEqualTo(<span class="string">&quot;tom&quot;</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> BeanWrapperImpl <span class="title function_">createAccessor</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BeanWrapperImpl</span>(target);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到 <code>createAccessor</code> 就是<code>new BeanWrapperImpl</code>就完成对<code>Bean</code>的封装了， 就可以调用</p>
<ul>
<li><code>setPropertyValue</code>  设置属性值</li>
<li><code>getPropertyValue</code>  获取属性值</li>
</ul>
</li>
<li>
<p>初步看下 <code>BeanWrapperImpl</code>的<code>UML</code> (不用纠结 <code>UML</code> 后面会人肉其运行过程) :happy:</p>
</li>
</ol>
<img src="/2021/08/02/spring_analysis/beans/1.bean%E7%9A%84%E5%8C%85%E8%A3%85/image-20191012223223606.png" class="">
<p><strong>在上面这个图中，着重 <code>AbstractNesablePropertyAccessor</code></strong> 此类是用于支持上文提到的<code>Nested</code> 嵌套属性读写.</p>
<ol start="3">
<li>
<p><code>getPropertyDescriptor</code> 获取属性描述符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> PropertyDescriptor <span class="title function_">getPropertyDescriptor</span><span class="params">(String propertyName)</span> <span class="keyword">throws</span> InvalidPropertyException &#123;</span><br><span class="line">		<span class="comment">// [1] 先解析嵌套属性，获取最后一个属性的Instance</span></span><br><span class="line">		<span class="type">BeanWrapperImpl</span> <span class="variable">nestedBw</span> <span class="operator">=</span> (BeanWrapperImpl) getPropertyAccessorForPropertyPath(propertyName);</span><br><span class="line">		<span class="type">String</span> <span class="variable">finalPath</span> <span class="operator">=</span> getFinalPath(nestedBw, propertyName);</span><br><span class="line">		<span class="comment">// [2] 然后直接获取属性描述符</span></span><br><span class="line">		<span class="type">PropertyDescriptor</span> <span class="variable">pd</span> <span class="operator">=</span> nestedBw.getCachedIntrospectionResults().getPropertyDescriptor(finalPath);</span><br><span class="line">		<span class="keyword">if</span> (pd == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidPropertyException</span>(getRootClass(), getNestedPath() + propertyName,</span><br><span class="line">					<span class="string">&quot;No property &#x27;&quot;</span> + propertyName + <span class="string">&quot;&#x27; found&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> pd;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>刚才我们说过其支持<code>nested</code> 嵌套属性，如果我们传入的<code>propertyName</code> 为 <code>bean.child.name</code> ，我们就要先拿到 <code>bean</code> 然后再拿到 <code>child</code> 最后拿到 <code>name</code> 然后才能返回类型描述符. ​ :warning: 第一步我们先不管</p>
</li>
<li>
<p>然后第二步 <code>getCachedIntrospectionResults#getPropertyDescriptor()</code> 来获取属性描述符</p>
</li>
<li>
<p><code>CachedIntrospectionResults</code> 中包含 <code>PropertyDescriptor</code> 信息，跟下去</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> CachedIntrospectionResults <span class="title function_">getCachedIntrospectionResults</span><span class="params">()</span> &#123;</span><br><span class="line">   	<span class="comment">// [1] 判断是不是有缓存了</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.cachedIntrospectionResults == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// [2] 缓存中没有那就 new</span></span><br><span class="line">			<span class="built_in">this</span>.cachedIntrospectionResults = CachedIntrospectionResults.forClass(getWrappedClass());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.cachedIntrospectionResults;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>继续跟。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> CachedIntrospectionResults <span class="title function_">forClass</span><span class="params">(Class&lt;?&gt; beanClass)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">		<span class="comment">// [1] 从一级缓存中获取</span></span><br><span class="line">		<span class="type">CachedIntrospectionResults</span> <span class="variable">results</span> <span class="operator">=</span> strongClassCache.get(beanClass);</span><br><span class="line">		<span class="keyword">if</span> (results != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> results;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// [2] 从二级缓存中获取</span></span><br><span class="line">		results = softClassCache.get(beanClass);</span><br><span class="line">		<span class="keyword">if</span> (results != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> results;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// [3] 如果都没有，则New一个, 核心还是在这</span></span><br><span class="line">		results = <span class="keyword">new</span> <span class="title class_">CachedIntrospectionResults</span>(beanClass);</span><br><span class="line">		ConcurrentMap&lt;Class&lt;?&gt;, CachedIntrospectionResults&gt; classCacheToUse;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// [4] 判断使用一级缓存还是二级缓存</span></span><br><span class="line">		<span class="comment">// 经调试，发现spring用的是一级缓存</span></span><br><span class="line">		<span class="keyword">if</span> (ClassUtils.isCacheSafe(beanClass, CachedIntrospectionResults.class.getClassLoader()) ||</span><br><span class="line">				isClassLoaderAccepted(beanClass.getClassLoader())) &#123;</span><br><span class="line">			classCacheToUse = strongClassCache;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;Not strongly caching class [&quot;</span> + beanClass.getName() + <span class="string">&quot;] because it is not cache-safe&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			classCacheToUse = softClassCache;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// [5] 将新New的放入缓存</span></span><br><span class="line">		<span class="type">CachedIntrospectionResults</span> <span class="variable">existing</span> <span class="operator">=</span> classCacheToUse.putIfAbsent(beanClass, results);</span><br><span class="line">		<span class="keyword">return</span> (existing != <span class="literal">null</span> ? existing : results);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>spring</code> 很善用缓存，这里可以看到，其用了两个缓存 <code>strongClassCache</code> 和 <code>softClassCache</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/* [DESC] 一级缓存*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ConcurrentMap&lt;Class&lt;?&gt;, CachedIntrospectionResults&gt; strongClassCache =</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">64</span>);</span><br><span class="line">     </span><br><span class="line"><span class="comment">/* [DESC] 二级缓存 又称为 SoftCache，因为采用弱引用MAP，所以缓存元素长时间未使用则会被回收*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ConcurrentMap&lt;Class&lt;?&gt;, CachedIntrospectionResults&gt; softClassCache =</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">ConcurrentReferenceHashMap</span>&lt;&gt;(<span class="number">64</span>);</span><br></pre></td></tr></table></figure>
<p><strong>虽然其设置了两层缓存，但实际只用到了 <code>strongClassCache</code></strong> 因为属性这些会常驻内存，所以不需要使用弱引用的<code>Map</code>,实际上控制使用那个缓存是<code>isCacheSafe</code> 来控制的, 继续跟 :hammer:我是最强人肉王子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isCacheSafe</span><span class="params">(Class&lt;?&gt; clazz, <span class="meta">@Nullable</span> ClassLoader classLoader)</span> &#123;</span><br><span class="line">   Assert.notNull(clazz, <span class="string">&quot;Class must not be null&quot;</span>);</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// [1] 获取该类的ClassLoader</span></span><br><span class="line">      <span class="type">ClassLoader</span> <span class="variable">target</span> <span class="operator">=</span> clazz.getClassLoader();</span><br><span class="line">      <span class="comment">// Common cases</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// [2] 如果目标类的ClassLoader == 提供的classLoader</span></span><br><span class="line">      <span class="comment">// [NOTICE] 双亲委派原则，只有使用同一个类加载器，加载的数据才能是只有一份，这个缓存才是是有效的</span></span><br><span class="line">      <span class="keyword">if</span> (target == classLoader || target == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (classLoader == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// [3] 递归classLoader的祖先</span></span><br><span class="line">      <span class="comment">// Check for match in ancestors -&gt; positive</span></span><br><span class="line">      <span class="type">ClassLoader</span> <span class="variable">current</span> <span class="operator">=</span> classLoader;</span><br><span class="line">      <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">         current = current.getParent();</span><br><span class="line">         <span class="keyword">if</span> (current == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// [4] 递归目标的祖先</span></span><br><span class="line">      <span class="comment">// Check for match in children -&gt; negative</span></span><br><span class="line">      <span class="keyword">while</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">         target = target.getParent();</span><br><span class="line">         <span class="keyword">if</span> (target == classLoader) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (SecurityException ex) &#123;</span><br><span class="line">      <span class="comment">// Fall through to loadable check below</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Fallback for ClassLoaders without parent/child relationship:</span></span><br><span class="line">   <span class="comment">// safe if same Class can be loaded from given ClassLoader</span></span><br><span class="line">   <span class="keyword">return</span> (classLoader != <span class="literal">null</span> &amp;&amp; isLoadable(clazz, classLoader));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这里判断cache是否安全的原理是</strong> ，根据<code>双亲委派</code> 机制，因为一个类被一个加载器加载一次在内存中就会有一份<code>Class</code> , 如果它们的加载器是一样的，那么得到的<code>Class</code> 也是一致的，这样才能确保，我们拿到的目标<code>Class</code> 数据是正确的。</p>
<p>解析完这个，我们继续上面的，如果从缓存拿不到则 <code>new</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">results = <span class="keyword">new</span> <span class="title class_">CachedIntrospectionResults</span>(beanClass);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">CachedIntrospectionResults</span><span class="params">(Class&lt;?&gt; beanClass)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(<span class="string">&quot;Getting BeanInfo for class [&quot;</span> + beanClass.getName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 关注 #getBeanInfo</span></span><br><span class="line">			<span class="built_in">this</span>.beanInfo = getBeanInfo(beanClass);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> BeanInfo <span class="title function_">getBeanInfo</span><span class="params">(Class&lt;?&gt; beanClass)</span> <span class="keyword">throws</span> IntrospectionException &#123;</span><br><span class="line">   <span class="comment">// [1] 尝试从加载的工厂中获取BeanInfo</span></span><br><span class="line">   <span class="comment">// 实际上，spring.beans 只提供一个工厂，而且那个工厂也是从线程上下文中获取</span></span><br><span class="line">   <span class="comment">// 所以一定能拿到，这是为了防止spring.beans没有提供工厂而考虑到的细节</span></span><br><span class="line">   <span class="keyword">for</span> (BeanInfoFactory beanInfoFactory : beanInfoFactories) &#123;</span><br><span class="line">      <span class="type">BeanInfo</span> <span class="variable">beanInfo</span> <span class="operator">=</span> beanInfoFactory.getBeanInfo(beanClass);</span><br><span class="line">      <span class="keyword">if</span> (beanInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> beanInfo;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// [2] 如果不提供工厂或者工厂不存在，直接在线程上下文中获取</span></span><br><span class="line">   <span class="keyword">return</span> (shouldIntrospectorIgnoreBeaninfoClasses ?</span><br><span class="line">         Introspector.getBeanInfo(beanClass, Introspector.IGNORE_ALL_BEANINFO) :</span><br><span class="line">         Introspector.getBeanInfo(beanClass));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>CachedIntrospectionResults</code> 中，它会加载一个 <code>factory</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** [DESC]  在这里加载BeanInfoFactory*/</span></span><br><span class="line"><span class="comment">// 加载 &quot;META-INF/spring.factories&quot; 中指定的工厂类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;BeanInfoFactory&gt; beanInfoFactories = SpringFactoriesLoader.loadFactories(</span><br><span class="line">      BeanInfoFactory.class, CachedIntrospectionResults.class.getClassLoader());</span><br></pre></td></tr></table></figure>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">org.springframework.beans.BeanInfoFactory</span>=<span class="string">org.springframework.beans.ExtendedBeanInfoFactory</span></span><br></pre></td></tr></table></figure>
<p>发现了，它的默认工厂类是 <code>ExtendedBeanInfoFactory</code></p>
<p>接下来继续看，如果工厂类中不存在 <code>BeanInfo</code>则会调用 <code>Introspector#getBeanInfo()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> BeanInfo <span class="title function_">getBeanInfo</span><span class="params">(Class&lt;?&gt; beanClass)</span></span><br><span class="line">        <span class="keyword">throws</span> IntrospectionException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ReflectUtil.isPackageAccessible(beanClass)) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">new</span> <span class="title class_">Introspector</span>(beanClass, <span class="literal">null</span>, USE_ALL_BEANINFO)).getBeanInfo();</span><br><span class="line">        &#125;</span><br><span class="line">  			<span class="comment">// 从线程上下文获取已经加载的 Class 信息</span></span><br><span class="line">        <span class="type">ThreadGroupContext</span> <span class="variable">context</span> <span class="operator">=</span> ThreadGroupContext.getContext();</span><br><span class="line">        BeanInfo beanInfo;</span><br><span class="line">        <span class="keyword">synchronized</span> (declaredMethodCache) &#123;</span><br><span class="line">            beanInfo = context.getBeanInfo(beanClass);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (beanInfo == <span class="literal">null</span>) &#123;</span><br><span class="line">            beanInfo = <span class="keyword">new</span> <span class="title class_">Introspector</span>(beanClass, <span class="literal">null</span>, USE_ALL_BEANINFO).getBeanInfo();</span><br><span class="line">            <span class="keyword">synchronized</span> (declaredMethodCache) &#123;</span><br><span class="line">                context.putBeanInfo(beanClass, beanInfo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanInfo;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>到此就不用追了，这里已经是jdk了，实际上是从 <code>线程上下文</code>获取的 <code>BeanInfo</code> ，这也证明了 <code>BeanFactory</code> 用的是 <code>线程上下文加载器</code></p>
<p><strong>其实上面的 默认工厂 ExtendedBeanInfoFactory</strong> 用的也是<code>上下文加载器</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtendedBeanInfoFactory</span> <span class="keyword">implements</span> <span class="title class_">BeanInfoFactory</span>, Ordered &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return an &#123;<span class="doctag">@link</span> ExtendedBeanInfo&#125; for the given bean class, if applicable.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">public</span> BeanInfo <span class="title function_">getBeanInfo</span><span class="params">(Class&lt;?&gt; beanClass)</span> <span class="keyword">throws</span> IntrospectionException &#123;</span><br><span class="line">      <span class="keyword">return</span> (supports(beanClass) ? <span class="keyword">new</span> <span class="title class_">ExtendedBeanInfo</span>(Introspector.getBeanInfo(beanClass)) : <span class="literal">null</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结下，以免跟得太深，回溯不了</strong></p>
</li>
</ul>
 <img src="/2021/08/02/spring_analysis/beans/1.bean%E7%9A%84%E5%8C%85%E8%A3%85/image-20191013012133042.png" class="">
<p>目前为止，我们也只是拿到了 <code>BeanInfo</code><br>
回到 <code>new CachedIntrospectionResults</code> 的地方，我们首先已经有了 <code>BeanInfo</code></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">CachedIntrospectionResults</span><span class="params">(Class&lt;?&gt; beanClass)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 关注 #getBeanInfo</span></span><br><span class="line">      <span class="built_in">this</span>.beanInfo = getBeanInfo(beanClass);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">this</span>.propertyDescriptorCache = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// [1] 直接获取BeanInfo的 &#123;@link PropertyDescriptor&#125;</span></span><br><span class="line">      PropertyDescriptor[] pds = <span class="built_in">this</span>.beanInfo.getPropertyDescriptors();</span><br><span class="line">      <span class="keyword">for</span> (PropertyDescriptor pd : pds) &#123;</span><br><span class="line">         <span class="comment">// [2] 某些属性是被保护的，则跳过</span></span><br><span class="line">         <span class="keyword">if</span> (Class.class == beanClass &amp;&amp;</span><br><span class="line">               (<span class="string">&quot;classLoader&quot;</span>.equals(pd.getName()) ||  <span class="string">&quot;protectionDomain&quot;</span>.equals(pd.getName()))) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// [3] 将&#123;@link PropertyDescriptor&#125; 转换为 &#123;@link GenericTypeAwarePropertyDescriptor&#125;</span></span><br><span class="line">         pd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd);</span><br><span class="line">         <span class="comment">// [4] 丢入缓存</span></span><br><span class="line">         <span class="built_in">this</span>.propertyDescriptorCache.put(pd.getName(), pd);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// [5] 还得判断这些方法是不是java8的接口的默认方法</span></span><br><span class="line">      Class&lt;?&gt; currClass = beanClass;</span><br><span class="line">      <span class="keyword">while</span> (currClass != <span class="literal">null</span> &amp;&amp; currClass != Object.class) &#123;</span><br><span class="line">         introspectInterfaces(beanClass, currClass);</span><br><span class="line">         currClass = currClass.getSuperclass();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.typeDescriptorCache = <span class="keyword">new</span> <span class="title class_">ConcurrentReferenceHashMap</span>&lt;&gt;();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接从 <code>BeanInfo</code> 拿到属性描述符，并且缓存起来，现在我们就完成了获取 <code>BeanInfo</code> 部分了，那么剩下的就是根据拿到的 <code>PropertyDescriptor</code> 去读写 <code>Property</code> :wink:</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Spring-Bean</category>
      </categories>
      <tags>
        <tag>Spring-Bean</tag>
      </tags>
  </entry>
  <entry>
    <title>2.嵌套属性解析</title>
    <url>/2021/08/02/spring_analysis/beans/2.%E5%B5%8C%E5%A5%97%E5%B1%9E%E6%80%A7%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h3 id="前言-7">前言</h3>
<p>在上面的<code>getPropertyDescriptor</code>中用到了这个方法去解析 <code>nested</code> 嵌套属性，下面就来看下它怎么实现的</p>
<p>首先我们得明确一件事情，<code>BeanWrapperImp</code> 继承自 <code>AbstractNestablePropertyAccessor</code> 因为 <code>BeanWrapperImp</code> 携带有 <code>Instance</code> ，所以 <code>AbstractNestablePropertyAccessor</code> 必然也携带有 <code>Instance</code> ，那按照我们的思路该如何解析 <code>nested</code> 属性呢，比如 有一个<code>Bean</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> name;</span><br><span class="line">  <span class="keyword">private</span> Clazz clazzInfo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Clazz</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Integer id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个我们需要取出其<code>ClazzId</code>，用<code>nested</code> 表示就是 <code>clazzInfo.id</code> ，那我们该如何解析，首先找到第一个属性</p>
<p><code>clazzInfo</code>，然后从<code>Student</code>中获取 <code>clazzInfo</code> 的<code>Instance</code> ，然后在解析第二个属性 <code>id</code> ，然后再在<code>classInfo</code> 中拿到 <code>id</code> 的值，这显然是一个递归。</p>
<p>下面来看实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> AbstractNestablePropertyAccessor <span class="title function_">getPropertyAccessorForPropertyPath</span><span class="params">(String propertyPath)</span> &#123;</span><br><span class="line">   <span class="comment">// [1] 解析出第一个属性的分割索引</span></span><br><span class="line">   <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> PropertyAccessorUtils.getFirstNestedPropertySeparatorIndex(propertyPath);</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p><strong>首先看第一步</strong>：<code>PropertyAccessorUtils.getFirstNestedPropertySeparatorIndex</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getNestedPropertySeparatorIndex</span><span class="params">(String propertyPath, <span class="type">boolean</span> last)</span> &#123;</span><br><span class="line">   <span class="comment">// [1] map[my.key] 这种就无法解析，因为它是按顺序解析的</span></span><br><span class="line">   <span class="comment">// 如果属性是一个数组 value[1].x，它就解析出 value[1]</span></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">inKey</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">   <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> propertyPath.length();</span><br><span class="line">   <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (last ? length - <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">   <span class="keyword">while</span> (last ? i &gt;= <span class="number">0</span> : i &lt; length) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (propertyPath.charAt(i)) &#123;</span><br><span class="line">          <span class="comment">// &quot;[&quot;</span></span><br><span class="line">         <span class="keyword">case</span> PropertyAccessor.PROPERTY_KEY_PREFIX_CHAR:</span><br><span class="line">          <span class="comment">// &quot;]&quot;</span></span><br><span class="line">         <span class="keyword">case</span> PropertyAccessor.PROPERTY_KEY_SUFFIX_CHAR:</span><br><span class="line">            <span class="comment">// 忽略[.] 中的 dots</span></span><br><span class="line">            inKey = !inKey;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="comment">// &quot;.&quot;</span></span><br><span class="line">         <span class="keyword">case</span> PropertyAccessor.NESTED_PROPERTY_SEPARATOR_CHAR:</span><br><span class="line">          <span class="comment">// 确保这个 &quot;.&quot; 不是在 [] 里面</span></span><br><span class="line">            <span class="keyword">if</span> (!inKey) &#123;</span><br><span class="line">               <span class="comment">// 不在[]里面的 . 说明就找到了分隔符</span></span><br><span class="line">               <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (last) &#123;</span><br><span class="line">         i--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         i++;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出<code>nested</code>不仅支持<code>普通类型</code>和<code>pojo</code> ，还支持 <code>map</code> 和 <code>list</code> 集合，但支持度最终有限，比如说这种形式它就不支持 <code>map[child.name]</code> , <code>[]</code> 中带 <code>.</code> 是不支持的。</p>
<p>从上面可以看出，其遇到 <code>.</code> 就直接返回了，所以说 当我们输入 <code>child[1].name</code> 和 <code>child.name</code> ，它返回的都是 <code>.</code>的位置，那么我们继续跟踪上面.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">protected</span> AbstractNestablePropertyAccessor <span class="title function_">getPropertyAccessorForPropertyPath</span><span class="params">(String propertyPath)</span> &#123;</span><br><span class="line">   <span class="comment">// [1] 解析出第一个属性的分割索引</span></span><br><span class="line">   <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> PropertyAccessorUtils.getFirstNestedPropertySeparatorIndex(propertyPath);</span><br><span class="line">   <span class="keyword">if</span> (pos &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// [2] 获取第一个属性名</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">nestedProperty</span> <span class="operator">=</span> propertyPath.substring(<span class="number">0</span>, pos);</span><br><span class="line">      <span class="comment">// 剩下的路径, 递归</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">nestedPath</span> <span class="operator">=</span> propertyPath.substring(pos + <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// [3] 根据属性名获取 accessor</span></span><br><span class="line">      <span class="type">AbstractNestablePropertyAccessor</span> <span class="variable">nestedPa</span> <span class="operator">=</span> getNestedPropertyAccessor(nestedProperty);</span><br><span class="line">      <span class="comment">// [4] 继续递归 nested path</span></span><br><span class="line">      <span class="keyword">return</span> nestedPa.getPropertyAccessorForPropertyPath(nestedPath);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>接着看第二步</strong>，就是根据 <code>.</code> 的位置分隔出属性的名字</p>
<ul>
<li>
<p>如果输入 <code>bean[1].name</code> 那么获取的属性名就应该是 <code>bean[1]</code>，那么剩下的路径就是<code>name</code>了;</p>
</li>
<li>
<p>如果输入 <code>bean.name</code> ，那么获取的属性名就是<code>bean</code> ，剩下的路径就是 <code>name</code></p>
</li>
</ul>
<p><strong>第三步</strong>, 拿到属性名怎么做？那不就是调用 <code>getProperty</code> 拿到<code>Instance</code>吗，在这里它封装了一下，职责进行了分离.</p>
<ul>
<li><code>AbstractNestablePropertyAccessor</code> 用于解析出 <code>属性名</code></li>
<li><code>PropertyHandler</code> 用于读写<code>属性值</code></li>
<li><code>PropertyTokenHolder</code> 对属性名进行封装，因为如果属性是集合类型 <code>bean[1]</code> 这个还是需要再解析的，所以使用一个 <code>Token</code> 来描述解析出来的<code>属性</code></li>
</ul>
<p>了解了职责分离，理解起来就简单了，我们继续第三步</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">AbstractNestablePropertyAccessor</span> <span class="variable">nestedPa</span> <span class="operator">=</span> getNestedPropertyAccessor(nestedProperty);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> AbstractNestablePropertyAccessor <span class="title function_">getNestedPropertyAccessor</span><span class="params">(String nestedProperty)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.nestedPropertyAccessors == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.nestedPropertyAccessors = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// [1] 首先生成 token</span></span><br><span class="line">   <span class="type">PropertyTokenHolder</span> <span class="variable">tokens</span> <span class="operator">=</span> getPropertyNameTokens(nestedProperty);</span><br><span class="line">   <span class="type">String</span> <span class="variable">canonicalName</span> <span class="operator">=</span> tokens.canonicalName;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// [2] 从Instance中获取值</span></span><br><span class="line">   <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> getPropertyValue(tokens);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// [3] 如果值为空，则判断是不是支持集合类型的数据，是集合类型数据就 new 一个空集合</span></span><br><span class="line">   <span class="keyword">if</span> (value == <span class="literal">null</span> || (value <span class="keyword">instanceof</span> Optional &amp;&amp; !((Optional&lt;?&gt;) value).isPresent())) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isAutoGrowNestedPaths()) &#123;</span><br><span class="line">         <span class="comment">// 这里设置一个默认值，也就是 new ArrayList 或者 HashMap</span></span><br><span class="line">         value = setDefaultValue(tokens);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 不支持集合类型那就报异常洛</span></span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullValueInNestedPathException</span>(getRootClass(), <span class="built_in">this</span>.nestedPath + canonicalName);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// [4] 将其Instance交给 AbstractNestablePropertyAccessor ，因为它是负责操作Instance的</span></span><br><span class="line">   <span class="comment">// 先尝试从缓存中找</span></span><br><span class="line">   <span class="type">AbstractNestablePropertyAccessor</span> <span class="variable">nestedPa</span> <span class="operator">=</span> <span class="built_in">this</span>.nestedPropertyAccessors.get(canonicalName);</span><br><span class="line">   <span class="keyword">if</span> (nestedPa == <span class="literal">null</span> || nestedPa.getWrappedInstance() != ObjectUtils.unwrapOptional(value)) &#123;</span><br><span class="line">      <span class="comment">// [5] 找不到则 new 一个</span></span><br><span class="line">      nestedPa = newNestedPropertyAccessor(value, <span class="built_in">this</span>.nestedPath + canonicalName + NESTED_PROPERTY_SEPARATOR);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 继承属性编辑器</span></span><br><span class="line">      copyDefaultEditorsTo(nestedPa);</span><br><span class="line">      copyCustomEditorsTo(nestedPa, canonicalName);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 别忘记丢进缓存</span></span><br><span class="line">      <span class="built_in">this</span>.nestedPropertyAccessors.put(canonicalName, nestedPa);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> nestedPa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>根据传进来的属性名创建<code>token</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> PropertyTokenHolder <span class="title function_">getPropertyNameTokens</span><span class="params">(String propertyName)</span> &#123;</span><br><span class="line">   <span class="comment">/**------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">    * [DESC] 实际用途就是用来解析集合类型的嵌套属性然后封装成token</span></span><br><span class="line"><span class="comment">    * 1. bean[1].name</span></span><br><span class="line"><span class="comment">    * 2. bean[1][2].name</span></span><br><span class="line"><span class="comment">    * 3. bean[&quot;key&quot;].x</span></span><br><span class="line"><span class="comment">    * 4. bean[&#x27;key&#x27;].y</span></span><br><span class="line"><span class="comment">    *------------------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line">   <span class="type">String</span> <span class="variable">actualName</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   List&lt;String&gt; keys = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">   <span class="type">int</span> <span class="variable">searchIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> (searchIndex != -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// [1] 先找出 [ 的位置</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">keyStart</span> <span class="operator">=</span> propertyName.indexOf(PROPERTY_KEY_PREFIX, searchIndex);</span><br><span class="line">      searchIndex = -<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (keyStart != -<span class="number">1</span>) &#123;</span><br><span class="line">         <span class="comment">// [2] 再找 ] 的位置</span></span><br><span class="line">         <span class="type">int</span> <span class="variable">keyEnd</span> <span class="operator">=</span> getPropertyNameKeyEnd(propertyName, keyStart + PROPERTY_KEY_PREFIX.length());</span><br><span class="line">         <span class="keyword">if</span> (keyEnd != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (actualName == <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="comment">// [3] 获取属性名</span></span><br><span class="line">               actualName = propertyName.substring(<span class="number">0</span>, keyStart);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// [4] 把key取出来，如果是 &quot;key&quot; 或者 &#x27;key&#x27; 那就把前缀去掉</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> propertyName.substring(keyStart + PROPERTY_KEY_PREFIX.length(), keyEnd);</span><br><span class="line">            <span class="keyword">if</span> (key.length() &gt; <span class="number">1</span> &amp;&amp; (key.startsWith(<span class="string">&quot;&#x27;&quot;</span>) &amp;&amp; key.endsWith(<span class="string">&quot;&#x27;&quot;</span>)) ||</span><br><span class="line">                  (key.startsWith(<span class="string">&quot;\&quot;&quot;</span>) &amp;&amp; key.endsWith(<span class="string">&quot;\&quot;&quot;</span>))) &#123;</span><br><span class="line">               key = key.substring(<span class="number">1</span>, key.length() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 把key丢进去</span></span><br><span class="line">            keys.add(key);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// [5] 因为支持多维数组，所以继续 ， example = bean[key][1]</span></span><br><span class="line">            searchIndex = keyEnd + PROPERTY_KEY_SUFFIX.length();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// [6] 创建token</span></span><br><span class="line">   <span class="type">PropertyTokenHolder</span> <span class="variable">tokens</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PropertyTokenHolder</span>(actualName != <span class="literal">null</span> ? actualName : propertyName);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// [7] keys不为空，</span></span><br><span class="line">   <span class="keyword">if</span> (!keys.isEmpty()) &#123;</span><br><span class="line">      <span class="comment">// 规范名称，貌似这个用不到</span></span><br><span class="line">      tokens.canonicalName += PROPERTY_KEY_PREFIX +</span><br><span class="line">            StringUtils.collectionToDelimitedString(keys, PROPERTY_KEY_SUFFIX + PROPERTY_KEY_PREFIX) +</span><br><span class="line">            PROPERTY_KEY_SUFFIX;</span><br><span class="line">      tokens.keys = StringUtils.toStringArray(keys);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> tokens;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个算法很简单，值得关注的地方是用于确定 <code>]</code>位置的方法 <code>getPropertyNameKeyEnd</code></p>
<p>因为当传入进来的 <code>nested</code> 值是 <code>map[map[key]]</code> 的时候，<code>spring不支持这种写法</code> ，我怎么知道？看下面的方法实现你就知道了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getPropertyNameKeyEnd</span><span class="params">(String propertyName, <span class="type">int</span> startIndex)</span> &#123;</span><br><span class="line">   <span class="comment">/**---------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">    * [DESC] 其作用也就是确认 ] 的位置，需要考虑的问题是</span></span><br><span class="line"><span class="comment">    * 1. beans[child[2]] 那么我们应该取最外层的 ] 的位置</span></span><br><span class="line"><span class="comment">    * 2. 因为 spring 不支持上面这种写法，它会把 child[2] 当成字符串，当成beans的key</span></span><br><span class="line"><span class="comment">    *----------------------------------------------------------------------------*/</span></span><br><span class="line">   <span class="type">int</span> <span class="variable">unclosedPrefixes</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> propertyName.length();</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; length; i++) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (propertyName.charAt(i)) &#123;</span><br><span class="line">         <span class="comment">// [1] 如果遇到了 [ 则 unclosedPrefixes++,用于判断进入了多少层的 [] </span></span><br><span class="line">         <span class="keyword">case</span> PropertyAccessor.PROPERTY_KEY_PREFIX_CHAR:</span><br><span class="line">            <span class="comment">// The property name contains opening prefix(es)...</span></span><br><span class="line">            unclosedPrefixes++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// [2] 如果遇到了 ]</span></span><br><span class="line">         <span class="keyword">case</span> PropertyAccessor.PROPERTY_KEY_SUFFIX_CHAR:</span><br><span class="line">            <span class="comment">// unclosedPrefixes == 0 说明这是最外层的 ]</span></span><br><span class="line">            <span class="keyword">if</span> (unclosedPrefixes == <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">// 最外层直接返回</span></span><br><span class="line">               <span class="comment">// No unclosed prefix(es) in the property name (left) -&gt;</span></span><br><span class="line">               <span class="comment">// this is the suffix we are looking for.</span></span><br><span class="line">               <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// 否则不是最外层的 ] ,unclosedPrefixed -- 表示退出一层，继续寻找外一层的 ]</span></span><br><span class="line">               unclosedPrefixes--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为这个方法是拿到最外层 <code>]</code> 的位置，所以，我们拿到的<code>key</code> 也只能拿最外层，所以即使你有多层<code>key</code>，它也只识别一层, 例如：<code>beans[map[key]]</code> 它只能识别出 <code>beans</code> 是一个 <code>map</code> ，而 <code>map[key]</code> 当成是一个字符串作为 <code>beans </code> 的一个 <code>key</code> 处理</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Spring-Bean</category>
      </categories>
      <tags>
        <tag>Spring-Bean</tag>
      </tags>
  </entry>
  <entry>
    <title>3.对Bean属性进行读取</title>
    <url>/2021/08/02/spring_analysis/beans/3.%E5%AF%B9bean%E5%B1%9E%E6%80%A7%E8%BF%9B%E8%A1%8C%E8%AF%BB%E5%8F%96/</url>
    <content><![CDATA[<p>###前言</p>
<ol>
<li>
<p>根据<code>token</code>获取该属性的 <code>Instance</code></p>
<p>在上面 解析中，我们已经拿到了<code>token</code> ，我们知道 <code>token</code> 里面包含了<code>属性名</code>和 <code>keys</code> ，接下来就能通过<code>属性名</code>拿到<code>属性值了</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> getPropertyValue(tokens);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getPropertyValue</span><span class="params">(PropertyTokenHolder tokens)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">   <span class="type">String</span> <span class="variable">propertyName</span> <span class="operator">=</span> tokens.canonicalName;</span><br><span class="line">   <span class="type">String</span> <span class="variable">actualName</span> <span class="operator">=</span> tokens.actualName;</span><br><span class="line">   <span class="comment">// [1] 直接获取 handler,handler用于访问属性</span></span><br><span class="line">   <span class="type">PropertyHandler</span> <span class="variable">ph</span> <span class="operator">=</span> getLocalPropertyHandler(actualName);</span><br></pre></td></tr></table></figure>
<p>上面提到过，<code>PropertyHandler</code> 是用于访问属性的，职责分离嘛，所以再拿到<code>token</code> 后，就可以获取 <code>Handler</code>了。这个方法的实现是在<code>BeanWrapperImpl#getLocalPropertyHandler</code>中实现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> BeanPropertyHandler <span class="title function_">getLocalPropertyHandler</span><span class="params">(String propertyName)</span> &#123;</span><br><span class="line">   <span class="comment">// [1] 实现很简单，直接从缓存获取属性描述符</span></span><br><span class="line">   <span class="type">PropertyDescriptor</span> <span class="variable">pd</span> <span class="operator">=</span> getCachedIntrospectionResults().getPropertyDescriptor(propertyName);</span><br><span class="line">   <span class="keyword">return</span> (pd != <span class="literal">null</span> ? <span class="keyword">new</span> <span class="title class_">BeanPropertyHandler</span>(pd) : <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>善用缓存～:happy:  ，还记得 <code>getCachedIntrospectionResults</code> 这个方法么，从<code>缓存</code>或者从<code>线程上下文类加载器</code></p>
<p>拿到 <code>BeanInfo</code>，现在我们需要到 <code>BeanInfo -&gt; PropertyDescriptor</code></p>
<p>最后我们就拿到了 <code>Handler</code>，这个<code>Handler</code>的实现类是 <code>BeanPropertyHandler</code></p>
<p>回到上面的方法，现在已经有了 <code>Handler</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getPropertyValue</span><span class="params">(PropertyTokenHolder tokens)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">   <span class="type">String</span> <span class="variable">propertyName</span> <span class="operator">=</span> tokens.canonicalName;</span><br><span class="line">   <span class="type">String</span> <span class="variable">actualName</span> <span class="operator">=</span> tokens.actualName;</span><br><span class="line">   <span class="comment">// [1] 直接获取 handler,handler用于访问属性</span></span><br><span class="line">   <span class="type">PropertyHandler</span> <span class="variable">ph</span> <span class="operator">=</span> getLocalPropertyHandler(actualName);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 属性是否存在或者不可读</span></span><br><span class="line">   <span class="keyword">if</span> (ph == <span class="literal">null</span> || !ph.isReadable()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NotReadablePropertyException</span>(getRootClass(), <span class="built_in">this</span>.nestedPath + propertyName);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// [2] 直接调用 propertyHandle#getValue 获取属性值</span></span><br><span class="line">      <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> ph.getValue();</span><br></pre></td></tr></table></figure>
<p>跟 <code>#getValue</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   <span class="comment">// [1] 从属性描述符中获取 Method</span></span><br><span class="line">   <span class="keyword">final</span> <span class="type">Method</span> <span class="variable">readMethod</span> <span class="operator">=</span> <span class="built_in">this</span>.pd.getReadMethod();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// [2] 清除方法权限，然后直接调用get方法</span></span><br><span class="line">   <span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">      AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">         ReflectionUtils.makeAccessible(readMethod);</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt;</span><br><span class="line">               readMethod.invoke(getWrappedInstance(), (Object[]) <span class="literal">null</span>), acc);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line">         <span class="keyword">throw</span> pae.getException();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      ReflectionUtils.makeAccessible(readMethod);</span><br><span class="line">      <span class="keyword">return</span> readMethod.invoke(getWrappedInstance(), (Object[]) <span class="literal">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>熟悉吧，从 <code>PropertyDescriptor</code>拿到 <code>readMethod</code>，然后反射调用一下就 👌</p>
<p>但这没有结束，因为还要处理 <code>keys</code>呢，继续追<code>getPropertyValue</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getPropertyValue</span><span class="params">(PropertyTokenHolder tokens)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">propertyName</span> <span class="operator">=</span> tokens.canonicalName;</span><br><span class="line">		<span class="type">String</span> <span class="variable">actualName</span> <span class="operator">=</span> tokens.actualName;</span><br><span class="line">		<span class="comment">// [1] 直接获取 handler,handler用于访问属性</span></span><br><span class="line">		<span class="type">PropertyHandler</span> <span class="variable">ph</span> <span class="operator">=</span> getLocalPropertyHandler(actualName);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 属性是否存在或者不可读</span></span><br><span class="line">		<span class="keyword">if</span> (ph == <span class="literal">null</span> || !ph.isReadable()) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NotReadablePropertyException</span>(getRootClass(), <span class="built_in">this</span>.nestedPath + propertyName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// [2] 直接调用 propertyHandle#getValue 获取属性值</span></span><br><span class="line">			<span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> ph.getValue();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// [3] 这里还是很熟悉，就是判断token是否存在，然后如果支持集合类型</span></span><br><span class="line">			<span class="comment">// 如果属性值为null，则new 一个集合给它</span></span><br><span class="line">			<span class="comment">// 如果不支持集合类型，那么 over~</span></span><br><span class="line">			<span class="comment">// [NOTICE] 它new出来的集合，它还是会调用 setDefaultValue 把值放进去</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// key are not-null</span></span><br><span class="line">			<span class="keyword">if</span> (tokens.keys != <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">					<span class="comment">// the AutoGrowNestedPaths enabled</span></span><br><span class="line">					<span class="keyword">if</span> (isAutoGrowNestedPaths()) &#123;</span><br><span class="line">						<span class="comment">// this value not null</span></span><br><span class="line">						value = setDefaultValue(<span class="keyword">new</span> <span class="title class_">PropertyTokenHolder</span>(tokens.actualName));</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullValueInNestedPathException</span>(getRootClass(), <span class="built_in">this</span>.nestedPath + propertyName,</span><br><span class="line">								<span class="string">&quot;Cannot access indexed value of property referenced in indexed &quot;</span> +</span><br><span class="line">										<span class="string">&quot;property path &#x27;&quot;</span> + propertyName + <span class="string">&quot;&#x27;: returned null&quot;</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="type">StringBuilder</span> <span class="variable">indexedPropertyName</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(tokens.actualName);</span><br><span class="line">				<span class="comment">// [4] 下面是重头戏，也就是处理集合类型的属性</span></span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tokens.keys.length; i++) &#123;</span><br><span class="line">					<span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> tokens.keys[i];</span><br><span class="line">					<span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullValueInNestedPathException</span>(getRootClass(), <span class="built_in">this</span>.nestedPath + propertyName,</span><br><span class="line">								<span class="string">&quot;Cannot access indexed value of property referenced in indexed &quot;</span> +</span><br><span class="line">										<span class="string">&quot;property path &#x27;&quot;</span> + propertyName + <span class="string">&quot;&#x27;: returned null&quot;</span>);</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					<span class="comment">// 类型是 Array</span></span><br><span class="line">					<span class="comment">//growArrayIfNecessary 的作用是如果你的 index 越界它会帮你扩容, 贴心吧？</span></span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span> (value.getClass().isArray()) &#123;</span><br><span class="line">						<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Integer.parseInt(key);</span><br><span class="line">						<span class="comment">// 扩容</span></span><br><span class="line">						value = growArrayIfNecessary(value, index, indexedPropertyName.toString());</span><br><span class="line">						<span class="comment">// [NOTICE]返回索引的值 可能为 null，index 越界后会填充null</span></span><br><span class="line">						<span class="comment">// 如果value是 集合类的数组，则不可能是null，会是一个新的集合</span></span><br><span class="line">						<span class="comment">// 如果是  BeanInstance[] 那就可能拿到null，如果index越界</span></span><br><span class="line">						value = Array.get(value, index);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// 类型是 List</span></span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> List) &#123;</span><br><span class="line">						<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Integer.parseInt(key);</span><br><span class="line">						List&lt;Object&gt; list = (List&lt;Object&gt;) value;</span><br><span class="line">						growCollectionIfNecessary(list, index, indexedPropertyName.toString(), ph, i + <span class="number">1</span>);</span><br><span class="line">						<span class="comment">// list 和上面是一样的</span></span><br><span class="line">						value = list.get(index);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// 类型是 Set</span></span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> Set) &#123;</span><br><span class="line">						<span class="comment">// Apply index to Iterator in case of a Set.</span></span><br><span class="line">						Set&lt;Object&gt; set = (Set&lt;Object&gt;) value;</span><br><span class="line">						<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Integer.parseInt(key);</span><br><span class="line">						<span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= set.size()) &#123;</span><br><span class="line">							<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidPropertyException</span>(getRootClass(), <span class="built_in">this</span>.nestedPath + propertyName,</span><br><span class="line">									<span class="string">&quot;Cannot get element with index &quot;</span> + index + <span class="string">&quot; from Set of size &quot;</span> +</span><br><span class="line">											set.size() + <span class="string">&quot;, accessed using property path &#x27;&quot;</span> + propertyName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">						&#125;</span><br><span class="line">						Iterator&lt;Object&gt; it = set.iterator();</span><br><span class="line">						<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; it.hasNext(); j++) &#123;</span><br><span class="line">							<span class="type">Object</span> <span class="variable">elem</span> <span class="operator">=</span> it.next();</span><br><span class="line">							<span class="keyword">if</span> (j == index) &#123;</span><br><span class="line">								value = elem;</span><br><span class="line">								<span class="keyword">break</span>;</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// 类型是 Map</span></span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">						Map&lt;Object, Object&gt; map = (Map&lt;Object, Object&gt;) value;</span><br><span class="line">						<span class="comment">// 获取key的类型</span></span><br><span class="line">						Class&lt;?&gt; mapKeyType = ph.getResolvableType().getNested(i + <span class="number">1</span>).asMap().resolveGeneric(<span class="number">0</span>);</span><br><span class="line">						<span class="comment">// IMPORTANT: Do not pass full property name in here - property editors</span></span><br><span class="line">						<span class="comment">// must not kick in for map keys but rather only for map values.</span></span><br><span class="line">						<span class="type">TypeDescriptor</span> <span class="variable">typeDescriptor</span> <span class="operator">=</span> TypeDescriptor.valueOf(mapKeyType);</span><br><span class="line">						<span class="comment">// 转换key 的类型</span></span><br><span class="line">						<span class="type">Object</span> <span class="variable">convertedMapKey</span> <span class="operator">=</span> convertIfNecessary(<span class="literal">null</span>, <span class="literal">null</span>, key, mapKeyType, typeDescriptor);</span><br><span class="line">						<span class="comment">// 直接从map中拿到数据</span></span><br><span class="line">						<span class="comment">// [NOTICE] map的情况比较特殊，它在这里不会检查，是否存在key，它不像那些自增长的集合</span></span><br><span class="line">						<span class="comment">// [NOTICE] 在外部处理 value为 null的 情况，因为数据类型可能是 map&lt;String,List[]&gt;</span></span><br><span class="line">						<span class="comment">// 因为我们不知道 下一个key是什么，因为这里不会传入所有的key，why</span></span><br><span class="line">						<span class="comment">// 当我们调用的是 setPropertyValue的时候，当我们传入的参数是 map[key][1]</span></span><br><span class="line">						<span class="comment">// 我们就得先调用 getPropertyValue（&quot;map[key]&quot;），这个时候执行完这里，外面还有一个key 那就是 1</span></span><br><span class="line">						<span class="comment">// 我们map#get后可能为 null，所以要在外部处理 map#get 为null 的情况，终于明白了 :good：</span></span><br><span class="line">						value = map.get(convertedMapKey);</span><br><span class="line">					&#125;</span><br><span class="line">indexedPropertyName.append(PROPERTY_KEY_PREFIX).append(key).append(PROPERTY_KEY_SUFFIX);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> value;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>上面可以看到，在获取属性值后，需要处理<code>keys</code>的问题，也就是要支持集合，可以看出 <code>spring</code> 支持</p>
<ul>
<li>Array</li>
<li>List</li>
<li>Set</li>
<li>Map</li>
</ul>
<p>四种集合类型</p>
<p>同时也支持集合扩容，比如 List<List> 可以自动扩容</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Spring-Bean</category>
      </categories>
      <tags>
        <tag>Spring-Bean</tag>
      </tags>
  </entry>
  <entry>
    <title>4.对Bean属性进行写入</title>
    <url>/2021/08/02/spring_analysis/beans/4.%E5%AF%B9bean%E5%B1%9E%E6%80%A7%E8%BF%9B%E8%A1%8C%E5%86%99%E5%85%A5/</url>
    <content><![CDATA[<h3 id="前言-8">前言</h3>
<p>这个和<code>getPropertyValue</code> 有很多相似的地方</p>
<ul>
<li>解析嵌套属性得到 <code>Accessor</code></li>
<li>生成 <code>token</code> 实际上也就是支持 <code>集合类型</code></li>
<li>然后调用 <code>AbstractNestablePropertyAccessor#setProperty</code></li>
</ul>
<p><code>setPropertyValue</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPropertyValue</span><span class="params">(String propertyName, <span class="meta">@Nullable</span> Object value)</span> <span class="keyword">throws</span> BeansException&#123;</span><br><span class="line">		<span class="comment">// [1] 获取嵌套属性中的最后一个Accessor</span></span><br><span class="line">		AbstractNestablePropertyAccessor nestedPa;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			nestedPa = getPropertyAccessorForPropertyPath(propertyName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (NotReadablePropertyException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NotWritablePropertyException</span>(getRootClass(), <span class="built_in">this</span>.nestedPath + propertyName,</span><br><span class="line">					<span class="string">&quot;Nested property in path &#x27;&quot;</span> + propertyName + <span class="string">&quot;&#x27; does not exist&quot;</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// [2] 生成Token</span></span><br><span class="line">		<span class="type">PropertyTokenHolder</span> <span class="variable">tokens</span> <span class="operator">=</span> getPropertyNameTokens(getFinalPath(nestedPa, propertyName));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// [3] 根据Token设置值</span></span><br><span class="line">		nestedPa.setPropertyValue(tokens, <span class="keyword">new</span> <span class="title class_">PropertyValue</span>(propertyName, value));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是不是缺少了 <code>PropertyHandler</code> ？，不用疑问，因为<code>setProperty</code>支持 通用类型转换，强得一匹, 所以类型转换后才需要到 <code>PropertyHandler</code></p>
<p>继续跟</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">setPropertyValue</span><span class="params">(PropertyTokenHolder tokens, PropertyValue pv)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">		<span class="keyword">if</span> (tokens.keys != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="comment">// [1] 处理带key 的值, 类型可以是 map,list,array</span></span><br><span class="line">			processKeyedProperty(tokens, pv);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// [2] 处理不带key的值,也就是普通类型，或者pojo</span></span><br><span class="line">			processLocalProperty(tokens, pv);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><strong>处理带key</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">xprivate <span class="keyword">void</span> <span class="title function_">processKeyedProperty</span><span class="params">(PropertyTokenHolder tokens, PropertyValue pv)</span> &#123;</span><br><span class="line">   <span class="comment">// [1] 这里获取属性值，这里是setProperty为什么要获取值？</span></span><br><span class="line">   <span class="comment">// 用于判断值的类型</span></span><br><span class="line">   <span class="type">Object</span> <span class="variable">propValue</span> <span class="operator">=</span> getPropertyHoldingValue(tokens);x</span><br></pre></td></tr></table></figure>
<p>先看第一步，调用了 <code>getPropertyHoldingValue</code> 来拿到值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Object <span class="title function_">getPropertyHoldingValue</span><span class="params">(PropertyTokenHolder tokens)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 因为我们是要 setPropertyValue</span></span><br><span class="line">		<span class="comment">// beans[1][&#x27;fafaf&#x27;]</span></span><br><span class="line">		<span class="comment">// 我们需要先拿到 beans[1]的对象，然后才能setValue</span></span><br><span class="line">		<span class="comment">// 所以这里，它只copy了 tokens.keys.length -1 个key， 最后一个不需要</span></span><br><span class="line">		Assert.state(tokens.keys != <span class="literal">null</span>, <span class="string">&quot;No token keys&quot;</span>);</span><br><span class="line">		<span class="type">PropertyTokenHolder</span> <span class="variable">getterTokens</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PropertyTokenHolder</span>(tokens.actualName);</span><br><span class="line">		getterTokens.canonicalName = tokens.canonicalName;</span><br><span class="line">		getterTokens.keys = <span class="keyword">new</span> <span class="title class_">String</span>[tokens.keys.length - <span class="number">1</span>];</span><br><span class="line">		System.arraycopy(tokens.keys, <span class="number">0</span>, getterTokens.keys, <span class="number">0</span>, tokens.keys.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		Object propValue;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// call getPropertyValue , keys must be not null</span></span><br><span class="line">			<span class="comment">// propValue maybe is null</span></span><br><span class="line">			propValue = getPropertyValue(getterTokens);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (NotReadablePropertyException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NotWritablePropertyException</span>(getRootClass(), <span class="built_in">this</span>.nestedPath + tokens.canonicalName,</span><br><span class="line">					<span class="string">&quot;Cannot access indexed value in property referenced &quot;</span> +</span><br><span class="line">					<span class="string">&quot;in indexed property path &#x27;&quot;</span> + tokens.canonicalName + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果value为null，则这个lastkey对应的属性必然是 map，可以看 getPropertyValue 的代码，里面有解析</span></span><br><span class="line">		<span class="keyword">if</span> (propValue == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="comment">// map case</span></span><br><span class="line">			<span class="comment">// map[key][1]</span></span><br><span class="line">			<span class="keyword">if</span> (isAutoGrowNestedPaths()) &#123;</span><br><span class="line">				<span class="comment">// 这个时候给 map 这个属性设置默认值，</span></span><br><span class="line">				<span class="type">int</span> <span class="variable">lastKeyIndex</span> <span class="operator">=</span> tokens.canonicalName.lastIndexOf(<span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">				getterTokens.canonicalName = tokens.canonicalName.substring(<span class="number">0</span>, lastKeyIndex);</span><br><span class="line">				propValue = setDefaultValue(getterTokens);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullValueInNestedPathException</span>(getRootClass(), <span class="built_in">this</span>.nestedPath + tokens.canonicalName,</span><br><span class="line">						<span class="string">&quot;Cannot access indexed value in property referenced &quot;</span> +</span><br><span class="line">						<span class="string">&quot;in indexed property path &#x27;&quot;</span> + tokens.canonicalName + <span class="string">&quot;&#x27;: returned null&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> propValue;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>拿到值后，我们继续</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processKeyedProperty</span><span class="params">(PropertyTokenHolder tokens, PropertyValue pv)</span> &#123;</span><br><span class="line">		<span class="comment">// [1] 这里获取属性值，这里是setProperty为什么要获取值？</span></span><br><span class="line">		<span class="comment">// 用于判断值的类型</span></span><br><span class="line">		<span class="type">Object</span> <span class="variable">propValue</span> <span class="operator">=</span> getPropertyHoldingValue(tokens);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 在这里拿到Handler</span></span><br><span class="line">		<span class="type">PropertyHandler</span> <span class="variable">ph</span> <span class="operator">=</span> getLocalPropertyHandler(tokens.actualName);</span><br><span class="line">		<span class="keyword">if</span> (ph == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidPropertyException</span>(</span><br><span class="line">					getRootClass(), <span class="built_in">this</span>.nestedPath + tokens.actualName, <span class="string">&quot;No property handler found&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		Assert.state(tokens.keys != <span class="literal">null</span>, <span class="string">&quot;No token keys&quot;</span>);</span><br><span class="line">		<span class="comment">// [TODO] 如果属性的值是 list类型就代表索引，map类型就是key</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">lastKey</span> <span class="operator">=</span> tokens.keys[tokens.keys.length - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * [2] 根据属性值的类型进行转换然后设置值</span></span><br><span class="line"><span class="comment">		 * 通过调用 &#123;<span class="doctag">@link</span> #convertIfNecessary(String, Object, Object, Class, TypeDescriptor)&#125; 来进行类型转换</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (propValue.getClass().isArray()) &#123;</span><br><span class="line">			Class&lt;?&gt; requiredType = propValue.getClass().getComponentType();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// [DESC] 属性类型为数组，则key代表索引</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">arrayIndex</span> <span class="operator">=</span> Integer.parseInt(lastKey);</span><br><span class="line">			<span class="type">Object</span> <span class="variable">oldValue</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (isExtractOldValueForEditor() &amp;&amp; arrayIndex &lt; Array.getLength(propValue)) &#123;</span><br><span class="line">					oldValue = Array.get(propValue, arrayIndex);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 进行类型转换</span></span><br><span class="line">				<span class="type">Object</span> <span class="variable">convertedValue</span> <span class="operator">=</span> convertIfNecessary(tokens.canonicalName, oldValue, pv.getValue(),</span><br><span class="line">						requiredType, ph.nested(tokens.keys.length));</span><br><span class="line">				<span class="comment">// 获取当前属性数组长度,判断是否越界</span></span><br><span class="line">				<span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> Array.getLength(propValue);</span><br><span class="line">				<span class="keyword">if</span> (arrayIndex &gt;= length &amp;&amp; arrayIndex &lt; <span class="built_in">this</span>.autoGrowCollectionLimit) &#123;</span><br><span class="line">					<span class="comment">// 如果当前属性长度不足，则new一个，然后copy</span></span><br><span class="line">					Class&lt;?&gt; componentType = propValue.getClass().getComponentType();</span><br><span class="line">					<span class="type">Object</span> <span class="variable">newArray</span> <span class="operator">=</span> Array.newInstance(componentType, arrayIndex + <span class="number">1</span>);</span><br><span class="line">					System.arraycopy(propValue, <span class="number">0</span>, newArray, <span class="number">0</span>, length);</span><br><span class="line"></span><br><span class="line">					<span class="comment">// 然后设置属性值</span></span><br><span class="line">					setPropertyValue(tokens.actualName, newArray);</span><br><span class="line">					propValue = getPropertyValue(tokens.actualName);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 最后才将数据丢进数组</span></span><br><span class="line">				Array.set(propValue, arrayIndex, convertedValue);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidPropertyException</span>(getRootClass(), <span class="built_in">this</span>.nestedPath + tokens.canonicalName,</span><br><span class="line">						<span class="string">&quot;Invalid array index in property path &#x27;&quot;</span> + tokens.canonicalName + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (propValue <span class="keyword">instanceof</span> List) &#123;</span><br><span class="line">			Class&lt;?&gt; requiredType = ph.getCollectionType(tokens.keys.length);</span><br><span class="line">			List&lt;Object&gt; list = (List&lt;Object&gt;) propValue;</span><br><span class="line">			<span class="comment">// [DESC] 属性类型为list，则key代表索引</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Integer.parseInt(lastKey);</span><br><span class="line">			<span class="type">Object</span> <span class="variable">oldValue</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">			<span class="keyword">if</span> (isExtractOldValueForEditor() &amp;&amp; index &lt; list.size()) &#123;</span><br><span class="line">				oldValue = list.get(index);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 数据转换</span></span><br><span class="line">			<span class="type">Object</span> <span class="variable">convertedValue</span> <span class="operator">=</span> convertIfNecessary(tokens.canonicalName, oldValue, pv.getValue(),</span><br><span class="line">					requiredType, ph.nested(tokens.keys.length));</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 判断下表是否越界</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.size();</span><br><span class="line">			<span class="keyword">if</span> (index &gt;= size &amp;&amp; index &lt; <span class="built_in">this</span>.autoGrowCollectionLimit) &#123;</span><br><span class="line">				<span class="comment">// 比如当前属性list有5个元素，若要插入位置为8，则其余的填充为 null</span></span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size; i &lt; index; i++) &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						list.add(<span class="literal">null</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">catch</span> (NullPointerException ex) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidPropertyException</span>(getRootClass(), <span class="built_in">this</span>.nestedPath + tokens.canonicalName,</span><br><span class="line">								<span class="string">&quot;Cannot set element with index &quot;</span> + index + <span class="string">&quot; in List of size &quot;</span> +</span><br><span class="line">								size + <span class="string">&quot;, accessed using property path &#x27;&quot;</span> + tokens.canonicalName +</span><br><span class="line">								<span class="string">&quot;&#x27;: List does not support filling up gaps with null elements&quot;</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 添加进list</span></span><br><span class="line">				list.add(convertedValue);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="comment">// 添加进list</span></span><br><span class="line">					list.set(index, convertedValue);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidPropertyException</span>(getRootClass(), <span class="built_in">this</span>.nestedPath + tokens.canonicalName,</span><br><span class="line">							<span class="string">&quot;Invalid list index in property path &#x27;&quot;</span> + tokens.canonicalName + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (propValue <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">			<span class="comment">// [DESC] 属性类型为map则 key就为 map的key</span></span><br><span class="line">			Class&lt;?&gt; mapKeyType = ph.getMapKeyType(tokens.keys.length);</span><br><span class="line">			Class&lt;?&gt; mapValueType = ph.getMapValueType(tokens.keys.length);</span><br><span class="line">			Map&lt;Object, Object&gt; map = (Map&lt;Object, Object&gt;) propValue;</span><br><span class="line">			<span class="comment">// IMPORTANT: Do not pass full property name in here - property editors</span></span><br><span class="line">			<span class="comment">// must not kick in for map keys but rather only for map values.</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// [DESC] key的类型也需要转换一下</span></span><br><span class="line">			<span class="type">TypeDescriptor</span> <span class="variable">typeDescriptor</span> <span class="operator">=</span> TypeDescriptor.valueOf(mapKeyType);</span><br><span class="line">			<span class="type">Object</span> <span class="variable">convertedMapKey</span> <span class="operator">=</span> convertIfNecessary(<span class="literal">null</span>, <span class="literal">null</span>, lastKey, mapKeyType, typeDescriptor);</span><br><span class="line">			<span class="type">Object</span> <span class="variable">oldValue</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 然后根据key获取map中的值</span></span><br><span class="line">			<span class="keyword">if</span> (isExtractOldValueForEditor()) &#123;</span><br><span class="line">				oldValue = map.get(convertedMapKey);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Pass full property name and old value in here, since we want full</span></span><br><span class="line">			<span class="comment">// conversion ability for map values.</span></span><br><span class="line">			<span class="comment">// 再将数据转换为map[key]对象对应的类型</span></span><br><span class="line">			<span class="type">Object</span> <span class="variable">convertedMapValue</span> <span class="operator">=</span> convertIfNecessary(tokens.canonicalName, oldValue, pv.getValue(),</span><br><span class="line">					mapValueType, ph.nested(tokens.keys.length));</span><br><span class="line">			<span class="comment">// 最后设置map的值</span></span><br><span class="line">			map.put(convertedMapKey, convertedMapValue);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidPropertyException</span>(getRootClass(), <span class="built_in">this</span>.nestedPath + tokens.canonicalName,</span><br><span class="line">					<span class="string">&quot;Property referenced in indexed property path &#x27;&quot;</span> + tokens.canonicalName +</span><br><span class="line">					<span class="string">&quot;&#x27; is neither an array nor a List nor a Map; returned value was [&quot;</span> + propValue + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>处理带key的部分确实很复杂，因为要考虑很多种类型，<code>list</code> 、<code>array</code> 、<code>map</code> ，如果属性为空还得扩容，设置属性值的时候还要支持类型转换，下面来看 处理不带key 的部分</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processLocalProperty</span><span class="params">(PropertyTokenHolder tokens, PropertyValue pv)</span> &#123;</span><br><span class="line">		<span class="comment">// [1] 先获取handler</span></span><br><span class="line">		<span class="type">PropertyHandler</span> <span class="variable">ph</span> <span class="operator">=</span> getLocalPropertyHandler(tokens.actualName);</span><br><span class="line">		<span class="keyword">if</span> (ph == <span class="literal">null</span> || !ph.isWritable()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (pv.isOptional()) &#123;</span><br><span class="line">				<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">					logger.debug(<span class="string">&quot;Ignoring optional value for property &#x27;&quot;</span> + tokens.actualName +</span><br><span class="line">							<span class="string">&quot;&#x27; - property not found on bean class [&quot;</span> + getRootClass().getName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">throw</span> createNotWritablePropertyException(tokens.canonicalName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// [2] 直接转换类型</span></span><br><span class="line">		<span class="type">Object</span> <span class="variable">oldValue</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="type">Object</span> <span class="variable">originalValue</span> <span class="operator">=</span> pv.getValue();</span><br><span class="line">			<span class="type">Object</span> <span class="variable">valueToApply</span> <span class="operator">=</span> originalValue;</span><br><span class="line">			<span class="keyword">if</span> (!Boolean.FALSE.equals(pv.conversionNecessary)) &#123;</span><br><span class="line">				<span class="comment">// 尝试从缓存中拿到转换的值</span></span><br><span class="line">				<span class="keyword">if</span> (pv.isConverted()) &#123;</span><br><span class="line">					valueToApply = pv.getConvertedValue();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> (isExtractOldValueForEditor() &amp;&amp; ph.isReadable()) &#123;</span><br><span class="line">						<span class="comment">// 调用 get方法拿到属性值</span></span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							oldValue = ph.getValue();</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">							<span class="keyword">if</span> (ex <span class="keyword">instanceof</span> PrivilegedActionException) &#123;</span><br><span class="line">								ex = ((PrivilegedActionException) ex).getException();</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">								logger.debug(<span class="string">&quot;Could not read previous value of property &#x27;&quot;</span> +</span><br><span class="line">										<span class="built_in">this</span>.nestedPath + tokens.canonicalName + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// 类型转换</span></span><br><span class="line">					valueToApply = convertForProperty(</span><br><span class="line">							tokens.canonicalName, oldValue, originalValue, ph.toTypeDescriptor());</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 设置 flag，确认是否需要转换，如果是同类型的下次就不用转换了</span></span><br><span class="line">				pv.getOriginalPropertyValue().conversionNecessary = (valueToApply != originalValue);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 调用 set方法设置属性值 </span></span><br><span class="line">			ph.setValue(valueToApply);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">			<span class="type">PropertyChangeEvent</span> <span class="variable">propertyChangeEvent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PropertyChangeEvent</span>(</span><br><span class="line">					getRootInstance(), <span class="built_in">this</span>.nestedPath + tokens.canonicalName, oldValue, pv.getValue());</span><br><span class="line">			<span class="keyword">if</span> (ex.getTargetException() <span class="keyword">instanceof</span> ClassCastException) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeMismatchException</span>(propertyChangeEvent, ph.getPropertyType(), ex.getTargetException());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="type">Throwable</span> <span class="variable">cause</span> <span class="operator">=</span> ex.getTargetException();</span><br><span class="line">				<span class="keyword">if</span> (cause <span class="keyword">instanceof</span> UndeclaredThrowableException) &#123;</span><br><span class="line">					<span class="comment">// May happen e.g. with Groovy-generated methods</span></span><br><span class="line">					cause = cause.getCause();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MethodInvocationException</span>(propertyChangeEvent, cause);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">			<span class="type">PropertyChangeEvent</span> <span class="variable">pce</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PropertyChangeEvent</span>(</span><br><span class="line">					getRootInstance(), <span class="built_in">this</span>.nestedPath + tokens.canonicalName, oldValue, pv.getValue());</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MethodInvocationException</span>(pce, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>处理不带key的很简单，就转换一下数据类型，然后调用 <code>set </code>方法设置属性值就👌，类型转换会单独跳出来分析，因为这些东西都比较复杂.</p>
]]></content>
      <categories>
        <category>Spring-Bean</category>
      </categories>
      <tags>
        <tag>Spring-Bean</tag>
      </tags>
  </entry>
  <entry>
    <title>5.Bean类型转换</title>
    <url>/2021/08/02/spring_analysis/beans/5.%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h3 id="前言-9">前言</h3>
<p>类型转换在<code>spring</code>中很常用，比如说<code>spring beans</code> 就我们之前研究的<code>setter/getter</code>属性，还有<code>spring mvc</code> 的参数绑定，或者说是 <code>i o c</code>自动装配，都用到了类型转换。下面我们就单独研究它.</p>
<p>实际上它调用的是 <code>org.springframework.core.convert</code> 中的 <code>DefaultConversionService</code></p>
<p>就不在这里讨论，单独讨论</p>
]]></content>
      <categories>
        <category>Spring-Bean</category>
      </categories>
      <tags>
        <tag>Spring-Bean</tag>
      </tags>
  </entry>
  <entry>
    <title>6.创建BeanInstance-概览</title>
    <url>/2021/08/02/spring_analysis/beans/6.%E5%88%9B%E5%BB%BABeanInstance-%E6%A6%82%E8%A7%88/</url>
    <content><![CDATA[<h3 id="前言-10">前言</h3>
<p><code>spring</code> 对 <code>bean</code> 的操作可以分为以下三个步骤：</p>
<ul>
<li>创建 Instance</li>
<li>填充 Instance</li>
<li>初始化 Bean</li>
</ul>
<p>所以在这里先从最基本的开始，创建 <code>Instance</code></p>
<p>首先 <code>bean</code> 的类型可以分为两种，仅讨论 <code>beans 包下 的 BeanFactory</code> ：</p>
<ul>
<li>singleton</li>
<li>prototype</li>
</ul>
<p>先讨论 <code>doGetBean</code> 也就是 梦开始的地方</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, <span class="meta">@Nullable</span> <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span><br><span class="line"><span class="params">			<span class="meta">@Nullable</span> <span class="keyword">final</span> Object[] args, <span class="type">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**-------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">		 * 调用者：&#123;<span class="doctag">@link</span> #getBean(String)&#125; ...</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * [DESC] 获取指定的Bean</span></span><br><span class="line"><span class="comment">		 * [1] 先从Singleton缓存中查找，若不存在遍历其父工厂递归getBean</span></span><br><span class="line"><span class="comment">		 * [2] 调用&#123;<span class="doctag">@link</span> AbstractAutowireCapableBeanFactory#createBean(String, RootBeanDefinition, Object[])&#125; 创建实例</span></span><br><span class="line"><span class="comment">		 *-------------------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取真实的bean名字，类似 &amp;BeanName 就会被解析为 BeanName就是去掉 &amp; 这个符号</span></span><br><span class="line">		<span class="comment">// 然后从别名中获取真实名字</span></span><br><span class="line">		<span class="comment">// [TODO] 这里去掉了 &amp; 并不影响后面处理 FactoryBean，FactoryBean是需要根据 &amp; 这个字符来判断的，在这里去掉并不影响</span></span><br><span class="line">		<span class="keyword">final</span> <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> transformedBeanName(name);</span><br><span class="line">		Object bean;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// [1] 优先从单例缓存中查找</span></span><br><span class="line">		<span class="type">Object</span> <span class="variable">sharedInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line">		<span class="keyword">if</span> (sharedInstance != <span class="literal">null</span> &amp;&amp; args == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">				<span class="comment">// 判断bean是否正在创建</span></span><br><span class="line">				<span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">					logger.trace(<span class="string">&quot;Returning eagerly cached instance of singleton bean &#x27;&quot;</span> + beanName +</span><br><span class="line">							<span class="string">&quot;&#x27; that is not fully initialized yet - a consequence of a circular reference&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					logger.trace(<span class="string">&quot;Returning cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// [NOTE] 这里之所以要从BeanInstance中获取Object，是因为Bean可能是FactoryBean利用工厂生产出Object</span></span><br><span class="line">			bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="literal">null</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 若当前名字的bean已经创建了，则肯定失败</span></span><br><span class="line">			<span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// [2] 判断其是否已经存在于现在这个工厂</span></span><br><span class="line">			<span class="type">BeanFactory</span> <span class="variable">parentBeanFactory</span> <span class="operator">=</span> getParentBeanFactory();</span><br><span class="line">			<span class="keyword">if</span> (parentBeanFactory != <span class="literal">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">				<span class="comment">// 不存在则，继续从父工厂获取</span></span><br><span class="line">				<span class="comment">// 我就说这是一个链表</span></span><br><span class="line">				<span class="comment">// [NOTE] 因为每一个Factory 都有一个 Parent对象，所以这就构成了一个单向链表</span></span><br><span class="line">				<span class="comment">// [NOTE] 所以下面就用递归就完事了</span></span><br><span class="line">				<span class="type">String</span> <span class="variable">nameToLookup</span> <span class="operator">=</span> originalBeanName(name);</span><br><span class="line">				<span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line">					<span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">							nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="literal">null</span>) &#123;</span><br><span class="line">					<span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line">					<span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (requiredType != <span class="literal">null</span>) &#123;</span><br><span class="line">					<span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line">					<span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 标记Bean已经被创建或者准备被创建</span></span><br><span class="line">			<span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">				markBeanAsCreated(beanName);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">// [3] 拿到合并后的BeanDefinition</span></span><br><span class="line">				<span class="keyword">final</span> <span class="type">RootBeanDefinition</span> <span class="variable">mbd</span> <span class="operator">=</span> getMergedLocalBeanDefinition(beanName);</span><br><span class="line">				<span class="comment">// 检查Bean是不是Abstract</span></span><br><span class="line">				checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// [4] 直接把根结点的依赖bean拷贝过来</span></span><br><span class="line">				<span class="comment">// [NOTE] 使用 depends-on标签可以使，执行的depends bean可以在 此bean创建之前创建</span></span><br><span class="line">				String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">				<span class="keyword">if</span> (dependsOn != <span class="literal">null</span>) &#123;</span><br><span class="line">					<span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">						<span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">							<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">									<span class="string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">						&#125;</span><br><span class="line">						registerDependentBean(dep, beanName);</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							<span class="comment">// NOTE 如果此bean存在 depends ，则先实例这些depends bean</span></span><br><span class="line">							getBean(dep);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">							<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">									<span class="string">&quot;&#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; depends on missing bean &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// [5] 创建bean实例</span></span><br><span class="line">				<span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">					sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							<span class="comment">// [6] 创建Bean</span></span><br><span class="line">							<span class="comment">/** &#123;<span class="doctag">@link</span> AbstractAutowireCapableBeanFactory#createBean(String, RootBeanDefinition, Object[])&#125;*/</span></span><br><span class="line">							<span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;);</span><br><span class="line"></span><br><span class="line">					<span class="comment">// 在这里判断是不是FactoryBean 如果是则调用其 getObject 方法</span></span><br><span class="line">					bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// [6] 判断是否为原型</span></span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">					<span class="comment">// 如果为原型则需要创建Instance</span></span><br><span class="line">					<span class="type">Object</span> <span class="variable">prototypeInstance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						beforePrototypeCreation(beanName);</span><br><span class="line">						prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">finally</span> &#123;</span><br><span class="line">						afterPrototypeCreation(beanName);</span><br><span class="line">					&#125;</span><br><span class="line">					bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">				&#125;</span><br><span class="line">		<span class="keyword">return</span> (T) bean;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>还是熟悉的感觉，在这个开头你看到的只能是一堆的检查和初始化工作，真正的创建 <code>Instance</code> 在后面，</p>
<ul>
<li>单例对象和原型对象就差了一个缓存，o f course 这没什么奇怪的</li>
<li>可以细看一下 <code>BeanFactory</code> 的设计，它就是一个单链表 <code>parent</code> 因为它有这个字段</li>
<li>然后 处理 depends-on 标签，也就是将这个标签内的 bean 先创建出来</li>
<li>然后调用 <code>createBean</code>进行真正的创建 bean</li>
<li>最后调用 <code>getObjectForBeanInstance</code> 处理 <code>FactoryBean</code> 的情况</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">			<span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line">		<span class="comment">/**-------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">		 * 调用者：&#123;<span class="doctag">@link</span> AbstractBeanFactory#doGetBean(String, Class, Object[], boolean)&#125;</span></span><br><span class="line"><span class="comment">		 * [DESC] 负责创建一个完整的Bean</span></span><br><span class="line"><span class="comment">		 * [1] 判断Bean是不是需要重写方法，若需要则校验</span></span><br><span class="line"><span class="comment">		 * [2] 实际调用 &#123;<span class="doctag">@link</span> #doCreateBean(String, RootBeanDefinition, Object[])&#125; 创建Bean</span></span><br><span class="line"><span class="comment">		 *-------------------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">&quot;Creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">RootBeanDefinition</span> <span class="variable">mbdToUse</span> <span class="operator">=</span> mbd;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Make sure bean class is actually resolved at this point, and</span></span><br><span class="line">		<span class="comment">// clone the bean definition in case of a dynamically resolved Class</span></span><br><span class="line">		<span class="comment">// which cannot be stored in the shared merged bean definition.</span></span><br><span class="line">		Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">		<span class="keyword">if</span> (resolvedClass != <span class="literal">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="literal">null</span>) &#123;</span><br><span class="line">			mbdToUse = <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(mbd);</span><br><span class="line">			mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Prepare method overrides.</span></span><br><span class="line">		<span class="comment">// [1] 如果Bean需要重写方法,则进行预处理 校验</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			mbdToUse.prepareMethodOverrides();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(mbdToUse.getResourceDescription(),</span><br><span class="line">					beanName, <span class="string">&quot;Validation of method overrides failed&quot;</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span></span><br><span class="line">			<span class="comment">//</span></span><br><span class="line">			<span class="comment">// NOTE 在这里调用 InstantiationAwareBeanPostProcessor 处理器</span></span><br><span class="line">			<span class="comment">// NOTE 此时bean还没被创建</span></span><br><span class="line">			<span class="comment">// InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation</span></span><br><span class="line">			<span class="comment">// BeanPostProcessor#postProcessAfterInitialization</span></span><br><span class="line">			<span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">			<span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> bean;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">					<span class="string">&quot;BeanPostProcessor before instantiation of bean failed&quot;</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// [3] 真正的创建Bean</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="type">Object</span> <span class="variable">beanInstance</span> <span class="operator">=</span> doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">			<span class="keyword">return</span> beanInstance;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>合并 <code>BeanDefinition</code> 那部分不用管，总结下</p>
<ul>
<li>
<p>处理 <code>Merge Definition</code></p>
</li>
<li>
<p><code>resolveBeforeInstantiation</code></p>
<blockquote>
<p>这里它会调用 <code>InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation</code> 处理器</p>
<p>如果此处理返回了 <code>Instance</code> 则会调用 <code>BeanPostProcessor#postProcessAfterInitialization</code> 处理器</p>
<p>注意：这里可能是 <code>AOP</code> 代理的地方，暂时没确定，因为这不属于 <code>BeanFactory</code> 的范围</p>
</blockquote>
</li>
<li>
<p>doCreateBean 创建 Instance</p>
</li>
</ul>
<p>继续深入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">			<span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">		 * [DESC] 负责创建Bean</span></span><br><span class="line"><span class="comment">		 * [1] 如果是singleton对象，现在缓存中移除</span></span><br><span class="line"><span class="comment">		 * [2] 如果之前没有创建过singleton，则调用 &#123;<span class="doctag">@link</span> #createBeanInstance&#125; 创建</span></span><br><span class="line"><span class="comment">		 * [3] 将单例添加到factory中，预先暴露bean，这可以支持spring去解决 singleton循环依赖问题</span></span><br><span class="line"><span class="comment">		 * [4] 调用 &#123;<span class="doctag">@link</span> #populateBean&#125; 填充依赖属性</span></span><br><span class="line"><span class="comment">		 * [5] 调用 &#123;<span class="doctag">@link</span> #initializeBean&#125; 初始化bean</span></span><br><span class="line"><span class="comment">		 * [6] 如果Bean定义了Dependent-on 那就修复 依赖</span></span><br><span class="line"><span class="comment">		 *------------------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 创建出来的实例是需要包装起来，然后才能修复依赖</span></span><br><span class="line">		<span class="type">BeanWrapper</span> <span class="variable">instanceWrapper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Note [1] 单例对象需要从缓存中移除</span></span><br><span class="line">		<span class="comment">// 如果之前没有创建过，那接下来就创建实例</span></span><br><span class="line">		<span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">			instanceWrapper = <span class="built_in">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (instanceWrapper == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="comment">// Note step in 创建实例</span></span><br><span class="line">			instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>继续跟</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> BeanWrapper <span class="title function_">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span> &#123;</span><br><span class="line">		<span class="comment">/**------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">		 * [DESC] 创建bean 实例</span></span><br><span class="line"><span class="comment">		 * [1] 判断类是不是 public</span></span><br><span class="line"><span class="comment">		 * [2] 判断是否提供了工厂方法，若有，则调用 &#123;<span class="doctag">@link</span> #instantiateUsingFactoryMethod&#125;</span></span><br><span class="line"><span class="comment">		 * [3] 判断是否提供了构造函数，若有，则调用 &#123;<span class="doctag">@link</span> #autowireConstructor&#125;</span></span><br><span class="line"><span class="comment">		 * [4] 两者都不提供，则直接调用默认构造函数 &#123;<span class="doctag">@link</span> #instantiateBean&#125;</span></span><br><span class="line"><span class="comment">		 *------------------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 确保class已经被解析</span></span><br><span class="line">		Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">		<span class="comment">// 判断Class是不是公开的，有没有访问权限</span></span><br><span class="line">		<span class="keyword">if</span> (beanClass != <span class="literal">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">					<span class="string">&quot;Bean class isn&#x27;t public, and non-public access not allowed: &quot;</span> + beanClass.getName());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取 Instance 提供者</span></span><br><span class="line">		Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();</span><br><span class="line">		<span class="keyword">if</span> (instanceSupplier != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 若存在Instance提供者，就直接调用提供者方法然后得到Instance</span></span><br><span class="line">			<span class="comment">// [TODO] 我还不知道能不能把一个工厂Bean 当作提供者,但在下面是可以指名这个Bean是一个FactoryBean然后调用工厂方法</span></span><br><span class="line">			<span class="keyword">return</span> obtainFromSupplier(instanceSupplier, beanName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// [DESC] 若提供了工厂方法，则调用工厂方法拿到Instance</span></span><br><span class="line">		<span class="comment">// factory-method=&quot;getXXX&quot;</span></span><br><span class="line">		<span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 调用工厂方法实例化对象</span></span><br><span class="line">			<span class="keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Shortcut when re-creating the same bean...</span></span><br><span class="line">		<span class="type">boolean</span> <span class="variable">resolved</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="comment">// 是否需要自动装配</span></span><br><span class="line">		<span class="type">boolean</span> <span class="variable">autowireNecessary</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (args == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">				<span class="comment">// 若存在构造函数解析器或者存在工厂方法存在</span></span><br><span class="line">				<span class="comment">// 则说明其可以提供了可以解析构造函数的处理器</span></span><br><span class="line">				<span class="keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="literal">null</span>) &#123;</span><br><span class="line">					resolved = <span class="literal">true</span>;</span><br><span class="line">					<span class="comment">// 提供构造函数解析</span></span><br><span class="line">					autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (resolved) &#123;</span><br><span class="line">			<span class="keyword">if</span> (autowireNecessary) &#123;</span><br><span class="line">				<span class="comment">// 如果提供了参数解析器，则自动装配</span></span><br><span class="line">				<span class="keyword">return</span> autowireConstructor(beanName, mbd, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// 不需要自动装配切提供了参数解析器，则直接调用无参的构造函数</span></span><br><span class="line">				<span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 构造函数自动装配 ？</span></span><br><span class="line">		<span class="comment">// 指定构造函数来自于BeanPost处理器?</span></span><br><span class="line">		<span class="comment">// SmartInstantiationAwareBeanPostProcessor#determineCandidateConstructors</span></span><br><span class="line">		Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line">		<span class="keyword">if</span> (ctors != <span class="literal">null</span> || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">				mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) &#123;</span><br><span class="line">			<span class="comment">// 自动装配</span></span><br><span class="line">			<span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Preferred constructors for default construction?</span></span><br><span class="line">		<span class="comment">// 获取首选的默认构造函数 ？</span></span><br><span class="line">		ctors = mbd.getPreferredConstructors();</span><br><span class="line">		<span class="keyword">if</span> (ctors != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 自动装配</span></span><br><span class="line">			<span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, <span class="literal">null</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 没有指定构造函数，则用无参方式 实例化对象</span></span><br><span class="line">		<span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>策略一 : 使用 <code>instantiateUsingFactoryMethod</code> 调用其<code>factory-method</code> 或者 <code>factory-bean</code>创建 <code>Instance</code></li>
<li>策略二：使用 <code>autowireConstructor</code> 利用 <code>Bean</code> 的构造函数创建 <code>Instance</code></li>
<li>策略三：使用 <code>instantiateBean</code> 利用 <code>Bean</code>的默认构造函数创建 <code>Instance</code></li>
</ul>
<p>第一种已经在 <code>functionality</code>文件夹中单独抽出来了，只讨论 下面两种策略，会另起一个小节</p>
]]></content>
      <categories>
        <category>Spring-Bean</category>
      </categories>
      <tags>
        <tag>Spring-Bean</tag>
      </tags>
  </entry>
  <entry>
    <title>8.创建BeanInstance-根据无参构造函数</title>
    <url>/2021/08/02/spring_analysis/beans/8.%E5%88%9B%E5%BB%BABeanInstance-%E6%A0%B9%E6%8D%AE%E6%97%A0%E5%8F%82%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h3 id="前言-11">前言</h3>
<p>利用无参数构造函数创建<code>Bean</code> 的<code>Instance</code> ，这个方式比较简单。来简单看一下, 其实在上一章节已经接触过了。。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> BeanWrapper <span class="title function_">instantiateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd)</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Object beanInstance;</span><br><span class="line">			<span class="keyword">final</span> <span class="type">BeanFactory</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">			<span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">				beanInstance = AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt;</span><br><span class="line">						getInstantiationStrategy().instantiate(mbd, beanName, parent),</span><br><span class="line">						getAccessControlContext());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">BeanWrapper</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanWrapperImpl</span>(beanInstance);</span><br><span class="line">			initBeanWrapper(bw);</span><br><span class="line">			<span class="keyword">return</span> bw;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">					mbd.getResourceDescription(), beanName, <span class="string">&quot;Instantiation of bean failed&quot;</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>这个 <code>getInstantiationStrategy()</code> 初始化策略可以用<code>CGI</code>动态代理策略代替，在这里不深入。</p>
<p>创建 <code>Instance</code> 就告一断落。</p>
]]></content>
      <categories>
        <category>Spring-Bean</category>
      </categories>
      <tags>
        <tag>Spring-Bean</tag>
      </tags>
  </entry>
  <entry>
    <title>1.Spring类型转换器服务</title>
    <url>/2021/08/02/spring_analysis/core/1.%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<h3 id="前言-12">前言</h3>
<p><code>sping</code>对整个<code>类型转换组件</code>抽象成为<code>service</code> , 毕竟类型转换这些没什么神秘之处，我们只需要了解它的设计模式。老规矩，从<code>test</code>开始 <code>package org.springframework.core.convert.converter#DefaultConversionServiceTests.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DefaultConversionServiceTests</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">DefaultConversionService</span> <span class="variable">conversionService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConversionService</span>();</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">stringToCharacter</span><span class="params">()</span> &#123;</span><br><span class="line">		assertThat(conversionService.convert(<span class="string">&quot;1&quot;</span>, Character.class)).isEqualTo(Character.valueOf(<span class="string">&#x27;1&#x27;</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>GenericConversionService</p>
<p>因为<code>DefaultConversionService</code>是继承自<code>GenericConversionService</code>，并且后者才是真正的核心，所以只需要看后者即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">convert</span><span class="params">(<span class="meta">@Nullable</span> Object source, <span class="meta">@Nullable</span> TypeDescriptor sourceType, TypeDescriptor targetType)</span> &#123;</span><br><span class="line">		<span class="comment">/**-----------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">		 * [DESC] 转换数据类型</span></span><br><span class="line"><span class="comment">		 * 1. 先获取转换器</span></span><br><span class="line"><span class="comment">		 * 2. 利用转换器进行数据转换</span></span><br><span class="line"><span class="comment">		 * 3. 对转换后的结果进行验证</span></span><br><span class="line"><span class="comment">		 *-----------------------------------------------------------------------------------------------------------*/</span></span><br><span class="line">		<span class="keyword">if</span> (sourceType == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="comment">// [1] sourceType为空，直接报异常就完事</span></span><br><span class="line">			<span class="keyword">return</span> handleResult(<span class="literal">null</span>, targetType, convertNullSource(<span class="literal">null</span>, targetType));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (source != <span class="literal">null</span> &amp;&amp; !sourceType.getObjectType().isInstance(source)) &#123;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// [2] 搜索转换器</span></span><br><span class="line">		<span class="type">GenericConverter</span> <span class="variable">converter</span> <span class="operator">=</span> getConverter(sourceType, targetType);</span><br><span class="line">		<span class="keyword">if</span> (converter != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="comment">// [3] 调用转换器</span></span><br><span class="line">			<span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> ConversionUtils.invokeConverter(converter, source, sourceType, targetType);</span><br><span class="line">			<span class="comment">// [4] 对转换结果进行判断</span></span><br><span class="line">			<span class="keyword">return</span> handleResult(sourceType, targetType, result);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// [5] over</span></span><br><span class="line">		<span class="keyword">return</span> handleConverterNotFound(source, sourceType, targetType);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>思路很清晰，搜索转换器、调用转换器、扫尾工作</p>
<p>我们主要看其如何管理转换器，转换器采用的是<code>策略设计模式</code></p>
<p>先暂时不用管这里，继续跟其搜索转换器那部分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> GenericConverter <span class="title function_">getConverter</span><span class="params">(TypeDescriptor sourceType, TypeDescriptor targetType)</span> &#123;</span><br><span class="line">		<span class="comment">// [1] 根据sourceType 和 targetType从缓存中拿到转换器</span></span><br><span class="line">		<span class="type">ConverterCacheKey</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConverterCacheKey</span>(sourceType, targetType);</span><br><span class="line">		<span class="type">GenericConverter</span> <span class="variable">converter</span> <span class="operator">=</span> <span class="built_in">this</span>.converterCache.get(key);</span><br><span class="line">		<span class="keyword">if</span> (converter != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> (converter != NO_MATCH ? converter : <span class="literal">null</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// [2] 如果缓存中没有，那就去搜索</span></span><br><span class="line">		converter = <span class="built_in">this</span>.converters.find(sourceType, targetType);</span><br><span class="line">		<span class="keyword">if</span> (converter == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 如果还没有，则获取默认的转换器</span></span><br><span class="line">			<span class="comment">// is null</span></span><br><span class="line">			converter = getDefaultConverter(sourceType, targetType);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// [3] 丢入缓存</span></span><br><span class="line">		<span class="keyword">if</span> (converter != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="built_in">this</span>.converterCache.put(key, converter);</span><br><span class="line">			<span class="keyword">return</span> converter;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// [4] 若找不到则直接设置该类型的转换器为空</span></span><br><span class="line">		<span class="built_in">this</span>.converterCache.put(key, NO_MATCH);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>由此可见缓存是多么重要. :dog:</p>
<p>continue</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> GenericConverter <span class="title function_">find</span><span class="params">(TypeDescriptor sourceType, TypeDescriptor targetType)</span> &#123;</span><br><span class="line">			<span class="comment">// 在这里搜索所有的继承的类型</span></span><br><span class="line">			List&lt;Class&lt;?&gt;&gt; sourceCandidates = getClassHierarchy(sourceType.getType());</span><br><span class="line">			List&lt;Class&lt;?&gt;&gt; targetCandidates = getClassHierarchy(targetType.getType());</span><br><span class="line">			<span class="comment">// 遍历所有类型的组合</span></span><br><span class="line">			<span class="keyword">for</span> (Class&lt;?&gt; sourceCandidate : sourceCandidates) &#123;</span><br><span class="line">				<span class="keyword">for</span> (Class&lt;?&gt; targetCandidate : targetCandidates) &#123;</span><br><span class="line">					<span class="comment">// 组合成  pair 后续会作为key 进行缓存</span></span><br><span class="line">					<span class="type">ConvertiblePair</span> <span class="variable">convertiblePair</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConvertiblePair</span>(sourceCandidate, targetCandidate);</span><br><span class="line">					<span class="comment">// 继续跟</span></span><br><span class="line">					<span class="type">GenericConverter</span> <span class="variable">converter</span> <span class="operator">=</span> getRegisteredConverter(sourceType, targetType, convertiblePair);</span><br><span class="line">					<span class="keyword">if</span> (converter != <span class="literal">null</span>) &#123;</span><br><span class="line">						<span class="keyword">return</span> converter;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>因为类型转换涉及到 <code>sourceType</code> —&gt; <code>targetType</code></p>
<p>所以分为两部分，获取 <code>sourceType</code>和 <code>targetType</code> 继承的所有的类型和实现的所有接口</p>
<p>如果自身类型无法转换，那么就看其继承的类型或者实现的接口类型能否进行类型转换。</p>
<p>what is mean?</p>
<p>如果现在有一个<code>sourceType</code>是实现自<code>List</code>的，本身转换器里面没有你这个类的转换器，这个时候它就会搜索你实现的接口或者继承的类，看有没有适合的，这个时候就可以搜索出来<code>list</code>了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> GenericConverter <span class="title function_">getRegisteredConverter</span><span class="params">(TypeDescriptor sourceType,</span></span><br><span class="line"><span class="params">				TypeDescriptor targetType, ConvertiblePair convertiblePair)</span> &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Check specifically registered converters</span></span><br><span class="line">			<span class="comment">// [1] 尝试从缓存中获取</span></span><br><span class="line">			<span class="type">ConvertersForPair</span> <span class="variable">convertersForPair</span> <span class="operator">=</span> <span class="built_in">this</span>.converters.get(convertiblePair);</span><br><span class="line">			<span class="keyword">if</span> (convertersForPair != <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="comment">// [2] 从pair中匹配转换器</span></span><br><span class="line">				<span class="type">GenericConverter</span> <span class="variable">converter</span> <span class="operator">=</span> convertersForPair.getConverter(sourceType, targetType);</span><br><span class="line">				<span class="keyword">if</span> (converter != <span class="literal">null</span>) &#123;</span><br><span class="line">					<span class="keyword">return</span> converter;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// [3] 如果缓存中没有，则从全局转换器中一个一个去匹配</span></span><br><span class="line">			<span class="keyword">for</span> (GenericConverter globalConverter : <span class="built_in">this</span>.globalConverters) &#123;</span><br><span class="line">				<span class="keyword">if</span> (((ConditionalConverter) globalConverter).matches(sourceType, targetType)) &#123;</span><br><span class="line">					<span class="keyword">return</span> globalConverter;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看着很乱，没事继续跟</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> GenericConverter <span class="title function_">getConverter</span><span class="params">(TypeDescriptor sourceType, TypeDescriptor targetType)</span> &#123;</span><br><span class="line">			<span class="comment">// 虽然一组类型的转换可以有多个转换器，但是通常只有一个转换器，因为我们一个转换器就可以满足需求了啊...</span></span><br><span class="line">			<span class="comment">// 除了某些特殊的类型，比如说日期，毕竟日期有很多种格式. [NOTE] 我猜的</span></span><br><span class="line">  	 <span class="comment">// 匹配转换器</span></span><br><span class="line">			<span class="keyword">for</span> (GenericConverter converter : <span class="built_in">this</span>.converters) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!(converter <span class="keyword">instanceof</span> ConditionalGenericConverter) ||</span><br><span class="line">						((ConditionalGenericConverter) converter).matches(sourceType, targetType)) &#123;</span><br><span class="line">					<span class="keyword">return</span> converter;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>请跳到第二节.</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Spring-Core</category>
      </categories>
      <tags>
        <tag>Spring-Core</tag>
      </tags>
  </entry>
  <entry>
    <title>2.Spring转换器的管理</title>
    <url>/2021/08/02/spring_analysis/core/2.%E8%BD%AC%E6%8D%A2%E5%99%A8%E7%9A%84%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h3 id="前言-13">前言</h3>
<p>因为分开每一个类理解是很难理解其设计，所以需要总结，分析各个类的义务，组合起来就是整个类型转换服务的功能. 先看一张结构图。</p>
<img src="/2021/08/02/spring_analysis/core/2.%E8%BD%AC%E6%8D%A2%E5%99%A8%E7%9A%84%E7%AE%A1%E7%90%86/image-20191017150446544.png" class="">
<ul>
<li>
<p><code>ConvertiblePair</code> 用于描述类型转换信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ConvertiblePair</span> &#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; sourceType;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; targetType;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>Converter</code> 用于转换数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GenericConverter</span> &#123;</span><br><span class="line">	<span class="comment">// 获取描述信息</span></span><br><span class="line">	Set&lt;ConvertiblePair&gt; <span class="title function_">getConvertibleTypes</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 数据转换</span></span><br><span class="line">	Object <span class="title function_">convert</span><span class="params">(<span class="meta">@Nullable</span> Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>ConvertersForPair</code> 用于管理同一个类型的所有的<code>Converter</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ConvertersForPair</span> &#123;</span><br><span class="line">	 <span class="comment">// 存放同一类型的转换器</span></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;GenericConverter&gt; converters = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 添加转换器</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(GenericConverter converter)</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 匹配并且获取转换器</span></span><br><span class="line">		<span class="keyword">public</span> GenericConverter <span class="title function_">getConverter</span><span class="params">(TypeDescriptor sourceType, TypeDescriptor targetType)</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>Converters</code> 用于管理所有类型的转换器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Converters</span> &#123;</span><br><span class="line">		<span class="comment">// 存放全局转换器, 未知转换类型的转换器</span></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> Set&lt;GenericConverter&gt; globalConverters = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 用作缓存，快速查询转换器</span></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;ConvertiblePair, ConvertersForPair&gt; converters = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(<span class="number">36</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * [DESC] 添加转换器</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> converter 需要添加的转换器</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(GenericConverter converter)</span>;</span><br><span class="line">  </span><br><span class="line">	  <span class="comment">// 查询转换器</span></span><br><span class="line">		<span class="keyword">public</span> GenericConverter <span class="title function_">find</span><span class="params">(TypeDescriptor sourceType, TypeDescriptor targetType)</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 匹配已经注册的转换器</span></span><br><span class="line">		<span class="keyword">private</span> GenericConverter <span class="title function_">getRegisteredConverter</span><span class="params">(TypeDescriptor sourceType,</span></span><br><span class="line"><span class="params">				TypeDescriptor targetType, ConvertiblePair convertiblePair)</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>GenericCOnversionService</code> 负责调度这些转换器从而提供转换服务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericConversionService</span> <span class="keyword">implements</span> <span class="title class_">ConfigurableConversionService</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 转换器管理类，用于管理所有的转换器</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Converters</span> <span class="variable">converters</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Converters</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用于缓存 source-&gt;target 的转换器</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;ConverterCacheKey, GenericConverter&gt; converterCache = <span class="keyword">new</span> <span class="title class_">ConcurrentReferenceHashMap</span>&lt;&gt;(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 添加转换器</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addConverter</span><span class="params">(Converter&lt;?, ?&gt; converter)</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 提供转换的业务</span></span><br><span class="line">	<span class="keyword">public</span> &lt;T&gt; T <span class="title function_">convert</span><span class="params">(<span class="meta">@Nullable</span> Object source, Class&lt;T&gt; targetType)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取转换器</span></span><br><span class="line">	<span class="keyword">protected</span> GenericConverter <span class="title function_">getConverter</span><span class="params">(TypeDescriptor sourceType, TypeDescriptor targetType)</span></span><br></pre></td></tr></table></figure>
<p>这一下子就清楚了，其核心就是围绕 <code>匹配转换器/find转换器</code> 而实现的</p>
<p>因为具体的转换的逻辑是采用<code>策略设计模式</code>, 讨论具体框架的时候根本不用管</p>
<p>下面来看一张具体的流程图。</p>
<img src="/2021/08/02/spring_analysis/core/2.%E8%BD%AC%E6%8D%A2%E5%99%A8%E7%9A%84%E7%AE%A1%E7%90%86/image-20191017165220571.png" class="">
<p>将此图链接上顶部的结构图，就一目了然，想要找到 <code>Converter</code> 就得先找到 <code>ConvertsOfPair</code> 然后在 其内部匹配转换器, 若在 <code>ConvertersOfPair</code> 中没有，则会在 <code>Converters</code> 管理的全局转换器中匹配</p>
<p>有了这些，再返回第一节看源码，一定很清晰.</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Spring-Core</category>
      </categories>
      <tags>
        <tag>Spring-Core</tag>
      </tags>
  </entry>
  <entry>
    <title>3.Spring提供的转换器</title>
    <url>/2021/08/02/spring_analysis/core/3.sprint%E6%8F%90%E4%BE%9B%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%99%A8/</url>
    <content><![CDATA[<h3 id="前言-14">前言</h3>
<p><code>GenericConversionService</code> 的功能提供转换数据的服务, <code>DefaultConversionService</code> 是继承自前者的，它的责任就是注册一些基本的<code>Converter</code>,  let me see～</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addDefaultConverters</span><span class="params">(ConverterRegistry converterRegistry)</span> &#123;</span><br><span class="line">   addScalarConverters(converterRegistry);</span><br><span class="line">   addCollectionConverters(converterRegistry);</span><br><span class="line">   <span class="comment">// ByteBuff -&gt; byte[]</span></span><br><span class="line">   <span class="comment">// byte[] -&gt; ByteBuff</span></span><br><span class="line">   converterRegistry.addConverter(<span class="keyword">new</span> <span class="title class_">ByteBufferConverter</span>((ConversionService) converterRegistry));</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// String -&gt; TimeZone</span></span><br><span class="line">   converterRegistry.addConverter(<span class="keyword">new</span> <span class="title class_">StringToTimeZoneConverter</span>());</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// ZoneId -&gt; TimeZone</span></span><br><span class="line">   converterRegistry.addConverter(<span class="keyword">new</span> <span class="title class_">ZoneIdToTimeZoneConverter</span>());</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// DateTime -&gt; Calendar</span></span><br><span class="line">   converterRegistry.addConverter(<span class="keyword">new</span> <span class="title class_">ZonedDateTimeToCalendarConverter</span>());</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// Object -&gt; Object</span></span><br><span class="line">   converterRegistry.addConverter(<span class="keyword">new</span> <span class="title class_">ObjectToObjectConverter</span>());</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// Id -&gt; Entity</span></span><br><span class="line">   converterRegistry.addConverter(<span class="keyword">new</span> <span class="title class_">IdToEntityConverter</span>((ConversionService) converterRegistry));</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// FallBackObject -&gt; String</span></span><br><span class="line">   converterRegistry.addConverter(<span class="keyword">new</span> <span class="title class_">FallbackObjectToStringConverter</span>());</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// Object -&gt; Optional</span></span><br><span class="line">   converterRegistry.addConverter(<span class="keyword">new</span> <span class="title class_">ObjectToOptionalConverter</span>((ConversionService) converterRegistry));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add common collection converters.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> converterRegistry the registry of converters to add to</span></span><br><span class="line"><span class="comment"> * (must also be castable to ConversionService, e.g. being a &#123;<span class="doctag">@link</span> ConfigurableConversionService&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassCastException if the given ConverterRegistry could not be cast to a ConversionService</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 4.2.3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addCollectionConverters</span><span class="params">(ConverterRegistry converterRegistry)</span> &#123;</span><br><span class="line">   <span class="type">ConversionService</span> <span class="variable">conversionService</span> <span class="operator">=</span> (ConversionService) converterRegistry;</span><br><span class="line">   <span class="comment">// Array -&gt; Collection</span></span><br><span class="line">   converterRegistry.addConverter(<span class="keyword">new</span> <span class="title class_">ArrayToCollectionConverter</span>(conversionService));</span><br><span class="line">   <span class="comment">// Collection -&gt; Array</span></span><br><span class="line">   converterRegistry.addConverter(<span class="keyword">new</span> <span class="title class_">CollectionToArrayConverter</span>(conversionService));</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// Array -&gt; Array</span></span><br><span class="line">   converterRegistry.addConverter(<span class="keyword">new</span> <span class="title class_">ArrayToArrayConverter</span>(conversionService));</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// Collection -&gt; Collection</span></span><br><span class="line">   converterRegistry.addConverter(<span class="keyword">new</span> <span class="title class_">CollectionToCollectionConverter</span>(conversionService));</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// Map -&gt; Map</span></span><br><span class="line">   converterRegistry.addConverter(<span class="keyword">new</span> <span class="title class_">MapToMapConverter</span>(conversionService));</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// Array -&gt; String</span></span><br><span class="line">   converterRegistry.addConverter(<span class="keyword">new</span> <span class="title class_">ArrayToStringConverter</span>(conversionService));</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// String -&gt; Array</span></span><br><span class="line">   converterRegistry.addConverter(<span class="keyword">new</span> <span class="title class_">StringToArrayConverter</span>(conversionService));</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// Array -&gt; Object</span></span><br><span class="line">   converterRegistry.addConverter(<span class="keyword">new</span> <span class="title class_">ArrayToObjectConverter</span>(conversionService));</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// Object -&gt; Array</span></span><br><span class="line">   converterRegistry.addConverter(<span class="keyword">new</span> <span class="title class_">ObjectToArrayConverter</span>(conversionService));</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// Collection -&gt; String</span></span><br><span class="line">   converterRegistry.addConverter(<span class="keyword">new</span> <span class="title class_">CollectionToStringConverter</span>(conversionService));</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// String -&gt; Collection</span></span><br><span class="line">   converterRegistry.addConverter(<span class="keyword">new</span> <span class="title class_">StringToCollectionConverter</span>(conversionService));</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// Collection -&gt; Object</span></span><br><span class="line">   converterRegistry.addConverter(<span class="keyword">new</span> <span class="title class_">CollectionToObjectConverter</span>(conversionService));</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// Object -&gt; Collection</span></span><br><span class="line">   converterRegistry.addConverter(<span class="keyword">new</span> <span class="title class_">ObjectToCollectionConverter</span>(conversionService));</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// Stream -&gt; Collection</span></span><br><span class="line">   <span class="comment">// Collection -&gt; Stream</span></span><br><span class="line">   converterRegistry.addConverter(<span class="keyword">new</span> <span class="title class_">StreamConverter</span>(conversionService));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addScalarConverters</span><span class="params">(ConverterRegistry converterRegistry)</span> &#123;</span><br><span class="line">   <span class="comment">// Number -&gt; Number</span></span><br><span class="line">   converterRegistry.addConverterFactory(<span class="keyword">new</span> <span class="title class_">NumberToNumberConverterFactory</span>());</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// String -&gt; Number</span></span><br><span class="line">   converterRegistry.addConverterFactory(<span class="keyword">new</span> <span class="title class_">StringToNumberConverterFactory</span>());</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// Number -&gt; String</span></span><br><span class="line">   converterRegistry.addConverter(Number.class, String.class, <span class="keyword">new</span> <span class="title class_">ObjectToStringConverter</span>());</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// String -&gt; Character</span></span><br><span class="line">   converterRegistry.addConverter(<span class="keyword">new</span> <span class="title class_">StringToCharacterConverter</span>());</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// Character -&gt; String</span></span><br><span class="line">   converterRegistry.addConverter(Character.class, String.class, <span class="keyword">new</span> <span class="title class_">ObjectToStringConverter</span>());</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Number -&gt; Character</span></span><br><span class="line">   converterRegistry.addConverter(<span class="keyword">new</span> <span class="title class_">NumberToCharacterConverter</span>());</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// Character -&gt; Number</span></span><br><span class="line">   converterRegistry.addConverterFactory(<span class="keyword">new</span> <span class="title class_">CharacterToNumberFactory</span>());</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// String -&gt; Boolean</span></span><br><span class="line">   converterRegistry.addConverter(<span class="keyword">new</span> <span class="title class_">StringToBooleanConverter</span>());</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// Boolean -&gt; String</span></span><br><span class="line">   converterRegistry.addConverter(Boolean.class, String.class, <span class="keyword">new</span> <span class="title class_">ObjectToStringConverter</span>());</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// String -&gt; Enum</span></span><br><span class="line">   converterRegistry.addConverterFactory(<span class="keyword">new</span> <span class="title class_">StringToEnumConverterFactory</span>());</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// Enum -&gt; String</span></span><br><span class="line">   converterRegistry.addConverter(<span class="keyword">new</span> <span class="title class_">EnumToStringConverter</span>((ConversionService) converterRegistry));</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// Integer -&gt; Enum</span></span><br><span class="line">   converterRegistry.addConverterFactory(<span class="keyword">new</span> <span class="title class_">IntegerToEnumConverterFactory</span>());</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// Enum -&gt; Integer</span></span><br><span class="line">   converterRegistry.addConverter(<span class="keyword">new</span> <span class="title class_">EnumToIntegerConverter</span>((ConversionService) converterRegistry));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// String -&gt; Local</span></span><br><span class="line">   converterRegistry.addConverter(<span class="keyword">new</span> <span class="title class_">StringToLocaleConverter</span>());</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// Local -&gt; String </span></span><br><span class="line">   converterRegistry.addConverter(Locale.class, String.class, <span class="keyword">new</span> <span class="title class_">ObjectToStringConverter</span>());</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// String -&gt; Charset</span></span><br><span class="line">   converterRegistry.addConverter(<span class="keyword">new</span> <span class="title class_">StringToCharsetConverter</span>());</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// CharSet -&gt; String</span></span><br><span class="line">   converterRegistry.addConverter(Charset.class, String.class, <span class="keyword">new</span> <span class="title class_">ObjectToStringConverter</span>());</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// String -&gt; Currency</span></span><br><span class="line">   converterRegistry.addConverter(<span class="keyword">new</span> <span class="title class_">StringToCurrencyConverter</span>());</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// Currency -&gt; String </span></span><br><span class="line">   converterRegistry.addConverter(Currency.class, String.class, <span class="keyword">new</span> <span class="title class_">ObjectToStringConverter</span>());</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// String -&gt; Properties</span></span><br><span class="line">   converterRegistry.addConverter(<span class="keyword">new</span> <span class="title class_">StringToPropertiesConverter</span>());</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// Properties -&gt; String </span></span><br><span class="line">   converterRegistry.addConverter(<span class="keyword">new</span> <span class="title class_">PropertiesToStringConverter</span>());</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// String -&gt; UUID</span></span><br><span class="line">   converterRegistry.addConverter(<span class="keyword">new</span> <span class="title class_">StringToUUIDConverter</span>());</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// UUID -&gt; String </span></span><br><span class="line">   converterRegistry.addConverter(UUID.class, String.class, <span class="keyword">new</span> <span class="title class_">ObjectToStringConverter</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>选择自己喜欢的部分详尽，这里太多了，不一一详尽</p>
]]></content>
      <categories>
        <category>Spring-Core</category>
      </categories>
      <tags>
        <tag>Spring-Core</tag>
      </tags>
  </entry>
  <entry>
    <title>4.进一步分析&#39;添加转换器</title>
    <url>/2021/08/02/spring_analysis/core/4.%E6%B7%BB%E5%8A%A0%E8%BD%AC%E6%8D%A2%E5%99%A8%E5%86%8D%E8%AF%A6%E5%B0%BD/</url>
    <content><![CDATA[<h3 id="前言-15">前言</h3>
<p>本节将单个功能<code>添加转换器</code>拿出来再讨论</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addConverter</span><span class="params">(Converter&lt;?, ?&gt; converter)</span> &#123;</span><br><span class="line">		<span class="comment">// [1] 首先获取范形的类型 [NOTE] 这个工具方法其实也蛮常用的，有兴趣可以了解下</span></span><br><span class="line">		ResolvableType[] typeInfo = getRequiredTypeInfo(converter.getClass(), Converter.class);</span><br><span class="line">		<span class="keyword">if</span> (typeInfo == <span class="literal">null</span> &amp;&amp; converter <span class="keyword">instanceof</span> DecoratingProxy) &#123;</span><br><span class="line">			typeInfo = getRequiredTypeInfo(((DecoratingProxy) converter).getDecoratedClass(), Converter.class);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 然后构造成 Adapter，继续跟</span></span><br><span class="line">		addConverter(<span class="keyword">new</span> <span class="title class_">ConverterAdapter</span>(converter, typeInfo[<span class="number">0</span>], typeInfo[<span class="number">1</span>]));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>这里出现了一个 <code>ConverterAdapter</code>, 转换器适配器，来看下其功能是什么.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * [DESC] Converter只负责对指定数据类型的转换，类型匹配的职责就用适配器来扩充</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ConverterAdapter</span> <span class="keyword">implements</span> <span class="title class_">ConditionalGenericConverter</span> &#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> Converter&lt;Object, Object&gt; converter;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> ConvertiblePair typeInfo;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> ResolvableType targetType;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(TypeDescriptor sourceType, TypeDescriptor targetType)</span> &#123;</span><br><span class="line">			<span class="comment">// [1] 先检查目标类型是否一致</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">this</span>.typeInfo.getTargetType() != targetType.getObjectType()) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Full check for complex generic type match required?</span></span><br><span class="line">			<span class="type">ResolvableType</span> <span class="variable">rt</span> <span class="operator">=</span> targetType.getResolvableType();</span><br><span class="line">			<span class="keyword">if</span> (!(rt.getType() <span class="keyword">instanceof</span> Class) &amp;&amp; !rt.isAssignableFrom(<span class="built_in">this</span>.targetType) &amp;&amp;</span><br><span class="line">					!<span class="built_in">this</span>.targetType.hasUnresolvableGenerics()) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// [2] 如果转换器为 ConditionalConverter 说明其具备 matches的能力, 则调用matches判断</span></span><br><span class="line">			<span class="keyword">return</span> !(<span class="built_in">this</span>.converter <span class="keyword">instanceof</span> ConditionalConverter) ||</span><br><span class="line">					((ConditionalConverter) <span class="built_in">this</span>.converter).matches(sourceType, targetType);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="meta">@Nullable</span></span><br><span class="line">		<span class="keyword">public</span> Object <span class="title function_">convert</span><span class="params">(<span class="meta">@Nullable</span> Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (source == <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> convertNullSource(sourceType, targetType);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">this</span>.converter.convert(source);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>这个适配器的作用扩充了 普通<code> Converter</code> 没有的功能就是 <code>matches</code>, 这样的好处是，我们可以插入自己的 <code>Converter</code>, 因为我们要实现 <code>conver</code> 功能和 <code>matches</code> 功能，这样<code>Service</code> 就不用处理 <code>matches</code> 逻辑了，将其交给我们。这样扩展性大大提高。</p>
<p>继续接着上面:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(GenericConverter converter)</span> &#123;</span><br><span class="line">   Set&lt;ConvertiblePair&gt; convertibleTypes = converter.getConvertibleTypes();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// [1] 如果没有提供具体的类型转换信息，则自动加入到全局转换器</span></span><br><span class="line">   <span class="comment">// 因为全局转换器中可以会存在 ConditionalConverter 其自带了匹配的功能所以不提供此信息也无妨</span></span><br><span class="line">   <span class="keyword">if</span> (convertibleTypes == <span class="literal">null</span>) &#123;</span><br><span class="line">      Assert.state(converter <span class="keyword">instanceof</span> ConditionalConverter,</span><br><span class="line">            <span class="string">&quot;Only conditional converters may return null convertible types&quot;</span>);</span><br><span class="line">      <span class="comment">// 如果转换类型是未知的，则放到全局转换器中</span></span><br><span class="line">      <span class="built_in">this</span>.globalConverters.add(converter);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 否则判断这个转换的类型，是不是和其它转换器的类型是一样的，如果是一样，则放在一起</span></span><br><span class="line">      <span class="comment">// 也就是放进ConvertersForPair 用于管理同一种类型的转换器</span></span><br><span class="line">      <span class="keyword">for</span> (ConvertiblePair convertiblePair : convertibleTypes) &#123;</span><br><span class="line">         <span class="comment">// [2] 尝试寻找该类型的转换器，若没有它会创建一个新的</span></span><br><span class="line">         <span class="type">ConvertersForPair</span> <span class="variable">convertersForPair</span> <span class="operator">=</span> getMatchableConverters(convertiblePair);</span><br><span class="line">         <span class="comment">// 添加转换器到 该类型</span></span><br><span class="line">         convertersForPair.add(converter);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ConvertersForPair <span class="title function_">getMatchableConverters</span><span class="params">(ConvertiblePair convertiblePair)</span> &#123;</span><br><span class="line">   <span class="comment">// 先从缓存中查询这种类型的转换器有没有</span></span><br><span class="line">   <span class="type">ConvertersForPair</span> <span class="variable">convertersForPair</span> <span class="operator">=</span> <span class="built_in">this</span>.converters.get(convertiblePair);</span><br><span class="line">   <span class="keyword">if</span> (convertersForPair == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果没有这种类型的转换器，则创建一个并且加入缓存</span></span><br><span class="line">      convertersForPair = <span class="keyword">new</span> <span class="title class_">ConvertersForPair</span>();</span><br><span class="line">      <span class="built_in">this</span>.converters.put(convertiblePair, convertersForPair);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> convertersForPair;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实和 <code>find</code> 和 <code>add</code> 的过程有很多类似的地方</p>
<p>总结几点：</p>
<ul>
<li>判断其是否提供了转换类型的信息，若不提供则直接加入到 全局转换器中</li>
<li>判断二级缓存中是否已经存在了此转换类型的 <code>ConvertersForPair</code> 如果存在则直接丢进去，否则创建一个新的<code>ConvertersForPair</code>然后把转换器丢进去.</li>
</ul>
<p>下一小节实现自定义的转换器</p>
]]></content>
      <categories>
        <category>Spring-Core</category>
      </categories>
      <tags>
        <tag>Spring-Core</tag>
      </tags>
  </entry>
  <entry>
    <title>5.Spring自定义转换器</title>
    <url>/2021/08/02/spring_analysis/core/5.%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%99%A8/</url>
    <content><![CDATA[<h3 id="前言-16">前言</h3>
<p>若要实现自己的类型转换器，则需要注意一下几点.</p>
<ul>
<li>推荐继承 <code>ConditionalGenericConverter</code></li>
<li>也可以继承 <code>GenericConverter</code></li>
<li>如果转换发生异常，最好抛出 <code>ConversionFailedException</code> 异常</li>
<li>最好提供<code>ConvertiblePair</code> 类型信息，这样就会被缓存，而不会被加入到全局转换器，到时候再一一遍历.</li>
</ul>
<hr>
<p>首先弄两个 测试类型，一个source 一个 target</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MySourceType</span> &#123;</span><br><span class="line">		<span class="keyword">private</span> String name;</span><br><span class="line">		<span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> name;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">			<span class="built_in">this</span>.name = name;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> age;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">			<span class="built_in">this</span>.age = age;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">MyTargetType</span>&#123;</span><br><span class="line">		<span class="keyword">private</span> String fake_name;</span><br><span class="line">		<span class="keyword">private</span> <span class="type">int</span> fake_age;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> String <span class="title function_">getFake_name</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> fake_name;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFake_name</span><span class="params">(String fake_name)</span> &#123;</span><br><span class="line">			<span class="built_in">this</span>.fake_name = fake_name;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getFake_age</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> fake_age;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFake_age</span><span class="params">(<span class="type">int</span> fake_age)</span> &#123;</span><br><span class="line">			<span class="built_in">this</span>.fake_age = fake_age;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;MyTargetType&#123;&quot;</span> +</span><br><span class="line">					<span class="string">&quot;fake_name=&#x27;&quot;</span> + fake_name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">					<span class="string">&quot;, fake_age=&quot;</span> + fake_age +</span><br><span class="line">					<span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>然后是 转换器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyConverter</span> <span class="keyword">implements</span> <span class="title class_">ConditionalGenericConverter</span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(TypeDescriptor sourceType, TypeDescriptor targetType)</span> &#123;</span><br><span class="line">			<span class="comment">// 这里写得比较死，想灵活的可以参考其内置的转换器</span></span><br><span class="line">			<span class="keyword">return</span> sourceType.getObjectType() == MySourceType.class &amp;&amp;</span><br><span class="line">					targetType.getObjectType() == MyTargetType.class;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> Set&lt;ConvertiblePair&gt; <span class="title function_">getConvertibleTypes</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="comment">// 这里可以学习一下，返回一个singleton</span></span><br><span class="line">			<span class="keyword">return</span> Collections.singleton(<span class="keyword">new</span> <span class="title class_">ConvertiblePair</span>(MySourceType.class, MyTargetType.class));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> Object <span class="title function_">convert</span><span class="params">(Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</span> &#123;</span><br><span class="line">			<span class="comment">// 具体转换逻辑 瞎几把写的。哈哈</span></span><br><span class="line">			<span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">			<span class="keyword">if</span>(source <span class="keyword">instanceof</span> MySourceType)&#123;</span><br><span class="line">				<span class="type">MySourceType</span> <span class="variable">temp</span> <span class="operator">=</span> (MySourceType)(source);</span><br><span class="line">				<span class="type">MyTargetType</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTargetType</span>();</span><br><span class="line">				target.setFake_age(temp.getAge());</span><br><span class="line">				target.setFake_name(temp.getName());</span><br><span class="line">				result = (Object)target;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>测试用例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">testMyConverter</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="type">DefaultConversionService</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConversionService</span>();</span><br><span class="line">    <span class="comment">// 添加我们的转换器进去</span></span><br><span class="line">		service.addConverter(<span class="keyword">new</span> <span class="title class_">MyConverter</span>());</span><br><span class="line">    </span><br><span class="line">		<span class="keyword">final</span> <span class="type">MySourceType</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MySourceType</span>();</span><br><span class="line">		source.setAge(<span class="number">1</span>);</span><br><span class="line">		source.setName(<span class="string">&quot;souce&quot;</span>);</span><br><span class="line">    <span class="comment">// 调用转换器</span></span><br><span class="line">		<span class="keyword">final</span> <span class="type">MyTargetType</span> <span class="variable">target</span> <span class="operator">=</span> service.convert(source, MyTargetType.class);</span><br><span class="line">		System.out.println(target);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Spring-Core</category>
      </categories>
      <tags>
        <tag>Spring-Core</tag>
      </tags>
  </entry>
  <entry>
    <title>源码级理解 BeanFactory 和 FactoryBean的区别</title>
    <url>/2021/08/02/spring_analysis/interview/%E6%BA%90%E7%A0%81%E7%BA%A7%E7%90%86%E8%A7%A3%20BeanFactory%20%E5%92%8C%20FactoryBean%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h3 id="1-BeanFactory">1. BeanFactory</h3>
<p><code>BeanFactory</code> 是一个接口，其定义了一个 <code>容器</code> 所具备的接口</p>
<ul>
<li>getBean</li>
<li>containsBean</li>
<li>isSingleton</li>
<li>isPrototype</li>
<li>isTypeMatch</li>
<li>getType</li>
</ul>
<p>意味着 <code>BeanFactory</code> 实现了 <code>Dependent Injection</code>，比较常见的用法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DefaultListableBeanFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>();</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionReader</span>(factory).loadBeanDefinitions(WITH_AUTOWIRING_CONTEXT);</span><br><span class="line"><span class="keyword">final</span> <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> factory.getBean(<span class="string">&quot;TestFactoryBean&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这个工厂的源码解析在上一层目录 <code>beans</code>中，在这不多讨论。</p>
<h3 id="2-FactoryBean">2. FactoryBean</h3>
<p>其实<code>BeanFactory</code> 没什么好讨论的，这个接口基本贯穿了整个<code>beans</code> 组件，唯一比较容易搞混的就是<code>FactoryBean</code></p>
<p>先概览一下其接口:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FactoryBean</span>&lt;T&gt; &#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">OBJECT_TYPE_ATTRIBUTE</span> <span class="operator">=</span> <span class="string">&quot;factoryBeanObjectType&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	T <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	Class&lt;?&gt; getObjectType();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这玩意和我们用的什么 <code>sqlSessionFactory</code>、<code>LoggerFactory</code> 都有着相同的思想，就是一个用于生产对象的工厂类。</p>
<p><code>BeanFactory</code> 是一个容器，而 <code>FactoryBean</code> 则是一个实实在在的 <code>Bean</code> ，但其也有不普通的地方，也就是其的作用只是用来生产 <code>Bean</code>。下面写一个测试类 :</p>
<p>首先是实现这个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;Object&gt; &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">24234</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">		<span class="keyword">return</span> Integer.class;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后定义一下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;TestFactoryBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.tests.beans.TestFactoryBean&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>最后调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DefaultListableBeanFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>();</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionReader</span>(factory).loadBeanDefinitions(WITH_AUTOWIRING_CONTEXT);</span><br><span class="line">		<span class="keyword">final</span> <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> factory.getBean(<span class="string">&quot;TestFactoryBean&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bean = 24234</span><br></pre></td></tr></table></figure>
<p>这很容易能看出 <code>FactoryBean</code> 的作用，当我们调用 <code>getBean</code>的时候，其会实例化 <code>TestFactoryBean</code> 对象，然后调用 <code>getObject</code> 方法拿到<code>Bean</code> 最后返回给我们。</p>
<p>如果<code>TestFactoryBean</code> 是一般的 <code>Bean</code> 也就是没有实现 <code>FactoryBean</code> 接口，那么我们调用上述的 <code>getBean</code> 则直接会返回 <code>TestFactoryBean</code> 的实例对象</p>
<p>由此我们可以得出一个结论：</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">FactoryBean是一个工厂 Bean，<span class="keyword">spring</span>会自动调用其 getObject方法拿到最终的 Bean</span><br></pre></td></tr></table></figure>
<hr>
<p>所以下面我们从源码层面剖析以及扩展涉及到的知识.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">					sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							<span class="comment">// [6] 创建Bean</span></span><br><span class="line">							<span class="comment">/** &#123;<span class="doctag">@link</span> AbstractAutowireCapableBeanFactory#createBean(String, RootBeanDefinition, Object[])&#125;*/</span></span><br><span class="line">							<span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;);</span><br><span class="line"></span><br><span class="line">					<span class="comment">// 在这里判断是不是FactoryBean 如果是则调用其 getObject 方法</span></span><br><span class="line">					bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">				&#125;</span><br></pre></td></tr></table></figure>
<p><code>createBean</code> 不是这一小节关键的地方，其作用是负责创建 <code>Instance</code>并且进行 <code>DI</code>，下面的 <code>getObjectForbeanInstance</code> 才是解密<code>FactoryBean</code> 的关键</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getObjectForBeanInstance</span><span class="params">(</span></span><br><span class="line"><span class="params">			Object beanInstance, String name, String beanName, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**---------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">		 * [DESC] 处理 FactoryBean</span></span><br><span class="line"><span class="comment">		 * [1] 首先，判断是根据 type 还是 name来 getBean</span></span><br><span class="line"><span class="comment">		 * [2] 其次其是不是 FactoryBean</span></span><br><span class="line"><span class="comment">		 * [3] 如果是根据 type 则直接返回其本身，无论是普通bean还是FactoryBean</span></span><br><span class="line"><span class="comment">		 * [4] 如果是根据名字，当是FactoryBean则调用其getObject方法</span></span><br><span class="line"><span class="comment">		 *----------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// [1] 如果是根据类型，则 name 则带有一个 &amp; 字符</span></span><br><span class="line">		<span class="comment">// 如果是根据名字则没有</span></span><br><span class="line">		<span class="comment">// Note 当然你可以在名字上自己一个 &amp; 符号，但这并不规范，容易让人混淆</span></span><br><span class="line">		<span class="keyword">if</span> (BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (beanInstance <span class="keyword">instanceof</span> NullBean) &#123;</span><br><span class="line">				<span class="keyword">return</span> beanInstance;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean)) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanIsNotAFactoryException</span>(beanName, beanInstance.getClass());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (mbd != <span class="literal">null</span>) &#123;</span><br><span class="line">				mbd.isFactoryBean = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> beanInstance;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 执行到这里则说明是根据名字来获取</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果不是 FactoryBean 则直接返回，不需要处理</span></span><br><span class="line">		<span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean)) &#123;</span><br><span class="line">			<span class="keyword">return</span> beanInstance;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 老规矩从缓存中获取</span></span><br><span class="line">		<span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (mbd != <span class="literal">null</span>) &#123;</span><br><span class="line">			mbd.isFactoryBean = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			object = getCachedObjectForFactoryBean(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (object == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="comment">// Return bean instance from factory.</span></span><br><span class="line">			FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;</span><br><span class="line">			<span class="comment">// Caches object obtained from FactoryBean if it is a singleton.</span></span><br><span class="line">			<span class="keyword">if</span> (mbd == <span class="literal">null</span> &amp;&amp; containsBeanDefinition(beanName)) &#123;</span><br><span class="line">				mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">boolean</span> <span class="variable">synthetic</span> <span class="operator">=</span> (mbd != <span class="literal">null</span> &amp;&amp; mbd.isSynthetic());</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 缓存没有，则继续获取 NOTE step in</span></span><br><span class="line">			object = getObjectFromFactoryBean(factory, beanName, !synthetic);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> object;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>如果说源码看多了就会发现这样一个规律就是:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">实际上很简单的东西，习惯性分为两个或者多个函数，前者负责参数检查，或者预处理，后者才是真正实现的方法</span><br></pre></td></tr></table></figure>
<p>总结上面的功能：</p>
<ul>
<li>如果是 byType 则 <code>name</code> 上则会带有 <code>&amp;</code> 字符，这个时候它就不处理了，直接返回 <code>Instance </code></li>
<li>如果是 byName 则 <code>name </code> 上没有 <code>&amp;</code> 字符，如果为 <code>FactoryBean</code> 则进行处理，否则直接返回 <code>Instance </code></li>
</ul>
<p>这就很有意思了，如果你通过 <code>byType</code> 你只能拿到 <code>FactoryBean</code> 的实例，你也可以通过 <code>byName</code> 并且在 <code>name</code> 前面加一个 <code>&amp;</code> 也可以拿到 <code>FactoryBean</code> 对象，但这貌似不符合规范，哈哈，不过在这里不推荐这样搞 . 否则就失去 <code>FactoryBean</code> 的意义了</p>
<p>那么 继续跟。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getObjectFromFactoryBean</span><span class="params">(FactoryBean&lt;?&gt; factory, String beanName, <span class="type">boolean</span> shouldPostProcess)</span> &#123;</span><br><span class="line">		<span class="comment">// 确保在工厂中已经生成了该 bean</span></span><br><span class="line">		<span class="keyword">if</span> (factory.isSingleton() &amp;&amp; containsSingleton(beanName)) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (getSingletonMutex()) &#123;</span><br><span class="line">				<span class="comment">// 尝试从缓存中拿到工厂bean生成的对象</span></span><br><span class="line">				<span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="built_in">this</span>.factoryBeanObjectCache.get(beanName);</span><br><span class="line">				<span class="keyword">if</span> (object == <span class="literal">null</span>) &#123;</span><br><span class="line">					<span class="comment">// 缓存中拿不到, 则调用  getObject 方法</span></span><br><span class="line">					object = doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line">					<span class="comment">// Only post-process and store if not put there already during getObject() call above</span></span><br><span class="line">					<span class="comment">// (e.g. because of circular reference processing triggered by custom getBean calls)</span></span><br><span class="line">					<span class="type">Object</span> <span class="variable">alreadyThere</span> <span class="operator">=</span> <span class="built_in">this</span>.factoryBeanObjectCache.get(beanName);</span><br><span class="line">					<span class="keyword">if</span> (alreadyThere != <span class="literal">null</span>) &#123;</span><br><span class="line">						object = alreadyThere;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="keyword">if</span> (shouldPostProcess) &#123;</span><br><span class="line">							<span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">								<span class="comment">// Temporarily return non-post-processed object, not storing it yet..</span></span><br><span class="line">								<span class="keyword">return</span> object;</span><br><span class="line">							&#125;</span><br><span class="line">							beforeSingletonCreation(beanName);</span><br><span class="line">							<span class="keyword">try</span> &#123;</span><br><span class="line">								<span class="comment">// 调用 BeanProcessor#postProcessAfterInitialization</span></span><br><span class="line">								object = postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">								<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(beanName,</span><br><span class="line">										<span class="string">&quot;Post-processing of FactoryBean&#x27;s singleton object failed&quot;</span>, ex);</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">finally</span> &#123;</span><br><span class="line">								afterSingletonCreation(beanName);</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="comment">// 丢入缓存</span></span><br><span class="line">						<span class="keyword">if</span> (containsSingleton(beanName)) &#123;</span><br><span class="line">							<span class="built_in">this</span>.factoryBeanObjectCache.put(beanName, object);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> object;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 这里是处理 prototype 类型的 bean，所以涉及不到缓存，也就是直接调用 getObject方法</span></span><br><span class="line">			<span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line">			<span class="keyword">if</span> (shouldPostProcess) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					object = postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(beanName, <span class="string">&quot;Post-processing of FactoryBean&#x27;s object failed&quot;</span>, ex);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> object;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>总结下 ：</p>
<ul>
<li>如果为 <code>singleton</code> 则将 <code>getObject</code> 得到的对象放入缓存</li>
<li>如果为 <code>prototype</code> 则无需将得到的对象放入缓存</li>
<li>在得到对象后都会调用 处理器 <code>BeanProcessor#postProcessAfterInitialization</code></li>
</ul>
<p><code>doGetObjectFromFactoryBean</code> 这个方法很简单就是调用 <code>getObject</code> 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Object <span class="title function_">doGetObjectFromFactoryBean</span><span class="params">(<span class="keyword">final</span> FactoryBean&lt;?&gt; factory, <span class="keyword">final</span> String beanName)</span></span><br><span class="line">			<span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">		Object object;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="type">AccessControlContext</span> <span class="variable">acc</span> <span class="operator">=</span> getAccessControlContext();</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					object = AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) factory::getObject, acc);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line">					<span class="keyword">throw</span> pae.getException();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// 直接调用 getObject 方法</span></span><br><span class="line">				object = factory.getObject();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (FactoryBeanNotInitializedException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName, ex.toString());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(beanName, <span class="string">&quot;FactoryBean threw exception on object creation&quot;</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Do not accept a null value for a FactoryBean that&#x27;s not fully</span></span><br><span class="line">		<span class="comment">// initialized yet: Many FactoryBeans just return null then.</span></span><br><span class="line">		<span class="keyword">if</span> (object == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(</span><br><span class="line">						beanName, <span class="string">&quot;FactoryBean which is currently in creation returned null from getObject&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			object = <span class="keyword">new</span> <span class="title class_">NullBean</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> object;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>到此我们就知道了 <code>FactoryBean</code> 是个什么东西了，并且还知道其功能是什么，实际上也就和一开始所说的，它是一个工厂对象，用于生产对象的工厂<code>Bean</code> ，是个比较特殊的<code>Bean</code> 。</p>
<p>实际上在 <code>spring</code> 中定义一个属于我们自己的 <code>工厂bean</code> 也有其它更灵活的方法，也就是利用标签</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;Service&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.FactoryBeanTests$Service&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;ServiceFactoryBean&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getObject&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;ServiceFactoryBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.FactoryBeanTests$ServiceFactoryBean&quot;</span> &gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面这个配置文件可以看到 <code>ServiceFactoryBean</code> 是一个用于生产 <code>Service </code> 的工厂, 则我们只需要在 <code>Service</code> 的定义中指定 <code>Factory-bean</code> 和 <code>factory-method </code>即可</p>
<p>上述这个过程会在 实例化 <code>Instance </code> 的过程中调用，而 <code>FactoryBean</code>则是在 拿到<code>BeanFactory 的 Instance </code>后才进行处理.</p>
<p>关于上面这个例子，留作一个单独的小节进行分析.</p>
]]></content>
      <categories>
        <category>Spring-Interview</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>ClassUtils</title>
    <url>/2021/08/01/spring_analysis/utils/1.ClassUtils/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>MyBatis-Plus Controller模版</title>
    <url>/2021/08/02/template/mybatis/controller/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">##导入宏定义</span><br><span class="line">$!define</span><br><span class="line"></span><br><span class="line">##设置表后缀（宏定义）</span><br><span class="line">#setTableSuffix(<span class="string">&quot;Controller&quot;</span>)</span><br><span class="line"></span><br><span class="line">##保存文件（宏定义）</span><br><span class="line">#save(<span class="string">&quot;/controller&quot;</span>, <span class="string">&quot;Controller.java&quot;</span>)</span><br><span class="line"></span><br><span class="line">##包路径（宏定义）</span><br><span class="line">#setPackageSuffix(<span class="string">&quot;controller&quot;</span>)</span><br><span class="line"></span><br><span class="line">##定义服务名</span><br><span class="line">#set($serviceName = $!tool.append($!tool.firstLowerCase($!tableInfo.name), <span class="string">&quot;Service&quot;</span>))</span><br><span class="line"></span><br><span class="line">##定义实体对象名</span><br><span class="line">#set($entityName = $!tool.firstLowerCase($!tableInfo.name))</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> $!&#123;tableInfo.savePackageName&#125;.pojo.$!tableInfo.name;</span><br><span class="line"><span class="keyword">import</span> $!&#123;tableInfo.savePackageName&#125;.service.$!&#123;tableInfo.name&#125;Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.Api;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line">##表注释（宏定义）</span><br><span class="line">#tableComment(<span class="string">&quot;表控制层&quot;</span>)</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;$!tool.firstLowerCase($!tableInfo.name)&quot;)</span></span><br><span class="line"><span class="meta">@Api(&quot;视图$!&#123;tableName&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">$</span>!&#123;tableName&#125; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> $!&#123;tableInfo.name&#125;Service $!&#123;serviceName&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分页查询所有数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> page 分页对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $!entityName 查询实体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 所有数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;分页查询所有数据&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ApiResult <span class="title function_">selectAll</span><span class="params">(Page&lt;$!tableInfo.name&gt; page, $!tableInfo.name $!entityName)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过主键查询单条数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 主键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 单条数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;通过主键查询单条数据&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ApiResult <span class="title function_">selectOne</span><span class="params">(<span class="meta">@PathVariable</span> </span></span><br><span class="line"><span class="params">                               <span class="meta">@ApiParam(&quot;主键&quot;)</span> Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $!entityName 实体对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 新增结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;新增数据&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ApiResult <span class="title function_">insert</span><span class="params">(<span class="meta">@RequestBody</span> $!tableInfo.name $!entityName)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $!entityName 实体对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 修改结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PutMapping</span></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;修改数据&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ApiResult <span class="title function_">update</span><span class="params">(<span class="meta">@RequestBody</span> $!tableInfo.name $!entityName)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> idList 主键结合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 删除结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@DeleteMapping</span></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;删除数据&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ApiResult <span class="title function_">delete</span><span class="params">(<span class="meta">@RequestParam(value= &quot;idList&quot;, required = true)</span></span></span><br><span class="line"><span class="params">                            <span class="meta">@ApiParam(&quot;主键集合&quot;)</span> List&lt;Long&gt; idList)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Template</category>
      </categories>
      <tags>
        <tag>EasyCode</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis-Plus DAO模版</title>
    <url>/2021/08/02/template/mybatis/dao/</url>
    <content><![CDATA[   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">##定义初始变量</span><br><span class="line">#set($tableName = $tool.append($tableInfo.name, <span class="string">&quot;Mapper&quot;</span>))</span><br><span class="line">##设置回调</span><br><span class="line">$!callback.setFileName($tool.append($tableName, <span class="string">&quot;.java&quot;</span>))</span><br><span class="line">$!callback.setSavePath($tool.append($tableInfo.savePath, <span class="string">&quot;/mapper&quot;</span>))</span><br><span class="line"></span><br><span class="line">##拿到主键</span><br><span class="line">#<span class="keyword">if</span>(!$tableInfo.pkColumn.isEmpty())</span><br><span class="line">    #set($pk = $tableInfo.pkColumn.get(<span class="number">0</span>))</span><br><span class="line">#end</span><br><span class="line"></span><br><span class="line">#<span class="keyword">if</span>($tableInfo.savePackageName)<span class="keyword">package</span> $!&#123;tableInfo.savePackageName&#125;.mapper#&#123;end&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> $!&#123;tableInfo.savePackageName&#125;.pojo.$!&#123;tableInfo.name&#125;;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Param;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * $!&#123;tableInfo.comment&#125;($!&#123;tableInfo.name&#125;)表数据库访问层</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> $!author</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> $!time.currTime()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">$</span>!&#123;tableName&#125; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过ID查询单条数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $!pk.name 主键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 实例对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    $!&#123;tableInfo.name&#125; queryById($!pk.shortType $!pk.name);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 查询所有实体数据</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 对象列表</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    List&lt;$!&#123;tableInfo.name&#125;&gt; queryList();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过实体作为筛选条件查询</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) 实例对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 对象列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;$!&#123;tableInfo.name&#125;&gt; queryAll($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) 实例对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 影响行数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">insertOne</span><span class="params">($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) 实例对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 影响行数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">update</span><span class="params">($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过主键删除数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $!pk.name 主键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 影响行数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteById</span><span class="params">($!pk.shortType $!pk.name)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量插入数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)List 数据列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 影响行数</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="type">int</span> <span class="title function_">batchInsert</span><span class="params">(<span class="meta">@Param(&quot;$!tool.firstLowerCase($!&#123;tableInfo.name&#125;)List&quot;)</span> List&lt;$!&#123;tableInfo.name&#125;&gt; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)</span>List);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据主键列表批量查询数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)IdList 主键列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 查询结果List</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    List&lt;$!&#123;tableInfo.name&#125;&gt; batchQueryByIdList(<span class="meta">@Param(&quot;$!tool.firstLowerCase($!&#123;tableInfo.name&#125;)IdList&quot;)</span> List&lt;$!pk.shortType&gt; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)IdList);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据主键列表批量删除数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)IdList 主键列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 影响行数</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="type">int</span> <span class="title function_">batchDeleteByIdList</span><span class="params">(<span class="meta">@Param(&quot;$!tool.firstLowerCase($!&#123;tableInfo.name&#125;)IdList&quot;)</span> List&lt;$!pk.shortType&gt; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)</span>IdList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Template</category>
      </categories>
      <tags>
        <tag>EasyCode</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis-Plus Entity模版</title>
    <url>/2021/08/02/template/mybatis/entity/</url>
    <content><![CDATA[   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">###Entity</span><br><span class="line"></span><br><span class="line">##导入宏定义</span><br><span class="line">$!define</span><br><span class="line"></span><br><span class="line">##保存文件（宏定义）</span><br><span class="line">#save(<span class="string">&quot;/pojo&quot;</span>, <span class="string">&quot;.java&quot;</span>)</span><br><span class="line"></span><br><span class="line">##包路径（宏定义）</span><br><span class="line">#setPackageSuffix(<span class="string">&quot;pojo&quot;</span>)</span><br><span class="line"></span><br><span class="line">##自动导入包（全局变量）</span><br><span class="line">$!autoImport</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line">##表注释（宏定义）</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ($!&#123;tableInfo.name&#125;)表实体类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> $!author</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> $!time.currTime()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">$</span>!&#123;tableInfo.name&#125; <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line">#foreach($column in $tableInfo.fullColumn)</span><br><span class="line"></span><br><span class="line">#<span class="keyword">if</span>($&#123;column.comment&#125;)</span><br><span class="line">#end</span><br><span class="line">    <span class="keyword">private</span> $!&#123;tool.getClsNameByFullName($column.type)&#125; $!&#123;column.name&#125;;</span><br><span class="line">#end</span><br><span class="line">#foreach($column in $tableInfo.fullColumn)</span><br><span class="line">    #getSetMethod($column)</span><br><span class="line">#end</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Template</category>
      </categories>
      <tags>
        <tag>EasyCode</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis-Plus Mapper模版</title>
    <url>/2021/08/02/template/mybatis/mapper/</url>
    <content><![CDATA[   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">##引入mybatis支持</span><br><span class="line">$!mybatisSupport</span><br><span class="line"></span><br><span class="line">##设置保存名称与保存位置</span><br><span class="line">$!callback.setFileName($tool.append($!&#123;tableInfo.name&#125;, <span class="string">&quot;Mapper.xml&quot;</span>))</span><br><span class="line">$!callback.setSavePath($tool.append($tableInfo.savePath, <span class="string">&quot;/mapper&quot;</span>))</span><br><span class="line"></span><br><span class="line">##拿到主键</span><br><span class="line">#<span class="keyword">if</span>(!$tableInfo.pkColumn.isEmpty())</span><br><span class="line">    #set($pk = $tableInfo.pkColumn.get(<span class="number">0</span>))</span><br><span class="line">#end</span><br><span class="line"></span><br><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="line">&lt;mapper namespace=<span class="string">&quot;$!&#123;tableInfo.savePackageName&#125;.mapper.$!&#123;tableInfo.name&#125;Mapper&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;resultMap type=<span class="string">&quot;$!&#123;tableInfo.savePackageName&#125;.pojo.$!&#123;tableInfo.name&#125;&quot;</span> id=<span class="string">&quot;$!&#123;tableInfo.name&#125;Map&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">#foreach($column in $tableInfo.fullColumn)</span><br><span class="line">        &lt;result property=<span class="string">&quot;$!column.name&quot;</span> column=<span class="string">&quot;$!column.obj.name&quot;</span> jdbcType=<span class="string">&quot;$!column.ext.jdbcType&quot;</span>/&gt;</span><br><span class="line">#end</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--查询单个--&gt;</span><br><span class="line">    &lt;select id=<span class="string">&quot;queryById&quot;</span> resultMap=<span class="string">&quot;$!&#123;tableInfo.name&#125;Map&quot;</span>&gt;</span><br><span class="line">        SELECT</span><br><span class="line">          #allSqlColumn()</span><br><span class="line">    </span><br><span class="line">        FROM $!tableInfo.obj.name</span><br><span class="line">        WHERE $!pk.obj.name = #&#123;$!pk.name&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!--通过实体作为筛选条件查询--&gt;</span><br><span class="line">    &lt;select id=<span class="string">&quot;queryAll&quot;</span> resultMap=<span class="string">&quot;$!&#123;tableInfo.name&#125;Map&quot;</span>&gt;</span><br><span class="line">        SELECT</span><br><span class="line">          #allSqlColumn()</span><br><span class="line">    </span><br><span class="line">        FROM $!tableInfo.obj.name</span><br><span class="line">        &lt;where&gt;</span><br><span class="line"></span><br><span class="line">#foreach($column in $tableInfo.fullColumn)</span><br><span class="line">            &lt;<span class="keyword">if</span> test=<span class="string">&quot;$!column.name != null#if($column.type.equals(&quot;</span>java.lang.String<span class="string">&quot;)) and $!column.name != &#x27;&#x27;#end&quot;</span>&gt;</span><br><span class="line">                AND $!column.obj.name = #&#123;$!column.name&#125;</span><br><span class="line">            &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">#end</span><br><span class="line">        &lt;/where&gt;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--查询列表--&gt;</span><br><span class="line">    &lt;select id=<span class="string">&quot;queryList&quot;</span> resultMap=<span class="string">&quot;$!&#123;tableInfo.name&#125;Map&quot;</span>&gt;</span><br><span class="line">        SELECT #allSqlColumn() FROM $!tableInfo.obj.name</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!--新增所有列--&gt;</span><br><span class="line">    &lt;insert id=<span class="string">&quot;insertOne&quot;</span> keyProperty=<span class="string">&quot;$!pk.name&quot;</span> useGeneratedKeys=<span class="string">&quot;true&quot;</span>&gt;</span><br><span class="line">        INSERT INTO $!&#123;tableInfo.obj.name&#125;(#foreach($column in $tableInfo.otherColumn)$!column.obj.name#<span class="keyword">if</span>($velocityHasNext), #end#end)</span><br><span class="line">        VALUES (#foreach($column in $tableInfo.otherColumn)#&#123;$!&#123;column.name&#125;&#125;#<span class="keyword">if</span>($velocityHasNext), #end#end)</span><br><span class="line">    &lt;/insert&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!--通过主键修改数据--&gt;</span><br><span class="line">    &lt;update id=<span class="string">&quot;update&quot;</span>&gt;</span><br><span class="line">        UPDATE $!&#123;tableInfo.obj.name&#125;</span><br><span class="line">        &lt;set&gt;</span><br><span class="line"></span><br><span class="line">#foreach($column in $tableInfo.otherColumn)</span><br><span class="line">            &lt;<span class="keyword">if</span> test=<span class="string">&quot;$!column.name != null#if($column.type.equals(&quot;</span>java.lang.String<span class="string">&quot;)) and $!column.name != &#x27;&#x27;#end&quot;</span>&gt;</span><br><span class="line">                $!column.obj.name = #&#123;$!column.name&#125;,</span><br><span class="line">            &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">#end</span><br><span class="line">        &lt;/set&gt;</span><br><span class="line">        WHERE $!pk.obj.name = #&#123;$!pk.name&#125;</span><br><span class="line">    &lt;/update&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--通过主键删除--&gt;</span><br><span class="line">    &lt;delete id=<span class="string">&quot;deleteById&quot;</span>&gt;</span><br><span class="line">        DELETE FROM $!&#123;tableInfo.obj.name&#125; WHERE $!pk.obj.name = #&#123;$!pk.name&#125;</span><br><span class="line">    &lt;/delete&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!--批量插入--&gt;</span><br><span class="line">    &lt;insert id=<span class="string">&quot;batchInsert&quot;</span> keyProperty=<span class="string">&quot;$!pk.name&quot;</span> useGeneratedKeys=<span class="string">&quot;true&quot;</span>&gt;</span><br><span class="line">        INSERT INTO $!&#123;tableInfo.obj.name&#125;(#foreach($column in $tableInfo.otherColumn)$!column.obj.name#<span class="keyword">if</span>($velocityHasNext), #end#end)</span><br><span class="line">        VALUES </span><br><span class="line">        &lt;<span class="type">foreach</span> <span class="variable">collection</span> <span class="operator">=</span> <span class="string">&quot;$!tool.firstLowerCase($!&#123;tableInfo.name&#125;)List&quot;</span> item = <span class="string">&quot;$!tool.firstLowerCase($!&#123;tableInfo.name&#125;)&quot;</span> index = <span class="string">&quot;index&quot;</span> separator=<span class="string">&quot;,&quot;</span> &gt;</span><br><span class="line">            (#foreach($column in $tableInfo.otherColumn)#&#123;$!tool.firstLowerCase($!&#123;tableInfo.name&#125;).$!&#123;column.name&#125;&#125;#<span class="keyword">if</span>($velocityHasNext), #end#end)</span><br><span class="line">        &lt;/foreach&gt;</span><br><span class="line">    &lt;/insert&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!--根据主键批量查询--&gt;</span><br><span class="line">    &lt;select id=<span class="string">&quot;batchQueryByIdList&quot;</span> resultMap=<span class="string">&quot;$!&#123;tableInfo.name&#125;Map&quot;</span>&gt;</span><br><span class="line">        SELECT</span><br><span class="line">          #allSqlColumn()</span><br><span class="line">          </span><br><span class="line">        FROM $!tableInfo.obj.name</span><br><span class="line">        WHERE $!pk.obj.name</span><br><span class="line">        IN</span><br><span class="line">        &lt;<span class="type">foreach</span> <span class="variable">collection</span> <span class="operator">=</span> <span class="string">&quot;$!tool.firstLowerCase($!&#123;tableInfo.name&#125;)IdList&quot;</span> item = <span class="string">&quot;$!tool.firstLowerCase($!&#123;tableInfo.name&#125;)Id&quot;</span> index = <span class="string">&quot;index&quot;</span> open = <span class="string">&quot;(&quot;</span> close = <span class="string">&quot;)&quot;</span> separator = <span class="string">&quot;,&quot;</span>&gt;</span><br><span class="line">            #&#123;$!tool.firstLowerCase($!&#123;tableInfo.name&#125;)Id&#125;</span><br><span class="line">        &lt;/foreach&gt;</span><br><span class="line">    &lt;/select&gt; </span><br><span class="line">    </span><br><span class="line">    &lt;!--根据主键批量删除--&gt;</span><br><span class="line">    &lt;delete id=<span class="string">&quot;batchDeleteByIdList&quot;</span>&gt;</span><br><span class="line">        DELETE FROM $!&#123;tableInfo.obj.name&#125; </span><br><span class="line">        WHERE $!pk.obj.name</span><br><span class="line">        IN</span><br><span class="line">        &lt;<span class="type">foreach</span> <span class="variable">collection</span> <span class="operator">=</span> <span class="string">&quot;$!tool.firstLowerCase($!&#123;tableInfo.name&#125;)IdList&quot;</span> item = <span class="string">&quot;$!tool.firstLowerCase($!&#123;tableInfo.name&#125;)Id&quot;</span> index = <span class="string">&quot;index&quot;</span> open = <span class="string">&quot;(&quot;</span> close = <span class="string">&quot;)&quot;</span> separator = <span class="string">&quot;,&quot;</span>&gt;</span><br><span class="line">            #&#123;$!tool.firstLowerCase($!&#123;tableInfo.name&#125;)Id&#125;</span><br><span class="line">        &lt;/foreach&gt; </span><br><span class="line">    &lt;/delete&gt; </span><br><span class="line">    </span><br><span class="line">    &lt;!--——————————————————————————————————————————————————————————————————————————————————————————--&gt;</span><br><span class="line"></span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Template</category>
      </categories>
      <tags>
        <tag>EasyCode</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis-Plus Service模版</title>
    <url>/2021/08/02/template/mybatis/service/</url>
    <content><![CDATA[   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">##定义初始变量</span><br><span class="line">#set($tableName = $tool.append($tableInfo.name, <span class="string">&quot;Service&quot;</span>))</span><br><span class="line">##设置回调</span><br><span class="line">$!callback.setFileName($tool.append($tableName, <span class="string">&quot;.java&quot;</span>))</span><br><span class="line">$!callback.setSavePath($tool.append($tableInfo.savePath, <span class="string">&quot;/service&quot;</span>))</span><br><span class="line"></span><br><span class="line">##拿到主键</span><br><span class="line">#<span class="keyword">if</span>(!$tableInfo.pkColumn.isEmpty())</span><br><span class="line">    #set($pk = $tableInfo.pkColumn.get(<span class="number">0</span>))</span><br><span class="line">#end</span><br><span class="line"></span><br><span class="line">#<span class="keyword">if</span>($tableInfo.savePackageName)<span class="keyword">package</span> $!&#123;tableInfo.savePackageName&#125;#&#123;end&#125;.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> $!&#123;tableInfo.savePackageName&#125;.pojo.$!&#123;tableInfo.name&#125;;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> com.github.pagehelper.PageHelper;</span><br><span class="line"><span class="keyword">import</span> com.github.pagehelper.PageInfo;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * $!&#123;tableInfo.comment&#125;($!&#123;tableInfo.name&#125;)表服务接口</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> $!author</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> $!time.currTime()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">$</span>!&#123;tableName&#125; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过ID查询单条数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $!pk.name 主键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 实例对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    $!&#123;tableInfo.name&#125; queryById($!pk.shortType $!pk.name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) 实例对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 插入是否成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">insertOne</span><span class="params">($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) 实例对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 更新是否成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">update</span><span class="params">($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过主键删除数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $!pk.name 主键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">deleteById</span><span class="params">($!pk.shortType $!pk.name)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量插入数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)List 数据列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否插入成功</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">batchInsert</span><span class="params">(List&lt;$!&#123;tableInfo.name&#125;&gt; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)</span>List);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据主键列表批量查询数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)IdList 主键列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 查询结果List</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    List&lt;$!&#123;tableInfo.name&#125;&gt; batchQueryByIdList(List&lt;$!pk.shortType&gt; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)IdList);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据主键列表批量删除数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)IdList 主键列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否删除成功</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">batchDeleteByIdList</span><span class="params">(List&lt;$!pk.shortType&gt; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)</span>IdList);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过实体作为筛选条件查询, 查询所有数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) 实例对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 对象列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;$!&#123;tableInfo.name&#125;&gt; queryAllBySelective($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 条件筛选性分页查询所有数据</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pageNumber 开始页</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pageSize 页大小</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryCondition 条件查询实体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 分页结果</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    PageInfo&lt;$!&#123;tableInfo.name&#125;&gt; pagingSelectiveQueryAll(Integer pageNumber,Integer pageSize,$!&#123;tableInfo.name&#125; queryCondition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Template</category>
      </categories>
      <tags>
        <tag>EasyCode</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis-Plus ServiceImpl模版</title>
    <url>/2021/08/02/template/mybatis/serviceImpl/</url>
    <content><![CDATA[   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">##定义初始变量</span><br><span class="line">#set($tableName = $tool.append($tableInfo.name, <span class="string">&quot;ServiceImpl&quot;</span>))</span><br><span class="line">##设置回调</span><br><span class="line">$!callback.setFileName($tool.append($tableName, <span class="string">&quot;.java&quot;</span>))</span><br><span class="line">$!callback.setSavePath($tool.append($tableInfo.savePath, <span class="string">&quot;/service/impl&quot;</span>))</span><br><span class="line"></span><br><span class="line">##拿到主键</span><br><span class="line">#<span class="keyword">if</span>(!$tableInfo.pkColumn.isEmpty())</span><br><span class="line">    #set($pk = $tableInfo.pkColumn.get(<span class="number">0</span>))</span><br><span class="line">#end</span><br><span class="line"></span><br><span class="line">#<span class="keyword">if</span>($tableInfo.savePackageName)<span class="keyword">package</span> $!&#123;tableInfo.savePackageName&#125;.#&#123;end&#125;service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> $!&#123;tableInfo.savePackageName&#125;.pojo.$!&#123;tableInfo.name&#125;;</span><br><span class="line"><span class="keyword">import</span> $!&#123;tableInfo.savePackageName&#125;.mapper.$!&#123;tableInfo.name&#125;Mapper;</span><br><span class="line"><span class="keyword">import</span> $!&#123;tableInfo.savePackageName&#125;.service.$!&#123;tableInfo.name&#125;Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.CollectionUtils;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> com.github.pagehelper.PageHelper;</span><br><span class="line"><span class="keyword">import</span> com.github.pagehelper.PageInfo;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * $!&#123;tableInfo.comment&#125;($!&#123;tableInfo.name&#125;)表服务实现类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> $!author</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> $!time.currTime()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service(&quot;$!tool.firstLowerCase($!&#123;tableInfo.name&#125;)Service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">$</span>!&#123;tableName&#125; <span class="keyword">implements</span> <span class="title class_">$</span>!&#123;tableInfo.name&#125;Service &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> $!&#123;tableInfo.name&#125;Mapper $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)Mapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过ID查询单条数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $!pk.name 主键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 实例对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> $!&#123;tableInfo.name&#125; queryById($!pk.shortType $!pk.name) &#123;</span><br><span class="line">        <span class="keyword">return</span> $!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;Mapper.queryById($!pk.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) 实例对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 插入是否成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">insertOne</span><span class="params">($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> $!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;Mapper.insertOne($!tool.firstLowerCase($!&#123;tableInfo.name&#125;)) == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) 实例对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 更新是否成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">update</span><span class="params">($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> $!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;Mapper.update($!tool.firstLowerCase($!&#123;tableInfo.name&#125;)) == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过主键删除数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $!pk.name 主键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deleteById</span><span class="params">($!pk.shortType $!pk.name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> $!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;Mapper.deleteById($!pk.name) == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量插入数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)List 数据列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否插入成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">batchInsert</span><span class="params">(List&lt;$!&#123;tableInfo.name&#125;&gt; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)</span>List)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!CollectionUtils.isEmpty($!tool.firstLowerCase($!&#123;tableInfo.name&#125;)List)) &#123;</span><br><span class="line">           <span class="keyword">return</span> $!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;Mapper.batchInsert($!tool.firstLowerCase($!&#123;tableInfo.name&#125;)List) == $tool.append($!tool.firstLowerCase($!&#123;tableInfo.name&#125;),<span class="string">&quot;List.size()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据主键列表批量查询数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)IdList 主键列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 查询结果List</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;$!&#123;tableInfo.name&#125;&gt; batchQueryByIdList(List&lt;$!pk.shortType&gt; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)IdList)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!CollectionUtils.isEmpty($!tool.firstLowerCase($!&#123;tableInfo.name&#125;)IdList)) &#123;</span><br><span class="line">           <span class="keyword">return</span> $!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;Mapper.batchQueryByIdList($!tool.firstLowerCase($!&#123;tableInfo.name&#125;)IdList);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据主键列表批量删除数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)IdList 主键列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否删除成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">batchDeleteByIdList</span><span class="params">(List&lt;$!pk.shortType&gt; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)</span>IdList)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!CollectionUtils.isEmpty($!tool.firstLowerCase($!&#123;tableInfo.name&#125;)IdList)) &#123;</span><br><span class="line">           <span class="keyword">return</span> $!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;Mapper.batchDeleteByIdList($!tool.firstLowerCase($!&#123;tableInfo.name&#125;)IdList) == $tool.append($!tool.firstLowerCase($!&#123;tableInfo.name&#125;),<span class="string">&quot;IdList.size()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过实体作为筛选条件查询, 查询所有数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) 实例对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 对象列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;$!&#123;tableInfo.name&#125;&gt; queryAllBySelective($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;))&#123;</span><br><span class="line">        <span class="keyword">return</span> $!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;Mapper.queryAll($!tool.firstLowerCase($!&#123;tableInfo.name&#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 条件筛选性分页查询所有数据</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pageNumber 开始页</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pageSize 页大小</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryCondition 条件查询实体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 分页结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> PageInfo&lt;$!&#123;tableInfo.name&#125;&gt; pagingSelectiveQueryAll(Integer pageNumber,Integer pageSize,$!&#123;tableInfo.name&#125; queryCondition)&#123;</span><br><span class="line">        PageHelper.startPage(pageNumber, pageSize);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageInfo</span>&lt;$!&#123;tableInfo.name&#125;&gt;($!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;Mapper.queryAll(queryCondition));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Template</category>
      </categories>
      <tags>
        <tag>EasyCode</tag>
      </tags>
  </entry>
  <entry>
    <title>1.factory-method 和 factory-bean的实现原理</title>
    <url>/2021/08/02/spring_analysis/beans/functionality/1.factory-method%E5%92%8Cfactory-bean%20%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>##factory-method 和 factory-bean的实现</p>
<p>在讨论实现原理之前，得先清楚怎么用，这两个东西.</p>
<p>假设目前有两个类 <code>ServiceFactory</code> 和 <code>Service</code> 我们就可以指定 <code>factory-method</code> 和 <code>factory-bean</code> 给 <code>Service</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;Service&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.FactoryBeanTests$Service&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;ServiceFactoryBean&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getObject&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;ServiceFactoryBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.FactoryBeanTests$ServiceFactoryBean&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上述的意思就是，当我们<code>getBean</code> <code>Service</code> 的时候，会从 <code>ServiceFactory</code>的 <code>getObject</code> 方法中获取 <code>Service</code></p>
<p>所以应该会分成两个过程 ：</p>
<ul>
<li>先获取 <code>ServiceFactory</code> 实例</li>
<li>调用<code>ServiceFactory</code>的  <code>getObject</code></li>
</ul>
<p>实际上获取从<code>ServiceFactory</code>中获取 <code>Service</code>，就相当于把 <code>ServiceFactory</code>当成是 <code>FactoryBean</code> ，只是这样做的话可以允许程序员自定义自己的<code>factory-method</code>罢了，因为 <code>FactoryBean</code>的话就要继承接口，工厂方法也就被定下来了。</p>
<hr>
<p><strong>原理部分</strong></p>
<p>因为这一小节只是详解 <code>factory-method</code> 和 <code>factory-bean</code> 的原理部分，所以源码只会截取一部分，若想要完整，那就到 <code>beans</code> 文件夹中查看详解部分.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> BeanWrapper <span class="title function_">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span> &#123;</span><br><span class="line">		<span class="comment">/**------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">		 * [DESC] 创建bean 实例</span></span><br><span class="line"><span class="comment">		 * [1] 判断类是不是 public</span></span><br><span class="line"><span class="comment">		 * [2] 判断是否提供了工厂方法，若有，则调用 &#123;<span class="doctag">@link</span> #instantiateUsingFactoryMethod&#125;</span></span><br><span class="line"><span class="comment">		 * [3] 判断是否提供了构造函数，若有，则调用 &#123;<span class="doctag">@link</span> #autowireConstructor&#125;</span></span><br><span class="line"><span class="comment">		 * [4] 两者都不提供，则直接调用默认构造函数 &#123;<span class="doctag">@link</span> #instantiateBean&#125;</span></span><br><span class="line"><span class="comment">		 *------------------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 确保class已经被解析</span></span><br><span class="line">		Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">		<span class="comment">// 判断Class是不是公开的，有没有访问权限</span></span><br><span class="line">		<span class="keyword">if</span> (beanClass != <span class="literal">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">					<span class="string">&quot;Bean class isn&#x27;t public, and non-public access not allowed: &quot;</span> + beanClass.getName());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取 Instance 提供者</span></span><br><span class="line">		Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();</span><br><span class="line">		<span class="keyword">if</span> (instanceSupplier != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 若存在Instance提供者，就直接调用提供者方法然后得到Instance</span></span><br><span class="line">			<span class="comment">// [TODO] 我还不知道能不能把一个工厂Bean 当作提供者,但在下面是可以指名这个Bean是一个FactoryBean然后调用工厂方法</span></span><br><span class="line">			<span class="keyword">return</span> obtainFromSupplier(instanceSupplier, beanName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// [DESC] 若提供了工厂方法，则调用工厂方法拿到Instance</span></span><br><span class="line">		<span class="comment">// factory-method=&quot;getXXX&quot;</span></span><br><span class="line">		<span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 调用工厂方法实例化对象</span></span><br><span class="line">			<span class="keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法是用于创建 <code>beanInstance</code> 的，前面部分都是校验用的，核心看最后那一句,  当我们在定义 <code>bean</code>的时候 <code>factory-method</code> 的时候，就是成立那个条件，然后执行 <code>instantiateUsingFactoryMethod</code> ,step in</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> BeanWrapper <span class="title function_">instantiateUsingFactoryMethod</span><span class="params">(</span></span><br><span class="line"><span class="params">			String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] explicitArgs)</span> &#123;</span><br><span class="line">		<span class="comment">/**------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">		 * [DESC] 用工厂方法实例化Bean</span></span><br><span class="line"><span class="comment">		 * [1] 在bean定义，若使用属性 factory-method= 来指定工厂方法，则方法必须为 static, 然后解析工厂工厂方法</span></span><br><span class="line"><span class="comment">		 * 若方法只有一个参数，并且方法没有参数，则直接调用&#123;<span class="doctag">@link</span> #instantiate(String, RootBeanDefinition, Object, Method, Object[])&#125;</span></span><br><span class="line"><span class="comment">		 * 其内部直接调用工厂方法获取 Instance</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * [2] 如果对一个bean 指定了 factory-bean 和 factory-method，则说明该bean的 instance交给 指定的factory-bean来实例化,</span></span><br><span class="line"><span class="comment">		 * 和上面差不多的，只是上面这个它自身bean就是工厂，自身就提供了工厂方法，现在这种情况是委托一个factory负责实例化</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * [3] TODO 多factory 和 多参数 有待研究</span></span><br><span class="line"><span class="comment">		 *------------------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line">		<span class="type">BeanWrapperImpl</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanWrapperImpl</span>();</span><br><span class="line">		<span class="built_in">this</span>.beanFactory.initBeanWrapper(bw);</span><br><span class="line"></span><br><span class="line">		Object factoryBean;</span><br><span class="line">		Class&lt;?&gt; factoryClass;</span><br><span class="line">		<span class="type">boolean</span> isStatic;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// [1] 若指定了 factory-bean=</span></span><br><span class="line">		<span class="comment">// 则根据 factory-bean 提供的工厂类，调用getBean拿到FactoryBean Instance</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">factoryBeanName</span> <span class="operator">=</span> mbd.getFactoryBeanName();</span><br><span class="line">		<span class="keyword">if</span> (factoryBeanName != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (factoryBeanName.equals(beanName)) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">						<span class="string">&quot;factory-bean reference points back to the same bean definition&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 拿到 Factorybean instance</span></span><br><span class="line">			factoryBean = <span class="built_in">this</span>.beanFactory.getBean(factoryBeanName);</span><br><span class="line">			<span class="keyword">if</span> (mbd.isSingleton() &amp;&amp; <span class="built_in">this</span>.beanFactory.containsSingleton(beanName)) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ImplicitlyAppearedSingletonException</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			factoryClass = factoryBean.getClass();</span><br><span class="line">			isStatic = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// [2] 这里没指定 factory-bean，只指定了 factory-method，则该方法必须为 静态方法</span></span><br><span class="line">			<span class="keyword">if</span> (!mbd.hasBeanClass()) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">						<span class="string">&quot;bean definition declares neither a bean class nor a factory-bean reference&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 静态方法不需要instance</span></span><br><span class="line">			factoryBean = <span class="literal">null</span>;</span><br><span class="line">			factoryClass = mbd.getBeanClass();</span><br><span class="line">			isStatic = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// [2] 解析FactoryBean的参数</span></span><br><span class="line">		<span class="type">Method</span> <span class="variable">factoryMethodToUse</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="type">ArgumentsHolder</span> <span class="variable">argsHolderToUse</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		Object[] argsToUse = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// [3] 尝试从缓存中拿到 factory method 和 args</span></span><br><span class="line">		<span class="keyword">if</span> (explicitArgs != <span class="literal">null</span>) &#123;</span><br><span class="line">			argsToUse = explicitArgs;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			Object[] argsToResolve = <span class="literal">null</span>;</span><br><span class="line">			<span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">				factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;</span><br><span class="line">				<span class="keyword">if</span> (factoryMethodToUse != <span class="literal">null</span> &amp;&amp; mbd.constructorArgumentsResolved) &#123;</span><br><span class="line">					<span class="comment">// Found a cached factory method...</span></span><br><span class="line">					argsToUse = mbd.resolvedConstructorArguments;</span><br><span class="line">					<span class="keyword">if</span> (argsToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">						argsToResolve = mbd.preparedConstructorArguments;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (argsToResolve != <span class="literal">null</span>) &#123;</span><br><span class="line">				argsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve, <span class="literal">true</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// [3] 从缓存中找不到那就只能解析了</span></span><br><span class="line">		<span class="keyword">if</span> (factoryMethodToUse == <span class="literal">null</span> || argsToUse == <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Need to determine the factory method...</span></span><br><span class="line">			<span class="comment">// Try all methods with this name to see if they match the given arguments.</span></span><br><span class="line">			factoryClass = ClassUtils.getUserClass(factoryClass);</span><br><span class="line"></span><br><span class="line">			List&lt;Method&gt; candidateList = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Note 从缓存数据中，判断这个工厂是不是只有一个工厂</span></span><br><span class="line">			<span class="keyword">if</span> (mbd.isFactoryMethodUnique) &#123;</span><br><span class="line">				<span class="keyword">if</span> (factoryMethodToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">					<span class="comment">// 从缓存中直接获取已经解析好的工厂方法</span></span><br><span class="line">					factoryMethodToUse = mbd.getResolvedFactoryMethod();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (factoryMethodToUse != <span class="literal">null</span>) &#123;</span><br><span class="line">					<span class="comment">// 转换为list</span></span><br><span class="line">					candidateList = Collections.singletonList(factoryMethodToUse);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Note 直接遍历类中的所有方法</span></span><br><span class="line">			<span class="keyword">if</span> (candidateList == <span class="literal">null</span>) &#123;</span><br><span class="line">				candidateList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">				Method[] rawCandidates = getCandidateMethods(factoryClass, mbd);</span><br><span class="line">				<span class="keyword">for</span> (Method candidate : rawCandidates) &#123;</span><br><span class="line">					<span class="comment">// Note 方法一定要是静态方法，并且是工厂方法</span></span><br><span class="line">					<span class="comment">// Note: isFactoryMethod 负责对 factory-method指定的值比较</span></span><br><span class="line">					<span class="keyword">if</span> (Modifier.isStatic(candidate.getModifiers()) == isStatic &amp;&amp; mbd.isFactoryMethod(candidate)) &#123;</span><br><span class="line">						candidateList.add(candidate);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Note 一个工厂方法，并且无参数,这种应该是最常用的吧</span></span><br><span class="line">			<span class="keyword">if</span> (candidateList.size() == <span class="number">1</span> &amp;&amp; explicitArgs == <span class="literal">null</span> &amp;&amp; !mbd.hasConstructorArgumentValues()) &#123;</span><br><span class="line">				<span class="type">Method</span> <span class="variable">uniqueCandidate</span> <span class="operator">=</span> candidateList.get(<span class="number">0</span>);</span><br><span class="line">				<span class="comment">// Note 缓存已经解析的数据</span></span><br><span class="line">				<span class="keyword">if</span> (uniqueCandidate.getParameterCount() == <span class="number">0</span>) &#123;</span><br><span class="line">					mbd.factoryMethodToIntrospect = uniqueCandidate;</span><br><span class="line">					<span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">						mbd.resolvedConstructorOrFactoryMethod = uniqueCandidate;</span><br><span class="line">						mbd.constructorArgumentsResolved = <span class="literal">true</span>;</span><br><span class="line">						mbd.resolvedConstructorArguments = EMPTY_ARGS;</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					<span class="comment">// Note 在这里直接调用工厂方法就完事了</span></span><br><span class="line">					bw.setBeanInstance(instantiate(beanName, mbd, factoryBean, uniqueCandidate, EMPTY_ARGS));</span><br><span class="line">					<span class="keyword">return</span> bw;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Note 如果执行到这里，说明有多个工厂方法，或者工厂方法带参数</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在bean定义，若使用属性 factory-method= 来指定工厂方法，则方法必须为 static, 然后解析工厂方法，若方法只有一个，并且方法没有参数，则直接调用{@link #instantiate(String, RootBeanDefinition, Object, Method, Object[])}，其内部直接调用工厂方法获取 Instance</li>
<li>如果对一个bean 指定了 factory-bean 和 factory-method，则说明该bean的 instance交给 指定的factory-bean来实例化, 和上面差不多的，只是上面这个它自身bean就是工厂，自身就提供了工厂方法，现在这种情况是委托一个factory负责实例化</li>
</ul>
]]></content>
      <categories>
        <category>Spring-functionality</category>
      </categories>
      <tags>
        <tag>Spring-Bean</tag>
      </tags>
  </entry>
  <entry>
    <title>2.注解@Qualifier和@Value的实现</title>
    <url>/2021/08/02/spring_analysis/beans/functionality/2.%E6%B3%A8%E8%A7%A3@Qualifier%E5%92%8C@Value%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h3 id="前言-17">前言</h3>
<p><code>@Qualifier</code>用于注解在属性、方法、参数，指定用于修复依赖的 <code>bean</code></p>
<p><code>QualifierAnnotationAutowireCandidateResolver</code>用于支持 <code>@Qualifier</code>和 <code>@Value</code>注解</p>
<p>这得分两种情形，否则会出意外的<code>BUG</code>出现  :</p>
<ul>
<li>以<code>byType</code> 方式装配</li>
<li>使用注解 <code>Autowried</code> 装配</li>
</ul>
<p>当以<code>byType</code> 方式装配的时候，<code>@Qualifier</code> 要写在<code>setter</code> 方法或者参数上</p>
<p>当以<code>@Autowried</code>注解装配，则写在 <code>属性</code> 上</p>
<p>因为<code>byType</code> 是以 <code>setter</code> 方法进行依赖修复的</p>
<p><code>@Autowried</code> 是以属性的方式进行依赖修复</p>
<p>下面看源码一目了然</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">autowireByType</span><span class="params">(</span></span><br><span class="line"><span class="params">			String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs)</span> &#123;</span><br><span class="line">		<span class="comment">// Note 根据类型来自动装配</span></span><br><span class="line">		<span class="comment">// Note 那就必然涉及到类型的转换</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// [1] 先new 一个类型转转换器</span></span><br><span class="line">		<span class="type">TypeConverter</span> <span class="variable">converter</span> <span class="operator">=</span> getCustomTypeConverter();</span><br><span class="line">		<span class="keyword">if</span> (converter == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 如果没有就用Wrapper内置的类型转换，支持基础类型</span></span><br><span class="line">			converter = bw;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// [2] 遍历属性和装配了</span></span><br><span class="line">		Set&lt;String&gt; autowiredBeanNames = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// NOTE 在这里排除一些不满足装配条件的属性</span></span><br><span class="line">		<span class="comment">// NOTE 使用 &lt;property name=&quot;impl1&quot; ref=&quot;BEAN1&quot;/&gt; ref属性引用的bean，这个是不会被装配的</span></span><br><span class="line">		<span class="comment">// NOTE CGLIB 定义的属性也不会被装配</span></span><br><span class="line">		<span class="comment">// NOTE 简单类型是不会被装配</span></span><br><span class="line">		<span class="comment">// TODO 之所以使用 ref是因为接触循环依赖？目前还不清楚</span></span><br><span class="line">		String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);</span><br><span class="line">		<span class="keyword">for</span> (String propertyName : propertyNames) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Note 第一步肯定是获取属性的描述符</span></span><br><span class="line">				<span class="type">PropertyDescriptor</span> <span class="variable">pd</span> <span class="operator">=</span> bw.getPropertyDescriptor(propertyName);</span><br><span class="line">				<span class="comment">// Don&#x27;t try autowiring by type for type Object: never makes sense,</span></span><br><span class="line">				<span class="comment">// even if it technically is a unsatisfied, non-simple property.</span></span><br><span class="line"></span><br><span class="line">				<span class="comment">// Note 类型是 Object 就不装配，显然Object类型这没法装配</span></span><br><span class="line">				<span class="keyword">if</span> (Object.class != pd.getPropertyType()) &#123;</span><br><span class="line"></span><br><span class="line">					<span class="comment">// 获取Get方法参数</span></span><br><span class="line">					<span class="type">MethodParameter</span> <span class="variable">methodParam</span> <span class="operator">=</span> BeanUtils.getWriteMethodParameter(pd);</span><br><span class="line">					<span class="comment">// Do not allow eager init for type matching in case of a prioritized post-processor.</span></span><br><span class="line"></span><br><span class="line">					<span class="type">boolean</span> <span class="variable">eager</span> <span class="operator">=</span> !PriorityOrdered.class.isInstance(bw.getWrappedInstance());</span><br><span class="line"></span><br><span class="line">					<span class="comment">// 确认Get方法的依赖？ TODO：进去看看</span></span><br><span class="line">					<span class="type">DependencyDescriptor</span> <span class="variable">desc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AutowireByTypeDependencyDescriptor</span>(methodParam, eager);</span><br><span class="line"></span><br><span class="line">					<span class="comment">// 解析Get方法的参数依赖</span></span><br><span class="line">					<span class="comment">// NOTE 解析依赖，关键的地方了</span></span><br><span class="line">					<span class="comment">/**<span class="doctag">@see</span> DefaultListableBeanFactory#resolveDependency*/</span></span><br><span class="line">					<span class="type">Object</span> <span class="variable">autowiredArgument</span> <span class="operator">=</span> resolveDependency(desc, beanName, autowiredBeanNames, converter);</span><br></pre></td></tr></table></figure>
<p>可以看到 <code>byType</code> 修复的时候 它是 获取 <code>setter</code> 方法然后拿到其参数进行依赖修复的</p>
<p>下面看修复依赖的 一部分代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">doResolveDependency</span><span class="params">(DependencyDescriptor descriptor, <span class="meta">@Nullable</span> String beanName,</span></span><br><span class="line"><span class="params">			<span class="meta">@Nullable</span> Set&lt;String&gt; autowiredBeanNames, <span class="meta">@Nullable</span> TypeConverter typeConverter)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">  <span class="comment">// NOTICE JDK8 的 CDI ，值得和 spring 的 DI进行比较 都是进行依赖注入的东西</span></span><br><span class="line">		<span class="comment">// NOTICE JSR365 CDI 与此关联的还有 JSR299 webBean管理</span></span><br><span class="line">		<span class="type">InjectionPoint</span> <span class="variable">previousInjectionPoint</span> <span class="operator">=</span> ConstructorResolver.setCurrentInjectionPoint(descriptor);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="type">Object</span> <span class="variable">shortcut</span> <span class="operator">=</span> descriptor.resolveShortcut(<span class="built_in">this</span>);</span><br><span class="line">			<span class="keyword">if</span> (shortcut != <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> shortcut;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//</span></span><br><span class="line">			Class&lt;?&gt; type = descriptor.getDependencyType();</span><br><span class="line"></span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * NOTE 获取建议的值 &#123;<span class="doctag">@link</span> QualifierAnnotationAutowireCandidateResolver&#125; 这个支持 &#123;<span class="doctag">@link</span> Value&#125; 注解提供建议值</span></span><br><span class="line"><span class="comment">			 * NOTE factory 是 &#123;<span class="doctag">@link</span> SimpleAutowireCandidateResolver&#125; 这个是不支持提供建议值的</span></span><br><span class="line"><span class="comment">			 * NOTE 如果需要启动注解，就需要添加注册装配处理器 &#123;<span class="doctag">@link</span> AutowiredAnnotationBeanPostProcessor&#125;</span></span><br><span class="line"><span class="comment">			 * NOTE 上述这些东西是用来支持  JSR330 依赖注入注解的</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line"></span><br><span class="line">			<span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> getAutowireCandidateResolver().getSuggestedValue(descriptor);</span><br><span class="line">			<span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (value <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">					<span class="comment">// NOTE 如果注解带的值是字符串类型，这里可以扩展成支持 property 的字符串，也就是需要解析字符串</span></span><br><span class="line">					<span class="comment">// NOTE 比如 $&#123;name.val&#125; 之类的 环境变量表达式</span></span><br><span class="line">					<span class="type">String</span> <span class="variable">strVal</span> <span class="operator">=</span> resolveEmbeddedValue((String) value);</span><br><span class="line">					<span class="type">BeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> (beanName != <span class="literal">null</span> &amp;&amp; containsBean(beanName) ?</span><br><span class="line">							getMergedBeanDefinition(beanName) : <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">					<span class="comment">// NOTE 解析 Bean定义表达式，这个是在 Context才支持的，beans包不支持这个</span></span><br><span class="line">					value = evaluateBeanDefinitionString(strVal, bd);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// NOTE 类型转换</span></span><br><span class="line">				<span class="type">TypeConverter</span> <span class="variable">converter</span> <span class="operator">=</span> (typeConverter != <span class="literal">null</span> ? typeConverter : getTypeConverter());</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> converter.convertIfNecessary(value, type, descriptor.getTypeDescriptor());</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (UnsupportedOperationException ex) &#123;</span><br><span class="line">					<span class="comment">// A custom TypeConverter which does not support TypeDescriptor resolution...</span></span><br><span class="line">					<span class="keyword">return</span> (descriptor.getField() != <span class="literal">null</span> ?</span><br><span class="line">							converter.convertIfNecessary(value, type, descriptor.getField()) :</span><br><span class="line">							converter.convertIfNecessary(value, type, descriptor.getMethodParameter()));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Note 处理 集合 和 映射数据结构</span></span><br><span class="line">			<span class="type">Object</span> <span class="variable">multipleBeans</span> <span class="operator">=</span> resolveMultipleBeans(descriptor, beanName, autowiredBeanNames, typeConverter);</span><br><span class="line">			<span class="keyword">if</span> (multipleBeans != <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> multipleBeans;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Note 匹配该 type 的Class</span></span><br><span class="line">			<span class="comment">// NOTICE 在这里用于确定此属性所需要的bean名称，因为 根据类型来装配是不可靠的，因为一个类型的bean可能有多个</span></span><br><span class="line">			<span class="comment">// NOTICE 所以在这里 spring 提供了 @Qualifier(&quot;personA&quot;) 注解来限定装配哪一个名称的bean</span></span><br><span class="line">			<span class="comment">// NOTICE 如果你用xml 就可以用 ref 来引用id，或者 qualifier ，TODO 这个我没用过 哈哈</span></span><br><span class="line">			Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, type, descriptor);</span><br><span class="line">			<span class="keyword">if</span> (matchingBeans.isEmpty()) &#123;</span><br><span class="line">				<span class="keyword">if</span> (isRequired(descriptor)) &#123;</span><br><span class="line">					raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			String autowiredBeanName;</span><br><span class="line">			Object instanceCandidate;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// NOTE 在这里匹配 使用 @Qualifier 指定的 bean</span></span><br><span class="line">			<span class="keyword">if</span> (matchingBeans.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">				autowiredBeanName = determineAutowireCandidate(matchingBeans, descriptor);</span><br><span class="line">				<span class="keyword">if</span> (autowiredBeanName == <span class="literal">null</span>) &#123;</span><br><span class="line">					<span class="keyword">if</span> (isRequired(descriptor) || !indicatesMultipleBeans(type)) &#123;</span><br><span class="line">						<span class="comment">// NOTE 这里 无法修复 非限定的 bean，爆异常</span></span><br><span class="line">						<span class="keyword">return</span> descriptor.resolveNotUnique(descriptor.getResolvableType(), matchingBeans);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="comment">// In case of an optional Collection/Map, silently ignore a non-unique case:</span></span><br><span class="line">						<span class="comment">// possibly it was meant to be an empty collection of multiple regular beans</span></span><br><span class="line">						<span class="comment">// (before 4.3 in particular when we didn&#x27;t even look for collection beans).</span></span><br><span class="line">						<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				instanceCandidate = matchingBeans.get(autowiredBeanName);</span><br><span class="line">			&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>其首先尝试获取 <code>@Value</code> 注解建议的值，此注解实现过程后面会说</p>
<p><code>Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, type, descriptor);</code></p>
<p>这一行代码就是来确定，这个<code>setter</code> 方法依赖的 <code>类型</code> 是属于哪个<code>BeanDefinition</code>的如果，因为是按照类型来装配，有可能 <code>BeanDefition</code> 相同的 <code>Bean</code> 有多个，这个时候就要确定一个，如果有两个或两个以上，它是无法修复的，并且会抛异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Map&lt;String, Object&gt; <span class="title function_">findAutowireCandidates</span><span class="params">(</span></span><br><span class="line"><span class="params">			<span class="meta">@Nullable</span> String beanName, Class&lt;?&gt; requiredType, DependencyDescriptor descriptor)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// NOTE setp In</span></span><br><span class="line">		String[] candidateNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class="line">				<span class="built_in">this</span>, requiredType, <span class="literal">true</span>, descriptor.isEager());</span><br><span class="line">		Map&lt;String, Object&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(candidateNames.length);</span><br><span class="line">		<span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; classObjectEntry : <span class="built_in">this</span>.resolvableDependencies.entrySet()) &#123;</span><br><span class="line">			Class&lt;?&gt; autowiringType = classObjectEntry.getKey();</span><br><span class="line">			<span class="keyword">if</span> (autowiringType.isAssignableFrom(requiredType)) &#123;</span><br><span class="line">				<span class="type">Object</span> <span class="variable">autowiringValue</span> <span class="operator">=</span> classObjectEntry.getValue();</span><br><span class="line">				autowiringValue = AutowireUtils.resolveAutowiringValue(autowiringValue, requiredType);</span><br><span class="line">				<span class="keyword">if</span> (requiredType.isInstance(autowiringValue)) &#123;</span><br><span class="line">					result.put(ObjectUtils.identityToString(autowiringValue), autowiringValue);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (String candidate : candidateNames) &#123;</span><br><span class="line">			<span class="comment">// NOTE 调用isAutowireCandidate 来确定BEAN</span></span><br><span class="line">			<span class="keyword">if</span> (!isSelfReference(beanName, candidate) &amp;&amp; isAutowireCandidate(candidate, descriptor)) &#123;</span><br><span class="line">				addCandidateEntry(result, candidate, descriptor, requiredType);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] candidateNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class="line">				<span class="built_in">this</span>, requiredType, <span class="literal">true</span>, descriptor.isEager());</span><br></pre></td></tr></table></figure>
<p>这一句是用来获取该类型的所有<code>Bean</code> 的名称</p>
<p>然后调用  <code>isAutowireCandidate </code>判断，该名称的 <code>Bean</code> 是不是我们要的，因为有多个我们就选一个，这个时候就是 <code>@Qualifier</code> 起作用的时候，这个时候跳到<code>QualifierAnnotationAutowireCandidateResolver</code> 的 <code>isAutowireCandidate</code> 方法里面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAutowireCandidate</span><span class="params">(BeanDefinitionHolder bdHolder, DependencyDescriptor descriptor)</span> &#123;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 用于确认该BeanDefinition 是不是 我们要装配到 DependencyDescriptor的 bean def</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="type">boolean</span> <span class="variable">match</span> <span class="operator">=</span> <span class="built_in">super</span>.isAutowireCandidate(bdHolder, descriptor);</span><br><span class="line">		<span class="keyword">if</span> (match) &#123;</span><br><span class="line">			<span class="comment">// 先确认属性/方法上的注解，取决于DependencyDescriptor  </span></span><br><span class="line">			match = checkQualifiers(bdHolder, descriptor.getAnnotations());</span><br><span class="line">			<span class="keyword">if</span> (match) &#123;</span><br><span class="line">				<span class="comment">// 再确认 方法里面的参数是否匹配</span></span><br><span class="line">				<span class="type">MethodParameter</span> <span class="variable">methodParam</span> <span class="operator">=</span> descriptor.getMethodParameter();</span><br><span class="line">				<span class="keyword">if</span> (methodParam != <span class="literal">null</span>) &#123;</span><br><span class="line">					<span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> methodParam.getMethod();</span><br><span class="line">					<span class="keyword">if</span> (method == <span class="literal">null</span> || <span class="keyword">void</span>.class == method.getReturnType()) &#123;</span><br><span class="line">						match = checkQualifiers(bdHolder, methodParam.getMethodAnnotations());</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> match;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><code>checkQualifiers</code> 这个是核心，<code>DependencyDescriptor</code>  如果是 <code>byType</code> 那就是 <code>method</code></p>
<p>如果是 <code>method</code> 它还会检查 <code>method param</code> 也就是参数上有没有 <code>@Qualifier</code> 注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">checkQualifiers</span><span class="params">(BeanDefinitionHolder bdHolder, Annotation[] annotationsToSearch)</span> &#123;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 检查是限定的 Bean</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// [1] 如果没有注解，那么直接返回true</span></span><br><span class="line">		<span class="keyword">if</span> (ObjectUtils.isEmpty(annotationsToSearch)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="type">SimpleTypeConverter</span> <span class="variable">typeConverter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleTypeConverter</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// [2] 遍历注解</span></span><br><span class="line">		<span class="keyword">for</span> (Annotation annotation : annotationsToSearch) &#123;</span><br><span class="line">			Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; type = annotation.annotationType();</span><br><span class="line">			<span class="type">boolean</span> <span class="variable">checkMeta</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">			<span class="type">boolean</span> <span class="variable">fallbackToMeta</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 判断注解是不是 @Qualifier, spring 有自己的 Qualifier注解，担其也支持 JSR330的标准</span></span><br><span class="line">			<span class="keyword">if</span> (isQualifier(type)) &#123;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 匹配 BeanDefinition 和 qualifier 指定的 Bean</span></span><br><span class="line">				<span class="keyword">if</span> (!checkQualifier(bdHolder, annotation, typeConverter)) &#123;</span><br><span class="line">					fallbackToMeta = <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					checkMeta = <span class="literal">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 检查 注解内部，也就是 注解 中的注解，再次判断</span></span><br><span class="line">			<span class="keyword">if</span> (checkMeta) &#123;</span><br><span class="line">				<span class="type">boolean</span> <span class="variable">foundMeta</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">				<span class="keyword">for</span> (Annotation metaAnn : type.getAnnotations()) &#123;</span><br><span class="line">					Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; metaType = metaAnn.annotationType();</span><br><span class="line">					<span class="keyword">if</span> (isQualifier(metaType)) &#123;</span><br><span class="line">						foundMeta = <span class="literal">true</span>;</span><br><span class="line">						<span class="comment">// Only accept fallback match if @Qualifier annotation has a value...</span></span><br><span class="line">						<span class="comment">// Otherwise it is just a marker for a custom qualifier annotation.</span></span><br><span class="line">						<span class="keyword">if</span> ((fallbackToMeta &amp;&amp; StringUtils.isEmpty(AnnotationUtils.getValue(metaAnn))) ||</span><br><span class="line">								!checkQualifier(bdHolder, metaAnn, typeConverter)) &#123;</span><br><span class="line">							<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (fallbackToMeta &amp;&amp; !foundMeta) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>在这里面会遍历所有注解，并且用 <code>isQualifier</code> 判断是不是 <code>@Qualifier</code> 注解 或者 <code>JSR330 Qualifier</code> 注解，这两个注解是不一样的，一个是 <code>spring</code> 提供的 ，另外一个是 <code>JSR330 </code> 标准 提供的</p>
<p>如果是上诉两种类型的注解，那就 <code>checkQualifier</code> 检查是不是限定了 <code>name</code> ，也就是说这个注解必须提供了值，也就是限定装配的那个 <code>bean</code> 的名称。</p>
<p>如果说这个注解没有提供值，则检测这个注解的内部，是不是还有 <code>Qualifier</code> 注解，丧心病狂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">checkQualifier</span><span class="params">(</span></span><br><span class="line"><span class="params">			BeanDefinitionHolder bdHolder, Annotation annotation, TypeConverter typeConverter)</span> &#123;</span><br><span class="line">		<span class="comment">// NOTE 获取注解属性</span></span><br><span class="line">		Map&lt;String, Object&gt; attributes = AnnotationUtils.getAnnotationAttributes(annotation);</span><br><span class="line">		<span class="keyword">if</span> (attributes.isEmpty() &amp;&amp; qualifier == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="comment">// If no attributes, the qualifier must be present</span></span><br><span class="line">			<span class="comment">// NOTE 没有提供属性， over</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : attributes.entrySet()) &#123;</span><br><span class="line">			<span class="type">String</span> <span class="variable">attributeName</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">			<span class="type">Object</span> <span class="variable">expectedValue</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">			<span class="type">Object</span> <span class="variable">actualValue</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">			<span class="comment">// Check qualifier first</span></span><br><span class="line">			<span class="keyword">if</span> (qualifier != <span class="literal">null</span>) &#123;</span><br><span class="line">				actualValue = qualifier.getAttribute(attributeName);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (actualValue == <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="comment">// Fall back on bean definition attribute</span></span><br><span class="line">				actualValue = bd.getAttribute(attributeName);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// NOTE 注解包括属性名为 value 的属性，那么就直接说明这是符合的</span></span><br><span class="line">			<span class="keyword">if</span> (actualValue == <span class="literal">null</span> &amp;&amp; attributeName.equals(AutowireCandidateQualifier.VALUE_KEY) &amp;&amp;</span><br><span class="line">					expectedValue <span class="keyword">instanceof</span> String &amp;&amp; bdHolder.matchesName((String) expectedValue)) &#123;</span><br><span class="line">				<span class="comment">// Fall back on bean name (or alias) match</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (actualValue == <span class="literal">null</span> &amp;&amp; qualifier != <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="comment">// Fall back on default, but only if the qualifier is present</span></span><br><span class="line">				actualValue = AnnotationUtils.getDefaultValue(annotation, attributeName);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (actualValue != <span class="literal">null</span>) &#123;</span><br><span class="line">				actualValue = typeConverter.convertIfNecessary(actualValue, expectedValue.getClass());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (!expectedValue.equals(actualValue)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>这里就是真正的判断逻辑了，就是获取注解的 <code>value </code>然后这个值 和 <code>beanDefinitonHoder</code> 匹配那就 ok，这个 <code>hoder</code> 是一个<code>map</code> 里面有我们定义的 <code>bean</code>的名称 对应的 <code>beanDefinition</code></p>
<p>这就是 <code>@Qualifier</code> 实现的原理。</p>
<hr>
<p>顺手也可以看得出 <code>@Value</code> 的实现方式。</p>
<p>且看 <code>QualifierAnnotationAutowireCandidateResolver</code> 的 <code>getSuggestedValue</code> 获取建议的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getSuggestedValue</span><span class="params">(DependencyDescriptor descriptor)</span> &#123;</span><br><span class="line">		<span class="comment">// 首先从 方法/属性 中获取 </span></span><br><span class="line">		<span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> findValue(descriptor.getAnnotations());</span><br><span class="line">		<span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 也可以从 参数中 获取</span></span><br><span class="line">			<span class="type">MethodParameter</span> <span class="variable">methodParam</span> <span class="operator">=</span> descriptor.getMethodParameter();</span><br><span class="line">			<span class="keyword">if</span> (methodParam != <span class="literal">null</span>) &#123;</span><br><span class="line">				value = findValue(methodParam.getMethodAnnotations());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>和<code>@Qualifier</code> 有点相似，提供从方法或者属性，也提供方法上面的参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">findValue</span><span class="params">(Annotation[] annotationsToSearch)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (annotationsToSearch.length &gt; <span class="number">0</span>) &#123;   <span class="comment">// qualifier annotations have to be local</span></span><br><span class="line">			<span class="type">AnnotationAttributes</span> <span class="variable">attr</span> <span class="operator">=</span> AnnotatedElementUtils.getMergedAnnotationAttributes(</span><br><span class="line">					<span class="comment">// 获取注解 限定 注解类型为 Value.class 也就是 @Value</span></span><br><span class="line">					AnnotatedElementUtils.forAnnotations(annotationsToSearch), <span class="built_in">this</span>.valueAnnotationType);</span><br><span class="line">			<span class="keyword">if</span> (attr != <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="comment">// 获取真正的值</span></span><br><span class="line">				<span class="keyword">return</span> extractValue(attr);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Extract the value attribute from the given annotation.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 4.3</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">protected</span> Object <span class="title function_">extractValue</span><span class="params">(AnnotationAttributes attr)</span> &#123;</span><br><span class="line">		<span class="comment">// 获取注解属性的值，属性的名称就是 value</span></span><br><span class="line">		<span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> attr.get(AnnotationUtils.VALUE);</span><br><span class="line">		<span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Value annotation must have a value attribute&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>这个不用多解释了，也就是 获取 注解上的属性，很easy</p>
<p>拿到值后还需要修复，比如说环境变量等，这里暂时不讨论</p>
]]></content>
      <categories>
        <category>Spring-functionality</category>
      </categories>
      <tags>
        <tag>Spring-Bean</tag>
      </tags>
  </entry>
  <entry>
    <title>3.@Autowired注解实现的原理</title>
    <url>/2021/08/02/spring_analysis/beans/functionality/3.@Autowired%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h3 id="前言-18">前言</h3>
<p><code>@Autowired</code> 注解的实现原理</p>
<p>第二小节说了，<code>byType</code>是根据 <code>method</code> 和<code>methodParm</code> 来装配的</p>
<p>在这里 <code>@Autowried </code>是根据 <code>field</code>来进行装配的</p>
<p><code>AutowiredAnnotationBeanPostProcessor</code> 这个处理器来负责实现<code>@Autowired </code> 注解装配</p>
<p><code>spring</code> 也支持 <code>JSR330</code> 的 <code>Inject</code> 注解</p>
<p>先看这个 <code>processor</code> 初始化部分</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</span> &#123;</span><br><span class="line">   <span class="comment">// [1] 预处理，准备注解数据，这个在new instance 后调用</span></span><br><span class="line">   <span class="comment">// 调用之后才是 填充bean依赖数据</span></span><br><span class="line">   <span class="type">InjectionMetadata</span> <span class="variable">metadata</span> <span class="operator">=</span> findAutowiringMetadata(beanName, beanType, <span class="literal">null</span>);</span><br><span class="line">   metadata.checkConfigMembers(beanDefinition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续跟进</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> InjectionMetadata <span class="title function_">findAutowiringMetadata</span><span class="params">(String beanName, Class&lt;?&gt; clazz, <span class="meta">@Nullable</span> PropertyValues pvs)</span> &#123;</span><br><span class="line">		<span class="comment">/**------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">		 * [DESC] 寻找存在注解的方法或者属性，前提是属性不能为 static 类型  NOTE so why? i don&#x27;t know</span></span><br><span class="line"><span class="comment">		 * [1] 第一步从缓存中搜索，没有就调用 &#123;<span class="doctag">@link</span> #buildAutowiringMetadata(Class)&#125; 来生成注解数据</span></span><br><span class="line"><span class="comment">		 *-----------------------------------------------------------------------------------------------------------*/</span></span><br><span class="line">		<span class="comment">// Fall back to class name as cache key, for backwards compatibility with custom callers.</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">cacheKey</span> <span class="operator">=</span> (StringUtils.hasLength(beanName) ? beanName : clazz.getName());</span><br><span class="line">		<span class="comment">// Quick check on the concurrent map first, with minimal locking.</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// [1] 从缓存中查找</span></span><br><span class="line">		<span class="type">InjectionMetadata</span> <span class="variable">metadata</span> <span class="operator">=</span> <span class="built_in">this</span>.injectionMetadataCache.get(cacheKey);</span><br><span class="line">		<span class="keyword">if</span> (InjectionMetadata.needsRefresh(metadata, clazz)) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (<span class="built_in">this</span>.injectionMetadataCache) &#123;</span><br><span class="line">				metadata = <span class="built_in">this</span>.injectionMetadataCache.get(cacheKey);</span><br><span class="line">				<span class="keyword">if</span> (InjectionMetadata.needsRefresh(metadata, clazz)) &#123;</span><br><span class="line">					<span class="keyword">if</span> (metadata != <span class="literal">null</span>) &#123;</span><br><span class="line">						metadata.clear(pvs);</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					<span class="comment">// 缓存找不到那就 build一个 Note step in</span></span><br><span class="line">					metadata = buildAutowiringMetadata(clazz);</span><br><span class="line">					<span class="built_in">this</span>.injectionMetadataCache.put(cacheKey, metadata);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> metadata;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><code>InjectionMetadata</code> 这个是关键的注入数据，继续跟进这个数据的产生</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> InjectionMetadata <span class="title function_">buildAutowiringMetadata</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; clazz)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**-------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">		 * [DESC] 生成注解数据</span></span><br><span class="line"><span class="comment">		 * [1] 遍历类的 filed 和method 字段，或许注解数据</span></span><br><span class="line"><span class="comment">		 * &#123;<span class="doctag">@link</span> AutoWried&#125; 注解支持方法filed和method，前提是不支持 静态的属性和方法，如果是方法，只能放在构造函数或者setter方法上面</span></span><br><span class="line"><span class="comment">		 * 并且方法一定要有参数，否则它装配什么。。。</span></span><br><span class="line"><span class="comment">		 * *------------------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// Note 确保是java bean</span></span><br><span class="line">		<span class="keyword">if</span> (!AnnotationUtils.isCandidateClass(clazz, <span class="built_in">this</span>.autowiredAnnotationTypes)) &#123;</span><br><span class="line">			<span class="keyword">return</span> InjectionMetadata.EMPTY;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		List&lt;InjectionMetadata.InjectedElement&gt; elements = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		Class&lt;?&gt; targetClass = clazz;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			<span class="keyword">final</span> List&lt;InjectionMetadata.InjectedElement&gt; currElements = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// TODO 因为@AutoWried 注解支持 filed 和 method</span></span><br><span class="line">			<span class="comment">// TODO 一般是 setter / constructor 方法</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// Note 利用java反射遍历 属性</span></span><br><span class="line">			ReflectionUtils.doWithLocalFields(targetClass, field -&gt; &#123;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 读取注解</span></span><br><span class="line">				MergedAnnotation&lt;?&gt; ann = findAutowiredAnnotation(field);</span><br><span class="line">				<span class="keyword">if</span> (ann != <span class="literal">null</span>) &#123;</span><br><span class="line">					<span class="comment">// Note 不支持static 的属性</span></span><br><span class="line">					<span class="keyword">if</span> (Modifier.isStatic(field.getModifiers())) &#123;</span><br><span class="line">						<span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">							logger.info(<span class="string">&quot;Autowired annotation is not supported on static fields: &quot;</span> + field);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">return</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// is required</span></span><br><span class="line">					<span class="type">boolean</span> <span class="variable">required</span> <span class="operator">=</span> determineRequiredStatus(ann);</span><br><span class="line"></span><br><span class="line">					<span class="comment">// Note 保存注解数据</span></span><br><span class="line">					currElements.add(<span class="keyword">new</span> <span class="title class_">AutowiredFieldElement</span>(field, required));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Note 利用java反射遍历 方法</span></span><br><span class="line">			ReflectionUtils.doWithLocalMethods(targetClass, method -&gt; &#123;</span><br><span class="line">				<span class="type">Method</span> <span class="variable">bridgedMethod</span> <span class="operator">=</span> BridgeMethodResolver.findBridgedMethod(method);</span><br><span class="line">				<span class="keyword">if</span> (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) &#123;</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Note 从方法上获取注解</span></span><br><span class="line">				MergedAnnotation&lt;?&gt; ann = findAutowiredAnnotation(bridgedMethod);</span><br><span class="line">				<span class="keyword">if</span> (ann != <span class="literal">null</span> &amp;&amp; method.equals(ClassUtils.getMostSpecificMethod(method, clazz))) &#123;</span><br><span class="line">					<span class="comment">// Note 不支持 static 方法</span></span><br><span class="line">					<span class="keyword">if</span> (Modifier.isStatic(method.getModifiers())) &#123;</span><br><span class="line">						<span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">							logger.info(<span class="string">&quot;Autowired annotation is not supported on static methods: &quot;</span> + method);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">return</span>;</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					<span class="comment">// Note 不支持无参数的方法，所以说只能用在 setter 和 contructor 方法上</span></span><br><span class="line">					<span class="keyword">if</span> (method.getParameterCount() == <span class="number">0</span>) &#123;</span><br><span class="line">						<span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">							logger.info(<span class="string">&quot;Autowired annotation should only be used on methods with parameters: &quot;</span> +</span><br><span class="line">									method);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="type">boolean</span> <span class="variable">required</span> <span class="operator">=</span> determineRequiredStatus(ann);</span><br><span class="line"></span><br><span class="line">					<span class="comment">// Note 获取方法的参数</span></span><br><span class="line">					<span class="type">PropertyDescriptor</span> <span class="variable">pd</span> <span class="operator">=</span> BeanUtils.findPropertyForMethod(bridgedMethod, clazz);</span><br><span class="line"></span><br><span class="line">					<span class="comment">// Note 保存注解数据</span></span><br><span class="line">					currElements.add(<span class="keyword">new</span> <span class="title class_">AutowiredMethodElement</span>(method, required, pd));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line"></span><br><span class="line">			elements.addAll(<span class="number">0</span>, currElements);</span><br><span class="line">			targetClass = targetClass.getSuperclass();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (targetClass != <span class="literal">null</span> &amp;&amp; targetClass != Object.class);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> InjectionMetadata.forElements(elements, clazz);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法用于生成注解配置数据，其主要从两个点入手：</p>
<ul>
<li>属性</li>
<li>方法</li>
</ul>
<p>其从上面两个点进行注解读取，如果为 <code>@Autowried</code> 或 <code>@Inject</code> 注解则将其方法或者字段信息进行保存</p>
<p>上述就是初始化过程。</p>
<hr>
<p>我们继续看处理部分</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> PropertyValues <span class="title function_">postProcessProperties</span><span class="params">(PropertyValues pvs, Object bean, String beanName)</span> &#123;</span><br><span class="line">		<span class="comment">// [1] 先拿到注册数据</span></span><br><span class="line">		<span class="type">InjectionMetadata</span> <span class="variable">metadata</span> <span class="operator">=</span> findAutowiringMetadata(beanName, bean.getClass(), pvs);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// [2] 根据注解数据然后注入依赖</span></span><br><span class="line">			metadata.inject(bean, beanName, pvs);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(beanName, <span class="string">&quot;Injection of autowired dependencies failed&quot;</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> pvs;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>继续跟进</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">inject</span><span class="params">(Object bean, <span class="meta">@Nullable</span> String beanName, <span class="meta">@Nullable</span> PropertyValues pvs)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">			<span class="comment">/**--------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">			 * [DESC] 根据注解数据，注入依赖</span></span><br><span class="line"><span class="comment">			 * [1] 尝试从缓存中获取已经缓存了的属性数据</span></span><br><span class="line"><span class="comment">			 * [2] 如果缓存没有，那就根据依赖的field信息进行依赖修复 &#123;<span class="doctag">@link</span> org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#resolveDependency&#125;</span></span><br><span class="line"><span class="comment">			 * [3] 解析完毕后，缓存数据</span></span><br><span class="line"><span class="comment">			 * [4] 调用field 的setter方法设置属性值</span></span><br><span class="line"><span class="comment">			 *--------------------------------------------------------------------------------------------------------*/</span></span><br><span class="line">			<span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> (Field) <span class="built_in">this</span>.member;</span><br><span class="line">			Object value;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// [1] 尝试从缓存中获取已经缓存的修复了的属性值</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">this</span>.cached) &#123;</span><br><span class="line">				value = resolvedCachedArgument(beanName, <span class="built_in">this</span>.cachedFieldValue);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// [2] 依赖描述符, 可以看出它是根据字段来进行依赖修复的</span></span><br><span class="line">				<span class="type">DependencyDescriptor</span> <span class="variable">desc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(field, <span class="built_in">this</span>.required);</span><br><span class="line">				desc.setContainingClass(bean.getClass());</span><br><span class="line">				Set&lt;String&gt; autowiredBeanNames = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">				Assert.state(beanFactory != <span class="literal">null</span>, <span class="string">&quot;No BeanFactory available&quot;</span>);</span><br><span class="line">				<span class="type">TypeConverter</span> <span class="variable">typeConverter</span> <span class="operator">=</span> beanFactory.getTypeConverter();</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="comment">// Note [3] 直接调用 factory 进行依赖修复，这个和getBean 的修复是一样的</span></span><br><span class="line">					<span class="comment">// Note 如果用了 @Qualifier(&quot;personA&quot;) 注解 那就加载指定名称的bean，很正常。..</span></span><br><span class="line">					value = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsatisfiedDependencyException</span>(<span class="literal">null</span>, beanName, <span class="keyword">new</span> <span class="title class_">InjectionPoint</span>(field), ex);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// [4] 缓存数据</span></span><br><span class="line">				<span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">					<span class="keyword">if</span> (!<span class="built_in">this</span>.cached) &#123;</span><br><span class="line">						<span class="keyword">if</span> (value != <span class="literal">null</span> || <span class="built_in">this</span>.required) &#123;</span><br><span class="line">							<span class="built_in">this</span>.cachedFieldValue = desc;</span><br><span class="line">							registerDependentBeans(beanName, autowiredBeanNames);</span><br><span class="line">							<span class="keyword">if</span> (autowiredBeanNames.size() == <span class="number">1</span>) &#123;</span><br><span class="line">								<span class="type">String</span> <span class="variable">autowiredBeanName</span> <span class="operator">=</span> autowiredBeanNames.iterator().next();</span><br><span class="line">								<span class="keyword">if</span> (beanFactory.containsBean(autowiredBeanName) &amp;&amp;</span><br><span class="line">										beanFactory.isTypeMatch(autowiredBeanName, field.getType())) &#123;</span><br><span class="line">									<span class="built_in">this</span>.cachedFieldValue = <span class="keyword">new</span> <span class="title class_">ShortcutDependencyDescriptor</span>(</span><br><span class="line">											desc, autowiredBeanName, field.getType());</span><br><span class="line">								&#125;</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">else</span> &#123;</span><br><span class="line">							<span class="built_in">this</span>.cachedFieldValue = <span class="literal">null</span>;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="built_in">this</span>.cached = <span class="literal">true</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// [5] 最后调用 setter 方法将 依赖属性值 丢进去</span></span><br><span class="line">			<span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">				ReflectionUtils.makeAccessible(field);</span><br><span class="line">				field.set(bean, value);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>这个是属性的自动装配，意思就是 <code>@Autowried</code> 注解应用在属性上的处理方法，最终还是调用 <code>resolveDependency </code> 这个方法解析过了，在这就不再赘述，因为这个方法和用 <code>xml </code>配置修复依赖是一样的，这样就轻松的扩展了。使用注解装配。。看起来还蛮方便的</p>
]]></content>
      <categories>
        <category>Spring-functionality</category>
      </categories>
      <tags>
        <tag>Spring-Bean</tag>
      </tags>
  </entry>
  <entry>
    <title>7.创建BeanInstance-根据带参构造函数</title>
    <url>/2021/08/02/spring_analysis/beans/7.%E5%88%9B%E5%BB%BABeanInstance-%E6%A0%B9%E6%8D%AE%E5%B8%A6%E5%8F%82%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h3 id="前言-19">前言</h3>
<p>在上一节讨论到 ``autowireConstructor<code> 利用其实例化</code>Bean<code>，这个功能是通过调用</code>代参构造函数<code>来拿到</code>Instance` 的。不多bb，开搞</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> BeanWrapper <span class="title function_">autowireConstructor</span><span class="params">(</span></span><br><span class="line"><span class="params">			String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Constructor&lt;?&gt;[] ctors, <span class="meta">@Nullable</span> Object[] explicitArgs)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConstructorResolver</span>(<span class="built_in">this</span>).autowireConstructor(beanName, mbd, ctors, explicitArgs);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>上面 <code>ConstructorResolver</code> 这个是 构造函数解析器，是<code>beans</code> 中比较重要的一部分，后面也常常涉及到这个类，那么继续</p>
<p>这个函数长度是 <code>200</code> 所以一点点分析，这样比较清晰</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> BeanWrapper <span class="title function_">autowireConstructor</span><span class="params">(String beanName, RootBeanDefinition mbd,</span></span><br><span class="line"><span class="params">			<span class="meta">@Nullable</span> Constructor&lt;?&gt;[] chosenCtors, <span class="meta">@Nullable</span> Object[] explicitArgs)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">		 * [DESC] 解析构造函数进行数据装配然后实例化对象</span></span><br><span class="line"><span class="comment">		 * [1] 第一种情况就是只有一个构造函数并且构造函数没有参数，这和工厂方法有点像，那就直接调用无参构造函数</span></span><br><span class="line"><span class="comment">		 * [2] 第二种情况，就是多个构造函数和带参数</span></span><br><span class="line"><span class="comment">		 * 先判断是不是在构造函数上用了 &#123;<span class="doctag">@link</span> ConstructorProperties&#125; 注解来标明构造函数的名称，若没有提供注解则直接从构造函数中获取参数名称</span></span><br><span class="line"><span class="comment">		 * 然后用 &#123;<span class="doctag">@link</span> #createArgumentArray&#125; 去匹配和创建构造函数的参数数组，TODO 这个方法比较核心，提供许多策略去匹配参数</span></span><br><span class="line"><span class="comment">		 * [3] 最后根据构造函数的数组 直接调用构造函数 实例化对象</span></span><br><span class="line"><span class="comment">		 *------------------------------------------------------------------------------------------------------------*/</span></span><br><span class="line">		<span class="type">BeanWrapperImpl</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanWrapperImpl</span>();</span><br><span class="line">		<span class="built_in">this</span>.beanFactory.initBeanWrapper(bw);</span><br><span class="line"></span><br><span class="line">		Constructor&lt;?&gt; constructorToUse = <span class="literal">null</span>;</span><br><span class="line">		<span class="type">ArgumentsHolder</span> <span class="variable">argsHolderToUse</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		Object[] argsToUse = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// [1] 尝试中缓存中获取，如果前面已经解析了的话</span></span><br><span class="line">		<span class="keyword">if</span> (explicitArgs != <span class="literal">null</span>) &#123;</span><br><span class="line">			argsToUse = explicitArgs;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			Object[] argsToResolve = <span class="literal">null</span>;</span><br><span class="line">			<span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">				constructorToUse = (Constructor&lt;?&gt;) mbd.resolvedConstructorOrFactoryMethod;</span><br><span class="line">				<span class="keyword">if</span> (constructorToUse != <span class="literal">null</span> &amp;&amp; mbd.constructorArgumentsResolved) &#123;</span><br><span class="line">					<span class="comment">// Found a cached constructor...</span></span><br><span class="line">					argsToUse = mbd.resolvedConstructorArguments;</span><br><span class="line">					<span class="keyword">if</span> (argsToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">						argsToResolve = mbd.preparedConstructorArguments;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (argsToResolve != <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="comment">// 能从缓存拿到就预先解析参数</span></span><br><span class="line">				argsToUse = resolvePreparedArguments(beanName, mbd, bw, constructorToUse, argsToResolve, <span class="literal">true</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>优先还是从缓存中拿到，调用构造函数所需要的参数，如果说没有提供则就自己解析，在上面 <code>explicitArgs</code> 是我们调用 <code>getBean</code> 的时候可以传入进来的参数</p>
<p>解析参数用的是 <code>resolvePreparedArguments</code>的方法，后面会单独讨论，我们先跟踪大体框架</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [2] 若从缓存拿不到，则自己解析Class</span></span><br><span class="line">		<span class="keyword">if</span> (constructorToUse == <span class="literal">null</span> || argsToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="comment">// Take specified constructors, if any.</span></span><br><span class="line">			Constructor&lt;?&gt;[] candidates = chosenCtors;</span><br><span class="line">			<span class="keyword">if</span> (candidates == <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="comment">// Note 直接获取构造函数</span></span><br><span class="line">				Class&lt;?&gt; beanClass = mbd.getBeanClass();</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					candidates = (mbd.isNonPublicAccessAllowed() ?</span><br><span class="line">							beanClass.getDeclaredConstructors() : beanClass.getConstructors());</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">							<span class="string">&quot;Resolution of declared constructors on bean Class [&quot;</span> + beanClass.getName() +</span><br><span class="line">							<span class="string">&quot;] from ClassLoader [&quot;</span> + beanClass.getClassLoader() + <span class="string">&quot;] failed&quot;</span>, ex);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Note 这里和工厂方法那边有点像，一个构造函数并且没有参数</span></span><br><span class="line">			<span class="keyword">if</span> (candidates.length == <span class="number">1</span> &amp;&amp; explicitArgs == <span class="literal">null</span> &amp;&amp; !mbd.hasConstructorArgumentValues()) &#123;</span><br><span class="line">				Constructor&lt;?&gt; uniqueCandidate = candidates[<span class="number">0</span>];</span><br><span class="line">				<span class="keyword">if</span> (uniqueCandidate.getParameterCount() == <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">						mbd.resolvedConstructorOrFactoryMethod = uniqueCandidate;</span><br><span class="line">						mbd.constructorArgumentsResolved = <span class="literal">true</span>;</span><br><span class="line">						mbd.resolvedConstructorArguments = EMPTY_ARGS;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// Note 只有一个默认构造函数</span></span><br><span class="line">					bw.setBeanInstance(instantiate(beanName, mbd, uniqueCandidate, EMPTY_ARGS));</span><br><span class="line">					<span class="keyword">return</span> bw;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>
<p>如果从缓存上拿不到，则需要自己解析<code>class</code>，先获取所有的构造函数，如果构造函数只有一个，并且是无参构造函数，那就直接调用 <code>instantiate</code>拿到 <code>Instance</code> ，这很容易理解，只有一个构造函数并且是无参的，那就很简单了。</p>
<p><strong>值得关注的是 instantiate</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Object <span class="title function_">instantiate</span><span class="params">(</span></span><br><span class="line"><span class="params">			String beanName, RootBeanDefinition mbd, Constructor&lt;?&gt; constructorToUse, Object[] argsToUse)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="type">InstantiationStrategy</span> <span class="variable">strategy</span> <span class="operator">=</span> <span class="built_in">this</span>.beanFactory.getInstantiationStrategy();</span><br><span class="line">			<span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt;</span><br><span class="line">						strategy.instantiate(mbd, beanName, <span class="built_in">this</span>.beanFactory, constructorToUse, argsToUse),</span><br><span class="line">						<span class="built_in">this</span>.beanFactory.getAccessControlContext());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> strategy.instantiate(mbd, beanName, <span class="built_in">this</span>.beanFactory, constructorToUse, argsToUse);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>上面有一个值得关注的点 <code>InstantiationStrategy</code> ，<code>spring</code> 提供了一个默认的初始化策略</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractAutowireCapableBeanFactory</span> <span class="keyword">extends</span> <span class="title class_">AbstractBeanFactory</span></span><br><span class="line">		<span class="keyword">implements</span> <span class="title class_">AutowireCapableBeanFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Strategy for creating bean instances. */</span></span><br><span class="line">	<span class="comment">// Note CGI 代理策略</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">InstantiationStrategy</span> <span class="variable">instantiationStrategy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CglibSubclassingInstantiationStrategy</span>();</span><br></pre></td></tr></table></figure>
<p>也就是 <code>CGI动态代理</code>，有兴趣可以深入，在这不做讨论</p>
<p>继续上面的第三步</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [3] 构造函数可能有多个，并且参数有多个,那就得解析了</span></span><br><span class="line">			<span class="type">boolean</span> <span class="variable">autowiring</span> <span class="operator">=</span> (chosenCtors != <span class="literal">null</span> ||</span><br><span class="line">					mbd.getResolvedAutowireMode() == AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR);</span><br><span class="line">			<span class="type">ConstructorArgumentValues</span> <span class="variable">resolvedValues</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">			<span class="type">int</span> minNrOfArgs;</span><br><span class="line">			<span class="keyword">if</span> (explicitArgs != <span class="literal">null</span>) &#123;</span><br><span class="line">				minNrOfArgs = explicitArgs.length;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// [4] 利用类型转换器，转换一下提供的参数，也就是 constructor-arg提供的参数 </span></span><br><span class="line">				<span class="type">ConstructorArgumentValues</span> <span class="variable">cargs</span> <span class="operator">=</span> mbd.getConstructorArgumentValues();</span><br><span class="line">				resolvedValues = <span class="keyword">new</span> <span class="title class_">ConstructorArgumentValues</span>();</span><br><span class="line">				minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>
<p>如果构造函数有多个并且参数有多个，那就会执行到这里，这个时候就得匹配合适的构造函数，匹配合适的构造函数之前先转换一下，为什么需要转换？</p>
<p>需要转换的数值是我们定义 <code>constructor-arg</code> 中指定的, 至于为什么转换，有待研究, 暂时不管</p>
<p>继续看第五步：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">		<span class="comment">// [5] 下面开始寻找合适的构造函数</span></span><br><span class="line">		AutowireUtils.sortConstructors(candidates);</span><br><span class="line">		<span class="type">int</span> <span class="variable">minTypeDiffWeight</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">		Set&lt;Constructor&lt;?&gt;&gt; ambiguousConstructors = <span class="literal">null</span>;</span><br><span class="line">		LinkedList&lt;UnsatisfiedDependencyException&gt; causes = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (Constructor&lt;?&gt; candidate : candidates) &#123;</span><br><span class="line">			Class&lt;?&gt;[] paramTypes = candidate.getParameterTypes();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (constructorToUse != <span class="literal">null</span> &amp;&amp; argsToUse != <span class="literal">null</span> &amp;&amp; argsToUse.length &gt; paramTypes.length) &#123;</span><br><span class="line">				<span class="comment">// Already found greedy constructor that can be satisfied -&gt;</span></span><br><span class="line">				<span class="comment">// do not look any further, there are only less greedy constructors left.</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Note 如果构造函数的参数 &lt; 提供的参数个数</span></span><br><span class="line">			<span class="comment">// TODO so why?</span></span><br><span class="line">			<span class="keyword">if</span> (paramTypes.length &lt; minNrOfArgs) &#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// [6] 检查参数是否匹配</span></span><br><span class="line">			ArgumentsHolder argsHolder;</span><br><span class="line">			<span class="keyword">if</span> (resolvedValues != <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="comment">// Note 判断是不是在构造函数上用了注解 ConstructorProperties 来标示构造函数的参数名字</span></span><br><span class="line">					String[] paramNames = ConstructorPropertiesChecker.evaluate(candidate, paramTypes.length);</span><br><span class="line"></span><br><span class="line">					<span class="keyword">if</span> (paramNames == <span class="literal">null</span>) &#123;</span><br><span class="line">						<span class="type">ParameterNameDiscoverer</span> <span class="variable">pnd</span> <span class="operator">=</span> <span class="built_in">this</span>.beanFactory.getParameterNameDiscoverer();</span><br><span class="line"></span><br><span class="line">						<span class="comment">// Note 如果没有提供注解，那就直接从构造函数中获取参数名称</span></span><br><span class="line">						<span class="keyword">if</span> (pnd != <span class="literal">null</span>) &#123;</span><br><span class="line">							paramNames = pnd.getParameterNames(candidate);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					<span class="comment">// TODO 这个方法已经解析完毕，可以跟进</span></span><br><span class="line">					<span class="comment">// Note 负责使用多种策略去匹配参数，然后创建参数holder</span></span><br><span class="line">					<span class="comment">// paramTypes 构造函数参数类型</span></span><br><span class="line">					<span class="comment">// paramNames 构造函数参数名称</span></span><br><span class="line">					<span class="comment">// resolvedValues 在bean的定义中提供的数值</span></span><br><span class="line">					argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames,</span><br><span class="line">							getUserDeclaredConstructor(candidate), autowiring, candidates.length == <span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (UnsatisfiedDependencyException ex) &#123;</span><br><span class="line">					</span><br><span class="line">					<span class="comment">// Swallow and try next constructor.</span></span><br><span class="line">					<span class="keyword">if</span> (causes == <span class="literal">null</span>) &#123;</span><br><span class="line">						causes = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">					&#125;</span><br><span class="line">					causes.add(ex);</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// Note 用户没有提供参数, 那就看下有没有提供显示的参数</span></span><br><span class="line">				<span class="comment">// Note 就是调用 #getBean的时候 用户是否传入了参数</span></span><br><span class="line"></span><br><span class="line">				<span class="comment">// Explicit arguments given -&gt; arguments length must match exactly.</span></span><br><span class="line">				<span class="keyword">if</span> (paramTypes.length != explicitArgs.length) &#123;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				argsHolder = <span class="keyword">new</span> <span class="title class_">ArgumentsHolder</span>(explicitArgs);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">typeDiffWeight</span> <span class="operator">=</span> (mbd.isLenientConstructorResolution() ?</span><br><span class="line">					argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));</span><br><span class="line">			<span class="comment">// Choose this constructor if it represents the closest match.</span></span><br><span class="line">			<span class="keyword">if</span> (typeDiffWeight &lt; minTypeDiffWeight) &#123;</span><br><span class="line">				constructorToUse = candidate;</span><br><span class="line">				argsHolderToUse = argsHolder;</span><br><span class="line">				argsToUse = argsHolder.arguments;</span><br><span class="line">				minTypeDiffWeight = typeDiffWeight;</span><br><span class="line">				ambiguousConstructors = <span class="literal">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (constructorToUse != <span class="literal">null</span> &amp;&amp; typeDiffWeight == minTypeDiffWeight) &#123;</span><br><span class="line">				<span class="keyword">if</span> (ambiguousConstructors == <span class="literal">null</span>) &#123;</span><br><span class="line">					ambiguousConstructors = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">					ambiguousConstructors.add(constructorToUse);</span><br><span class="line">				&#125;</span><br><span class="line">				ambiguousConstructors.add(candidate);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (constructorToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (causes != <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="type">UnsatisfiedDependencyException</span> <span class="variable">ex</span> <span class="operator">=</span> causes.removeLast();</span><br><span class="line">				<span class="keyword">for</span> (Exception cause : causes) &#123;</span><br><span class="line">					<span class="built_in">this</span>.beanFactory.onSuppressedException(cause);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">throw</span> ex;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (ambiguousConstructors != <span class="literal">null</span> &amp;&amp; !mbd.isLenientConstructorResolution()) &#123;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (explicitArgs == <span class="literal">null</span> &amp;&amp; argsHolderToUse != <span class="literal">null</span>) &#123;</span><br><span class="line">			argsHolderToUse.storeCache(mbd, constructorToUse);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Assert.state(argsToUse != <span class="literal">null</span>, <span class="string">&quot;Unresolved constructor arguments&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// [8] 调用构造函数 + 参数 进行实例化</span></span><br><span class="line">	bw.setBeanInstance(instantiate(beanName, mbd, constructorToUse, argsToUse));</span><br><span class="line">	<span class="keyword">return</span> bw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>匹配构造函数，按功能名称来看，其主要责任是根据提供的参数找到合适的构造函数，以我们对<code>spring</code>的认知，无非有几种情况：</p>
<ul>
<li>在 bean 的定义中使用 <code>constructor-arg</code> 标签提供参数的名称和值</li>
<li>在调用 <code>getBean</code> 处提供显式的参数</li>
<li>不提供参数则根据类型进行装配，类型必须得是 bean，否则 <code>factory</code> 根本无法知道要装配什么，其只能装配bean。</li>
</ul>
<p>那就可以先看第五步：</p>
<blockquote>
<p>​	第五步很简单，也就是将构造函数按照某种策略进行排序。在这不详尽，后期才会详尽各种工具类</p>
</blockquote>
<p>第六步：</p>
<blockquote>
<p>就要获取参数的类型和名称，如果使用了 <code>constructor-arg</code> 则就直接拿这个标签定义的类型和名称</p>
<p>否则，解析构造函数拿到参数类型，如果在构造函数上方使用了 <code> @ConstructorProperties</code> 注解，那就直接从这个注解中拿到参数的名称</p>
<p>最后调用 <code>createArgumentArray</code> 创建参数数组了，所谓的参数数组就是用来调用构造函数所需要的参数，因为我们要调用其构造函数所以我们就必须得获取参数数组。</p>
<p><code>createArgumentArray</code> 里面提供了三种参数匹配的策略：</p>
<ol>
<li>如果是使用 <code>constructor-arg</code> ，那就生成参数数组，因为 <code>constructor-arg</code> 一个属性就是 <code>index </code>就是用来表示参数的索引，另外一个就是 <code>value</code> 用来代表参数的值，只需要索引和值就能生成参数数组。</li>
<li>根据构造函数的参数类型和名称进行匹配，如果我们使用 <code>constructor-arg</code>中没有指定 <code>index</code> ，但我们指定了 <code>name</code> 和 <code>type </code> 和 <code>value</code> 那么我们也可以用这些进行匹配。</li>
<li>第三种就是 参数类型是 bean类型，而且我们也没有以任何方式提供参数，这个时候就要用到自动装配了，自动装配的实现方式到最后详解.</li>
</ol>
</blockquote>
<p>第八步：</p>
<blockquote>
<p>​	利用匹配到的构造函数和参数值调用构造函数就可以拿到<code>Instance</code>了</p>
</blockquote>
<p>参数匹配实现代码在这里列出，到时候会单独挑出来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ArgumentsHolder <span class="title function_">createArgumentArray</span><span class="params">(</span></span><br><span class="line"><span class="params">			String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> ConstructorArgumentValues resolvedValues,</span></span><br><span class="line"><span class="params">			BeanWrapper bw, Class&lt;?&gt;[] paramTypes, <span class="meta">@Nullable</span> String[] paramNames, Executable executable,</span></span><br><span class="line"><span class="params">			<span class="type">boolean</span> autowiring, <span class="type">boolean</span> fallback)</span> <span class="keyword">throws</span> UnsatisfiedDependencyException &#123;</span><br><span class="line">		<span class="comment">/**-----------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">		 * [DESC] 匹配参数并且创建参数持有者</span></span><br><span class="line"><span class="comment">		 * paramTypes 构造函数参数类型</span></span><br><span class="line"><span class="comment">		 * paramNames 构造函数参数名称</span></span><br><span class="line"><span class="comment">		 * resolvedValues 在bean的定义中提供的参数数值信息</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * [1] 采用两种方式去匹配参数，第一种是按照索引 index=&quot;1&quot; 指定的索引去匹配 &#123;<span class="doctag">@link</span> ConstructorArgumentValues#getArgumentValue&#125;</span></span><br><span class="line"><span class="comment">		 * 第二种是普通匹配，就是参数类型和名称匹配就ok</span></span><br><span class="line"><span class="comment">		 * 第三种是不指定参数类型和名称， 只要是参数类型能互相转换就匹配</span></span><br><span class="line"><span class="comment">		 * [2] 上面两种方式都无法匹配成功，那就判断是否开启了自动装配，因为参数类型可能是Bean &#123;<span class="doctag">@link</span> #resolveAutowiredArgument&#125;</span></span><br><span class="line"><span class="comment">		 *-----------------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line">		<span class="type">TypeConverter</span> <span class="variable">customConverter</span> <span class="operator">=</span> <span class="built_in">this</span>.beanFactory.getCustomTypeConverter();</span><br><span class="line">		<span class="type">TypeConverter</span> <span class="variable">converter</span> <span class="operator">=</span> (customConverter != <span class="literal">null</span> ? customConverter : bw);</span><br><span class="line"></span><br><span class="line">		<span class="type">ArgumentsHolder</span> <span class="variable">args</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArgumentsHolder</span>(paramTypes.length);</span><br><span class="line">		Set&lt;ConstructorArgumentValues.ValueHolder&gt; usedValueHolders = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(paramTypes.length);</span><br><span class="line">		Set&lt;String&gt; autowiredBeanNames = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// [1] 遍历所有的参数类型</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">paramIndex</span> <span class="operator">=</span> <span class="number">0</span>; paramIndex &lt; paramTypes.length; paramIndex++) &#123;</span><br><span class="line">			<span class="comment">// 参数类型和名称</span></span><br><span class="line">			Class&lt;?&gt; paramType = paramTypes[paramIndex];</span><br><span class="line">			<span class="type">String</span> <span class="variable">paramName</span> <span class="operator">=</span> (paramNames != <span class="literal">null</span> ? paramNames[paramIndex] : <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Note 根据索引或者普通方式去匹配构造参数值</span></span><br><span class="line">			<span class="comment">// Note 我们可以在bean定义中用 index=&quot;1&quot; 来指定参数的索引</span></span><br><span class="line">			<span class="comment">// Try to find matching constructor argument value, either indexed or generic.</span></span><br><span class="line">			ConstructorArgumentValues.<span class="type">ValueHolder</span> <span class="variable">valueHolder</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (resolvedValues != <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="comment">// Note 这里面采用两种方式，将构造函数所需参数和提供的参数进行匹配</span></span><br><span class="line">				<span class="comment">// [1] 采用index索引方式，前提得在定义bean 的时候用 index=&quot;1&quot;  指定参数, 然后提供的参数和所需的参数名和类型进行对比，</span></span><br><span class="line">				<span class="comment">// 若一致则匹配成功</span></span><br><span class="line">				<span class="comment">// [2] 采用通用方式，就是根据所需要的paramType和paramName去 遍历提供的所有参数信息，若参数名和参数类型一样，则匹配</span></span><br><span class="line">				<span class="comment">// 成功</span></span><br><span class="line">				valueHolder = resolvedValues.getArgumentValue(paramIndex, paramType, paramName, usedValueHolders);</span><br><span class="line">				<span class="comment">// If we couldn&#x27;t find a direct match and are not supposed to autowire,</span></span><br><span class="line">				<span class="comment">// let&#x27;s try the next generic, untyped argument value as fallback:</span></span><br><span class="line">				<span class="comment">// it could match after type conversion (for example, String -&gt; int).</span></span><br><span class="line"></span><br><span class="line">				<span class="comment">// Note 如果参数类型和参数名称都没有匹配到</span></span><br><span class="line">				<span class="comment">// Note 则将参数类型和参数名称设置为 null进行匹配，因为 string可以转换为int</span></span><br><span class="line">				<span class="comment">// Note 因为没有适合的参数类型，所以我们匹配这种 可以转换的类型的参数</span></span><br><span class="line">				<span class="keyword">if</span> (valueHolder == <span class="literal">null</span> &amp;&amp; (!autowiring || paramTypes.length == resolvedValues.getArgumentCount())) &#123;</span><br><span class="line">					valueHolder = resolvedValues.getGenericArgumentValue(<span class="literal">null</span>, <span class="literal">null</span>, usedValueHolders);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (valueHolder != <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="comment">// We found a potential match - let&#x27;s give it a try.</span></span><br><span class="line">				<span class="comment">// Do not consider the same value definition multiple times!</span></span><br><span class="line">				usedValueHolders.add(valueHolder);</span><br><span class="line">				<span class="type">Object</span> <span class="variable">originalValue</span> <span class="operator">=</span> valueHolder.getValue();</span><br><span class="line">				Object convertedValue;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Note 下面进行参数转换</span></span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (valueHolder.isConverted()) &#123;</span><br><span class="line">					<span class="comment">// 已经转换过了，则直接拿它的值</span></span><br><span class="line">					convertedValue = valueHolder.getConvertedValue();</span><br><span class="line">					args.preparedArguments[paramIndex] = convertedValue;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">// Note 否则就是没有转换过的参数, 下面调用转换器进行参数类型转换</span></span><br><span class="line">					<span class="type">MethodParameter</span> <span class="variable">methodParam</span> <span class="operator">=</span> MethodParameter.forExecutable(executable, paramIndex);</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						convertedValue = converter.convertIfNecessary(originalValue, paramType, methodParam);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsatisfiedDependencyException</span>(</span><br><span class="line">								mbd.getResourceDescription(), beanName, <span class="keyword">new</span> <span class="title class_">InjectionPoint</span>(methodParam),</span><br><span class="line">								<span class="string">&quot;Could not convert argument value of type [&quot;</span> +</span><br><span class="line">										ObjectUtils.nullSafeClassName(valueHolder.getValue()) +</span><br><span class="line">										<span class="string">&quot;] to required type [&quot;</span> + paramType.getName() + <span class="string">&quot;]: &quot;</span> + ex.getMessage());</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="type">Object</span> <span class="variable">sourceHolder</span> <span class="operator">=</span> valueHolder.getSource();</span><br><span class="line">					<span class="keyword">if</span> (sourceHolder <span class="keyword">instanceof</span> ConstructorArgumentValues.ValueHolder) &#123;</span><br><span class="line">						<span class="type">Object</span> <span class="variable">sourceValue</span> <span class="operator">=</span> ((ConstructorArgumentValues.ValueHolder) sourceHolder).getValue();</span><br><span class="line">						args.resolveNecessary = <span class="literal">true</span>;</span><br><span class="line">						args.preparedArguments[paramIndex] = sourceValue;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// Note 存放转换后的参数</span></span><br><span class="line">				args.arguments[paramIndex] = convertedValue;</span><br><span class="line">				args.rawArguments[paramIndex] = originalValue;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// Note 没有匹配的合适的参数, 上面两种方式都没有匹配到，那么 还有什么策略 ？ TODO</span></span><br><span class="line">				<span class="comment">// TODO of course 上面支持的是基本类型的匹配</span></span><br><span class="line"></span><br><span class="line">				<span class="type">MethodParameter</span> <span class="variable">methodParam</span> <span class="operator">=</span> MethodParameter.forExecutable(executable, paramIndex);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// DESC 判断是否支持自动装配，意思就是参数类型可能是一个bean</span></span><br><span class="line">				<span class="keyword">if</span> (!autowiring) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsatisfiedDependencyException</span>(</span><br><span class="line">							mbd.getResourceDescription(), beanName, <span class="keyword">new</span> <span class="title class_">InjectionPoint</span>(methodParam),</span><br><span class="line">							<span class="string">&quot;Ambiguous argument values for parameter of type [&quot;</span> + paramType.getName() +</span><br><span class="line">							<span class="string">&quot;] - did you specify the correct bean references as arguments?&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Note 尝试装配Bean到参数</span></span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="type">Object</span> <span class="variable">autowiredArgument</span> <span class="operator">=</span> resolveAutowiredArgument(</span><br><span class="line">							methodParam, beanName, autowiredBeanNames, converter, fallback);</span><br><span class="line">					args.rawArguments[paramIndex] = autowiredArgument;</span><br><span class="line">					args.arguments[paramIndex] = autowiredArgument;</span><br><span class="line">					args.preparedArguments[paramIndex] = autowiredArgumentMarker;</span><br><span class="line">					args.resolveNecessary = <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsatisfiedDependencyException</span>(</span><br><span class="line">							mbd.getResourceDescription(), beanName, <span class="keyword">new</span> <span class="title class_">InjectionPoint</span>(methodParam), ex);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (String autowiredBeanName : autowiredBeanNames) &#123;</span><br><span class="line">			<span class="built_in">this</span>.beanFactory.registerDependentBean(autowiredBeanName, beanName);</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;Autowiring by type from bean name &#x27;&quot;</span> + beanName +</span><br><span class="line">						<span class="string">&quot;&#x27; via &quot;</span> + (executable <span class="keyword">instanceof</span> Constructor ? <span class="string">&quot;constructor&quot;</span> : <span class="string">&quot;factory method&quot;</span>) +</span><br><span class="line">						<span class="string">&quot; to bean named &#x27;&quot;</span> + autowiredBeanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> args;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>那就在最后总结一下根据有参构造函数创建 <code>Instance</code></p>
<ul>
<li>
<p>首先先判断构造函数是不是只有一个，并且构造函数无参数，若是则直接 <code>new</code></p>
</li>
<li>
<p>存在多参数和多构造函数</p>
<blockquote>
<pre><code>1.	获取构造函数参数的 `type` 和 `name`，可以从 `constructor-arg` 提供的属性获取, 参数名也可以通过@ConstructorProperties 注解获取
2.	获取提供的参数值，可以从 `constructor-arg` 提供的属性获取，也可以通过 `getBean`提供的显式参数获取
</code></pre>
<p>匹配策略：</p>
<ol>
<li><code>constructor-arg</code>提供了 <code>index</code> 和 <code>value</code>，则利用 这两个属性就能匹配</li>
<li><code>consurtctor-arg</code>提供了 <code>name</code> 和 <code>value</code>，根据这两个属性进行匹配</li>
<li>只提供了 <code>value</code>，类型转换如果类型转换后能匹配当前构造函数</li>
<li>什么都没提供，自动装配</li>
</ol>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>Spring-Bean</category>
      </categories>
      <tags>
        <tag>Spring-Bean</tag>
      </tags>
  </entry>
  <entry>
    <title>9.自动装配Instance</title>
    <url>/2021/08/02/spring_analysis/beans/9.%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8DInstance/</url>
    <content><![CDATA[<h3 id="前言-20">前言</h3>
<p>我们已经完成了创建 <code>Instance</code> 的分析，接下来就应该是自动装配，只有装配完 <code>Bean</code> 才能被使用，在这里可能会看到 <code>spring</code>是如何解决 <code>循环依赖的</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">			<span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">		 * [DESC] 负责创建Bean</span></span><br><span class="line"><span class="comment">		 * [1] 如果是singleton对象，现在缓存中移除</span></span><br><span class="line"><span class="comment">		 * [2] 如果之前没有创建过singleton，则调用 &#123;<span class="doctag">@link</span> #createBeanInstance&#125; 创建</span></span><br><span class="line"><span class="comment">		 * [3] 将单例添加到factory中，预先暴露bean，这可以支持spring去解决 singleton循环依赖问题</span></span><br><span class="line"><span class="comment">		 * [4] 调用 &#123;<span class="doctag">@link</span> #populateBean&#125; 填充依赖属性</span></span><br><span class="line"><span class="comment">		 * [5] 调用 &#123;<span class="doctag">@link</span> #initializeBean&#125; 初始化bean</span></span><br><span class="line"><span class="comment">		 * [6] 如果Bean定义了Dependent-on 那就修复 依赖</span></span><br><span class="line"><span class="comment">		 *------------------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 创建出来的实例是需要包装起来，然后才能修复依赖</span></span><br><span class="line">		<span class="type">BeanWrapper</span> <span class="variable">instanceWrapper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Note [1] 单例对象需要从缓存中移除</span></span><br><span class="line">		<span class="comment">// 如果之前没有创建过，那接下来就创建实例</span></span><br><span class="line">		<span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">			instanceWrapper = <span class="built_in">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (instanceWrapper == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="comment">// Note step in 创建实例</span></span><br><span class="line">			instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取包装类中的实例</span></span><br><span class="line">		<span class="keyword">final</span> <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> instanceWrapper.getWrappedInstance();</span><br><span class="line">		Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">		<span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">			mbd.resolvedTargetType = beanType;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// NOTE 调用 MergedBeanDefinitionPostProcessor 处理器</span></span><br><span class="line">		<span class="comment">// NOTE 此时 Bean Instance 已经被创建出来</span></span><br><span class="line">		<span class="comment">// 允许修改被合并的bean定义</span></span><br><span class="line">		<span class="comment">// MergedBeanDefinitionPostProcessor#postProcessMergedBeanDefinition</span></span><br><span class="line">		<span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">							<span class="string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);</span><br><span class="line">				&#125;</span><br><span class="line">				mbd.postProcessed = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// NOTICE</span></span><br><span class="line">		<span class="comment">// NOTE 这里解决单例模式下的循环依赖，就是在Singleton未初始化完毕的时候就直接将其丢进工厂</span></span><br><span class="line">		<span class="comment">// NOTE 然后再填充依赖</span></span><br><span class="line">		<span class="comment">// 例如：ClassA 依赖 ClassB，先new ClassA，然后放入工厂</span></span><br><span class="line">		<span class="comment">// 然后填充 ClassA，发现依赖于ClassB 然后 new ClassB，因为ClassB依赖ClassA，并且ClassA已经被创建只是没有初始化并且存在工厂中</span></span><br><span class="line">		<span class="comment">// 所以这时候就能从工厂拿到ClassA来填充ClassB，从而ClassB完整创建，然后填充到ClassA，这就解决了循环依赖</span></span><br><span class="line">		<span class="type">boolean</span> <span class="variable">earlySingletonExposure</span> <span class="operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="built_in">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">				isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">		<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +</span><br><span class="line">						<span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// NOTE Bean未被填充，提前丢进工厂，只限于Singleton</span></span><br><span class="line">			addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Note 初始化Bean</span></span><br><span class="line">		<span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// Note 填充Bean，也就是填充BeanProperty</span></span><br><span class="line">			<span class="comment">// Note 传入的参数有Wrapper也就是包装类，用于修改属性和获取属性</span></span><br><span class="line">			<span class="comment">// Note step in 填充Bean</span></span><br><span class="line">			populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Note step in 初始化bean</span></span><br><span class="line">			exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">				<span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">						mbd.getResourceDescription(), beanName, <span class="string">&quot;Initialization of bean failed&quot;</span>, ex);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Note 当单例是循环引用，且到这已经被填充完了</span></span><br><span class="line">		<span class="comment">// Note 则注入dependent bean</span></span><br><span class="line">		<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">			<span class="comment">// 先获取一下填充完的实例</span></span><br><span class="line">			<span class="type">Object</span> <span class="variable">earlySingletonReference</span> <span class="operator">=</span> getSingleton(beanName, <span class="literal">false</span>);</span><br><span class="line">			<span class="keyword">if</span> (earlySingletonReference != <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">					exposedObject = earlySingletonReference;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">					<span class="comment">// 注入dependent bean</span></span><br><span class="line">					String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">					Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(dependentBeans.length);</span><br><span class="line">					<span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">						<span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">							actualDependentBeans.add(dependentBean);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">						</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Register bean as disposable.</span></span><br><span class="line">		<span class="comment">// 一次性注册Bean</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">					mbd.getResourceDescription(), beanName, <span class="string">&quot;Invalid destruction signature&quot;</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> exposedObject;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>这部分代码是紧接着<code>createInstance</code> 的，创建完 <code>Instance</code>后就是直接丢入工厂，这就解决了循环依赖，此时<code>Instance</code> 还没填充就直接丢进工厂。然后调用 <code>populateBean(beanName, mbd, instanceWrapper);</code> 自动装配。</p>
<p>我们继续。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> BeanWrapper bw)</span> &#123;</span><br><span class="line">		<span class="comment">// [1] bean必须存在属性，否则抛出异常</span></span><br><span class="line">		<span class="keyword">if</span> (bw == <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 没有属性你还populate 毛啊 ～</span></span><br><span class="line">			<span class="keyword">if</span> (mbd.hasPropertyValues()) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">						mbd.getResourceDescription(), beanName, <span class="string">&quot;Cannot apply property values to null instance&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// Skip property population phase for null instance.</span></span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Give any InstantiationAwareBeanPostProcessors the opportunity to modify the</span></span><br><span class="line">		<span class="comment">// state of the bean before properties are set. This can be used, for example,</span></span><br><span class="line">		<span class="comment">// to support styles of field injection.</span></span><br><span class="line">		<span class="type">boolean</span> <span class="variable">continueWithPropertyPopulation</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// [2] NOTE 调用InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation处理器</span></span><br><span class="line">		<span class="comment">// NOTE 此时正准备装配属性</span></span><br><span class="line">		<span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">			<span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">				<span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">					<span class="type">InstantiationAwareBeanPostProcessor</span> <span class="variable">ibp</span> <span class="operator">=</span> (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">					<span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">						continueWithPropertyPopulation = <span class="literal">false</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!continueWithPropertyPopulation) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// [3] 获取属性值</span></span><br><span class="line">		<span class="type">PropertyValues</span> <span class="variable">pvs</span> <span class="operator">=</span> (mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// [4] 根据自动填充模式来填充</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">resolvedAutowireMode</span> <span class="operator">=</span> mbd.getResolvedAutowireMode();</span><br><span class="line">		<span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">			<span class="type">MutablePropertyValues</span> <span class="variable">newPvs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MutablePropertyValues</span>(pvs);</span><br><span class="line">			<span class="comment">// Add property values based on autowire by name if applicable.</span></span><br><span class="line">			<span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">				autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Add property values based on autowire by type if applicable.</span></span><br><span class="line">			<span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">				<span class="comment">// NOTE 这个需要进去 （比较复杂）</span></span><br><span class="line">				autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">			&#125;</span><br><span class="line">			pvs = newPvs;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>自动装配之前，我们必须要拿到需要装配的类型，然后才能装配，在装配之前先调用</p>
<p><code>InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation</code> 处理器</p>
<p>然后看第三步：先获取<code>beanDefinition</code> 定义的属性的信息，也就是属性信息</p>
<p>第四步：就是根据装配模式来确定装配的方式，有两种，<code>byType</code>和 <code>byName</code>，那为什么没看到 <code>byConstruct</code>呢？是因为这只是装配 <code>bean</code> 需要的信息而已，也就是根据类型装配或者根据名称装配，<code>BeanFactory</code> 也就只提供这两种类型的<code>getBean</code>，至于 <code>byConstruct</code> 那个应该是注解完成的事情，留个悬念 <code>@Autowired</code></p>
<p>接下来先看 <code>byName</code>是怎么实现的，实际上不用想，直接 <code>getBean</code> …</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">autowireByName</span><span class="params">(</span></span><br><span class="line"><span class="params">			String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs)</span> &#123;</span><br><span class="line"></span><br><span class="line">		String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);</span><br><span class="line">		<span class="keyword">for</span> (String propertyName : propertyNames) &#123;</span><br><span class="line">			<span class="keyword">if</span> (containsBean(propertyName)) &#123;</span><br><span class="line">				<span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> getBean(propertyName);</span><br><span class="line">				pvs.add(propertyName, bean);</span><br><span class="line">				registerDependentBean(propertyName, beanName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>没毛病… 遍历属性然后直接根据属性名称装配，这种方式是最效率的。</p>
<p>继续看 <code>byType</code> ，这个比较复杂，跟进</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">autowireByType</span><span class="params">(</span></span><br><span class="line"><span class="params">      String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs)</span> &#123;</span><br><span class="line">   <span class="comment">// Note 根据类型来自动装配</span></span><br><span class="line">   <span class="comment">// Note 那就必然涉及到类型的转换</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// [1] 先new 一个类型转转换器</span></span><br><span class="line">   <span class="type">TypeConverter</span> <span class="variable">converter</span> <span class="operator">=</span> getCustomTypeConverter();</span><br><span class="line">   <span class="keyword">if</span> (converter == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果没有就用Wrapper内置的类型转换，支持基础类型</span></span><br><span class="line">      converter = bw;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// [2] 遍历属性和装配了</span></span><br><span class="line">   Set&lt;String&gt; autowiredBeanNames = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// NOTE 在这里排除一些不满足装配条件的属性</span></span><br><span class="line">   <span class="comment">// NOTE 使用 &lt;property name=&quot;impl1&quot; ref=&quot;BEAN1&quot;/&gt; ref属性引用的bean，这个是不会被装配的</span></span><br><span class="line">   <span class="comment">// NOTE CGLIB 定义的属性也不会被装配</span></span><br><span class="line">   <span class="comment">// NOTE ingnoreInterface 也不会被装配</span></span><br><span class="line">  <span class="comment">// NOTE 简单类型不会被装配</span></span><br><span class="line">   <span class="comment">// TODO 之所以使用 ref是因为接触循环依赖？目前还不清楚</span></span><br><span class="line">   String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);</span><br><span class="line">   <span class="keyword">for</span> (String propertyName : propertyNames) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Note 第一步肯定是获取属性的描述符</span></span><br><span class="line">         <span class="type">PropertyDescriptor</span> <span class="variable">pd</span> <span class="operator">=</span> bw.getPropertyDescriptor(propertyName);</span><br><span class="line">         <span class="comment">// Don&#x27;t try autowiring by type for type Object: never makes sense,</span></span><br><span class="line">         <span class="comment">// even if it technically is a unsatisfied, non-simple property.</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// Note 类型是 Object 就不装配，显然Object类型这没法装配</span></span><br><span class="line">         <span class="keyword">if</span> (Object.class != pd.getPropertyType()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取Get方法参数</span></span><br><span class="line">            <span class="type">MethodParameter</span> <span class="variable">methodParam</span> <span class="operator">=</span> BeanUtils.getWriteMethodParameter(pd);</span><br><span class="line">            <span class="comment">// Do not allow eager init for type matching in case of a prioritized post-processor.</span></span><br><span class="line"></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">eager</span> <span class="operator">=</span> !PriorityOrdered.class.isInstance(bw.getWrappedInstance());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 确认Get方法的依赖？ TODO：进去看看</span></span><br><span class="line">            <span class="type">DependencyDescriptor</span> <span class="variable">desc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AutowireByTypeDependencyDescriptor</span>(methodParam, eager);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 解析Get方法的参数依赖</span></span><br><span class="line">            <span class="comment">// NOTE 解析依赖，关键的地方了</span></span><br><span class="line">            <span class="comment">/**<span class="doctag">@see</span> DefaultListableBeanFactory#resolveDependency*/</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">autowiredArgument</span> <span class="operator">=</span> resolveDependency(desc, beanName, autowiredBeanNames, converter);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 保存依赖属性</span></span><br><span class="line">            <span class="keyword">if</span> (autowiredArgument != <span class="literal">null</span>) &#123;</span><br><span class="line">               pvs.add(propertyName, autowiredArgument);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (String autowiredBeanName : autowiredBeanNames) &#123;</span><br><span class="line">              </span><br><span class="line">					<span class="comment">// NOTE 这里有个小细节</span></span><br><span class="line">					<span class="comment">// NOTE 当已经拿到了这个Bean依赖的其它Bean，那就把这些依赖的Bean丢进 dependentBean里面，</span></span><br><span class="line">					<span class="comment">// NOTE 这相当于 我们使用 depends-on 标签，这样的话，这些依赖的 Bean就会在 该Bean初始化前初始化</span></span><br><span class="line">               registerDependentBean(autowiredBeanName, beanName);</span><br><span class="line">               <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                  logger.trace(<span class="string">&quot;Autowiring by type from bean name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; via property &#x27;&quot;</span> +</span><br><span class="line">                        propertyName + <span class="string">&quot;&#x27; to bean named &#x27;&quot;</span> + autowiredBeanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            autowiredBeanNames.clear();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsatisfiedDependencyException</span>(mbd.getResourceDescription(), beanName, propertyName, ex);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据类型装配，首先就得获取需要装配的属性信息，然后通过 <code>getBean</code> 就能修复依赖，虽然是这样说，但实际却很复杂。</p>
<p>先看下它怎么实现：</p>
<ul>
<li>调用 <code>unsatisfiedNonSimpleProperties</code> 过滤一些不用装配的属性，比如说 <code>简单类型</code>，<code>CGLIB</code> 生成的一些属性，<code>ref=&quot;bean&quot;</code> 引用的 <code>bean</code> 这些是不会被装配的，至于为什么，暂时还不知道，但后面它还是会装配的。但在 <code>byType</code> 这里不会装配，在这里它只会老老实实按照属性信息装配，至于为什么暂时不用管</li>
<li>然后获取属性对应的<code>set</code> 方法，然后调用 <code>resolveDependency</code> 修复依赖，这个东西贯穿所有依赖修复的核心。支持很多种类型的修复</li>
<li>最后将修复好的依赖属性值 保存起来</li>
<li>顺便把依赖的<code>bean</code>丢进 <code>dependentBean</code> 里面，让它们提前加载</li>
</ul>
<p>接着看 <code>resolveDependency</code> 这个是修复依赖的核心</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">resolveDependency</span><span class="params">(DependencyDescriptor descriptor, <span class="meta">@Nullable</span> String requestingBeanName,</span></span><br><span class="line"><span class="params">			<span class="meta">@Nullable</span> Set&lt;String&gt; autowiredBeanNames, <span class="meta">@Nullable</span> TypeConverter typeConverter)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 初始化一下 set 方法的 参数信息</span></span><br><span class="line">		descriptor.initParameterNameDiscovery(getParameterNameDiscoverer());</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Note 根据依赖的类型而进行不同的处理</span></span><br><span class="line">		<span class="keyword">if</span> (Optional.class == descriptor.getDependencyType()) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// NOTE Optional类型</span></span><br><span class="line">			<span class="keyword">return</span> createOptionalDependency(descriptor, requestingBeanName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (ObjectFactory.class == descriptor.getDependencyType() ||</span><br><span class="line">				ObjectProvider.class == descriptor.getDependencyType()) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Note FactoryBean Provider 要么是工厂 要么是 提供者</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DependencyObjectProvider</span>(descriptor, requestingBeanName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (javaxInjectProviderClass == descriptor.getDependencyType()) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Note Jsr330 标准的工厂</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Jsr330Factory</span>().createDependencyProvider(descriptor, requestingBeanName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Note 否则就是 基本的属性类型 或者 对象</span></span><br><span class="line">			<span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary(</span><br><span class="line">					descriptor, requestingBeanName);</span><br><span class="line">			<span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="comment">// Note step in</span></span><br><span class="line">				result = doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到自动装配支持很多种类型：</p>
<ul>
<li>Optional 类型</li>
<li>ObjectFactory 和 ObjectProvider</li>
<li>JSR330工厂</li>
<li>一般类型和对象</li>
</ul>
<p>最后一种比较重要，先看最后一种：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">doResolveDependency</span><span class="params">(DependencyDescriptor descriptor, <span class="meta">@Nullable</span> String beanName,</span></span><br><span class="line"><span class="params">			<span class="meta">@Nullable</span> Set&lt;String&gt; autowiredBeanNames, <span class="meta">@Nullable</span> TypeConverter typeConverter)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// NOTICE JDK8 的 CDI ，值得和 spring 的 DI进行比较 都是进行依赖注入的东西</span></span><br><span class="line">		<span class="comment">// NOTICE JSR365 CDI 与此关联的还有 JSR299 webBean管理</span></span><br><span class="line">		<span class="type">InjectionPoint</span> <span class="variable">previousInjectionPoint</span> <span class="operator">=</span> ConstructorResolver.setCurrentInjectionPoint(descriptor);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="type">Object</span> <span class="variable">shortcut</span> <span class="operator">=</span> descriptor.resolveShortcut(<span class="built_in">this</span>);</span><br><span class="line">			<span class="keyword">if</span> (shortcut != <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> shortcut;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//</span></span><br><span class="line">			Class&lt;?&gt; type = descriptor.getDependencyType();</span><br><span class="line"></span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * NOTE 获取建议的值 &#123;<span class="doctag">@link</span> QualifierAnnotationAutowireCandidateResolver&#125; 这个支持 &#123;<span class="doctag">@link</span> Value&#125; 注解提供建议值</span></span><br><span class="line"><span class="comment">			 * NOTE factory 是 &#123;<span class="doctag">@link</span> SimpleAutowireCandidateResolver&#125; 这个是不支持提供建议值的</span></span><br><span class="line"><span class="comment">			 * NOTE 如果需要启动注解，就需要添加注册装配处理器 &#123;<span class="doctag">@link</span> AutowiredAnnotationBeanPostProcessor&#125;</span></span><br><span class="line"><span class="comment">			 * NOTE 上述这些东西是用来支持  JSR330 依赖注入注解的</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line"></span><br><span class="line">			<span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> getAutowireCandidateResolver().getSuggestedValue(descriptor);</span><br><span class="line">			<span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (value <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">					<span class="comment">// NOTE 如果注解带的值是字符串类型，这里可以扩展成支持 property 的字符串，也就是需要解析字符串</span></span><br><span class="line">					<span class="comment">// NOTE 比如 $&#123;name.val&#125; 之类的 环境变量表达式</span></span><br><span class="line">					<span class="type">String</span> <span class="variable">strVal</span> <span class="operator">=</span> resolveEmbeddedValue((String) value);</span><br><span class="line">					<span class="type">BeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> (beanName != <span class="literal">null</span> &amp;&amp; containsBean(beanName) ?</span><br><span class="line">							getMergedBeanDefinition(beanName) : <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">					<span class="comment">// NOTE 解析 Bean定义表达式，这个是在 Context才支持的，beans包不支持这个</span></span><br><span class="line">					value = evaluateBeanDefinitionString(strVal, bd);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// NOTE 类型转换</span></span><br><span class="line">				<span class="type">TypeConverter</span> <span class="variable">converter</span> <span class="operator">=</span> (typeConverter != <span class="literal">null</span> ? typeConverter : getTypeConverter());</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> converter.convertIfNecessary(value, type, descriptor.getTypeDescriptor());</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (UnsupportedOperationException ex) &#123;</span><br><span class="line">					<span class="comment">// A custom TypeConverter which does not support TypeDescriptor resolution...</span></span><br><span class="line">					<span class="keyword">return</span> (descriptor.getField() != <span class="literal">null</span> ?</span><br><span class="line">							converter.convertIfNecessary(value, type, descriptor.getField()) :</span><br><span class="line">							converter.convertIfNecessary(value, type, descriptor.getMethodParameter()));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Note 处理 集合 和 映射数据结构</span></span><br><span class="line">			<span class="type">Object</span> <span class="variable">multipleBeans</span> <span class="operator">=</span> resolveMultipleBeans(descriptor, beanName, autowiredBeanNames, typeConverter);</span><br><span class="line">			<span class="keyword">if</span> (multipleBeans != <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> multipleBeans;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Note 匹配该 type 的Class</span></span><br><span class="line">			<span class="comment">// NOTICE 在这里用于确定此属性所需要的bean名称，因为 根据类型来装配是不可靠的，因为一个类型的bean可能有多个</span></span><br><span class="line">			<span class="comment">// NOTICE 所以在这里 spring 提供了 @Qualifier(&quot;personA&quot;) 注解来限定装配哪一个名称的bean</span></span><br><span class="line">			<span class="comment">// NOTICE 如果你用xml 就可以用 ref 来引用id，或者 qualifier ，TODO 这个我没用过 哈哈</span></span><br><span class="line">			Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, type, descriptor);</span><br><span class="line">			<span class="keyword">if</span> (matchingBeans.isEmpty()) &#123;</span><br><span class="line">				<span class="keyword">if</span> (isRequired(descriptor)) &#123;</span><br><span class="line">					raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			String autowiredBeanName;</span><br><span class="line">			Object instanceCandidate;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// NOTE 在这里匹配 使用 @Qualifier 指定的 bean</span></span><br><span class="line">			<span class="keyword">if</span> (matchingBeans.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">				autowiredBeanName = determineAutowireCandidate(matchingBeans, descriptor);</span><br><span class="line">				<span class="keyword">if</span> (autowiredBeanName == <span class="literal">null</span>) &#123;</span><br><span class="line">					<span class="keyword">if</span> (isRequired(descriptor) || !indicatesMultipleBeans(type)) &#123;</span><br><span class="line">						<span class="comment">// </span></span><br><span class="line">						<span class="keyword">return</span> descriptor.resolveNotUnique(descriptor.getResolvableType(), matchingBeans);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="comment">// In case of an optional Collection/Map, silently ignore a non-unique case:</span></span><br><span class="line">						<span class="comment">// possibly it was meant to be an empty collection of multiple regular beans</span></span><br><span class="line">						<span class="comment">// (before 4.3 in particular when we didn&#x27;t even look for collection beans).</span></span><br><span class="line">						<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				instanceCandidate = matchingBeans.get(autowiredBeanName);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// We have exactly one match.</span></span><br><span class="line">				Map.Entry&lt;String, Object&gt; entry = matchingBeans.entrySet().iterator().next();</span><br><span class="line">				autowiredBeanName = entry.getKey();</span><br><span class="line">				instanceCandidate = entry.getValue();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (autowiredBeanNames != <span class="literal">null</span>) &#123;</span><br><span class="line">				autowiredBeanNames.add(autowiredBeanName);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Note 在这里实例化装配</span></span><br><span class="line">			<span class="keyword">if</span> (instanceCandidate <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">				<span class="comment">// NOTE 这里的装配也就只是调用 Factory#GetBean</span></span><br><span class="line">				instanceCandidate = descriptor.resolveCandidate(autowiredBeanName, type, <span class="built_in">this</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> instanceCandidate;</span><br><span class="line">			<span class="keyword">if</span> (result <span class="keyword">instanceof</span> NullBean) &#123;</span><br><span class="line">				<span class="keyword">if</span> (isRequired(descriptor)) &#123;</span><br><span class="line">					raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);</span><br><span class="line">				&#125;</span><br><span class="line">				result = <span class="literal">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (!ClassUtils.isAssignableValue(type, result)) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanNotOfRequiredTypeException</span>(autowiredBeanName, type, instanceCandidate.getClass());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			ConstructorResolver.setCurrentInjectionPoint(previousInjectionPoint);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>从上面可以看出，这里支持了许多 <code>JSR</code>标准，到最后其还是使用 <code>getBean</code> 来修复依赖，如果支持<code>注解处理器</code>，那么就需要解析 <code>@Value</code> 指向的数据，然后进行转换</p>
<p><code>resolveMultipleBeans</code> 这个用于装配集合类型的数据</p>
<hr>
<p>装配方式分为 <code>byName</code> 和 <code>byType</code> 其中 <code>byType</code>比较重要</p>
<p>但其不支持 <code>ref</code>属性引用的 <code>bean</code>，这个时候我们已经拿到修复后的依赖的值，在最后还需要将这个值应用到<code>Instance</code> 上，实际上也就是赋值，在这里它就可以处理，<code>ref</code>引用的<code>bean</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">applyPropertyValues</span><span class="params">(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (pvs.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span> &amp;&amp; bw <span class="keyword">instanceof</span> BeanWrapperImpl) &#123;</span><br><span class="line">			((BeanWrapperImpl) bw).setSecurityContext(getAccessControlContext());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="type">MutablePropertyValues</span> <span class="variable">mpvs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		List&lt;PropertyValue&gt; original;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// NOTE 如果类型是 MutablePropertyValues </span></span><br><span class="line">		<span class="keyword">if</span> (pvs <span class="keyword">instanceof</span> MutablePropertyValues) &#123;</span><br><span class="line">			mpvs = (MutablePropertyValues) pvs;</span><br><span class="line">			<span class="comment">// NOTE 属性值已经被转换，就直接 set就行了</span></span><br><span class="line">			<span class="keyword">if</span> (mpvs.isConverted()) &#123;</span><br><span class="line">				<span class="comment">// Shortcut: use the pre-converted values as-is.</span></span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					bw.setPropertyValues(mpvs);</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">							mbd.getResourceDescription(), beanName, <span class="string">&quot;Error setting property values&quot;</span>, ex);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			original = mpvs.getPropertyValueList();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			original = Arrays.asList(pvs.getPropertyValues());</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// NOTE 下面开始转换任务</span></span><br><span class="line">		<span class="type">TypeConverter</span> <span class="variable">converter</span> <span class="operator">=</span> getCustomTypeConverter();</span><br><span class="line">		<span class="keyword">if</span> (converter == <span class="literal">null</span>) &#123;</span><br><span class="line">			converter = bw;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">BeanDefinitionValueResolver</span> <span class="variable">valueResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionValueResolver</span>(<span class="built_in">this</span>, beanName, mbd, converter);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Create a deep copy, resolving any references for values.</span></span><br><span class="line">		List&lt;PropertyValue&gt; deepCopy = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(original.size());</span><br><span class="line">		<span class="type">boolean</span> <span class="variable">resolveNecessary</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// NOTE 这里采用 deepcopy 进行 转换</span></span><br><span class="line">		<span class="keyword">for</span> (PropertyValue pv : original) &#123;</span><br><span class="line">			<span class="keyword">if</span> (pv.isConverted()) &#123;</span><br><span class="line">				deepCopy.add(pv);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="type">String</span> <span class="variable">propertyName</span> <span class="operator">=</span> pv.getName();</span><br><span class="line">				<span class="type">Object</span> <span class="variable">originalValue</span> <span class="operator">=</span> pv.getValue();</span><br><span class="line">				<span class="keyword">if</span> (originalValue == AutowiredPropertyMarker.INSTANCE) &#123;</span><br><span class="line">					<span class="type">Method</span> <span class="variable">writeMethod</span> <span class="operator">=</span> bw.getPropertyDescriptor(propertyName).getWriteMethod();</span><br><span class="line">					<span class="keyword">if</span> (writeMethod == <span class="literal">null</span>) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Autowire marker for property without write method: &quot;</span> + pv);</span><br><span class="line">					&#125;</span><br><span class="line">					originalValue = <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(<span class="keyword">new</span> <span class="title class_">MethodParameter</span>(writeMethod, <span class="number">0</span>), <span class="literal">true</span>);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// NOTE 解析值，在里面支持 ref 属性引用的bean解析</span></span><br><span class="line">				<span class="type">Object</span> <span class="variable">resolvedValue</span> <span class="operator">=</span> valueResolver.resolveValueIfNecessary(pv, originalValue);</span><br><span class="line">				<span class="type">Object</span> <span class="variable">convertedValue</span> <span class="operator">=</span> resolvedValue;</span><br><span class="line">				<span class="type">boolean</span> <span class="variable">convertible</span> <span class="operator">=</span> bw.isWritableProperty(propertyName) &amp;&amp;</span><br><span class="line">						!PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);</span><br><span class="line">				</span><br><span class="line">				<span class="comment">// NOTE 转换值</span></span><br><span class="line">				<span class="keyword">if</span> (convertible) &#123;</span><br><span class="line">					convertedValue = convertForProperty(resolvedValue, propertyName, bw, converter);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// Possibly store converted value in merged bean definition,</span></span><br><span class="line">				<span class="comment">// in order to avoid re-conversion for every created bean instance.</span></span><br><span class="line">				</span><br><span class="line">				<span class="comment">// NOTE 缓存已经转换的值</span></span><br><span class="line">				<span class="keyword">if</span> (resolvedValue == originalValue) &#123;</span><br><span class="line">					<span class="keyword">if</span> (convertible) &#123;</span><br><span class="line">						pv.setConvertedValue(convertedValue);</span><br><span class="line">					&#125;</span><br><span class="line">					deepCopy.add(pv);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (convertible &amp;&amp; originalValue <span class="keyword">instanceof</span> TypedStringValue &amp;&amp;</span><br><span class="line">						!((TypedStringValue) originalValue).isDynamic() &amp;&amp;</span><br><span class="line">						!(convertedValue <span class="keyword">instanceof</span> Collection || ObjectUtils.isArray(convertedValue))) &#123;</span><br><span class="line">					pv.setConvertedValue(convertedValue);</span><br><span class="line">					deepCopy.add(pv);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					resolveNecessary = <span class="literal">true</span>;</span><br><span class="line">					deepCopy.add(<span class="keyword">new</span> <span class="title class_">PropertyValue</span>(pv, convertedValue));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (mpvs != <span class="literal">null</span> &amp;&amp; !resolveNecessary) &#123;</span><br><span class="line">			mpvs.setConverted();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// NOTE 设置 深拷贝的值</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			bw.setPropertyValues(<span class="keyword">new</span> <span class="title class_">MutablePropertyValues</span>(deepCopy));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">					mbd.getResourceDescription(), beanName, <span class="string">&quot;Error setting property values&quot;</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">valueResolver.resolveValueIfNecessary </span><br></pre></td></tr></table></figure>
<p>这个是核心</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">resolveValueIfNecessary</span><span class="params">(Object argName, <span class="meta">@Nullable</span> Object value)</span> &#123;</span><br><span class="line">		<span class="comment">// We must check each value to see whether it requires a runtime reference</span></span><br><span class="line">		<span class="comment">// to another bean to be resolved.</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// NOTE ref引用的bean修复</span></span><br><span class="line">		<span class="keyword">if</span> (value <span class="keyword">instanceof</span> RuntimeBeanReference) &#123;</span><br><span class="line">			<span class="type">RuntimeBeanReference</span> <span class="variable">ref</span> <span class="operator">=</span> (RuntimeBeanReference) value;</span><br><span class="line">			<span class="keyword">return</span> resolveReference(argName, ref);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>RuntimeBeanReference</code> 就是 使用 <code>ref</code>属性后，生成的描述对象，在最后才会被解析</p>
]]></content>
      <categories>
        <category>Spring-Bean</category>
      </categories>
      <tags>
        <tag>Spring-Bean</tag>
      </tags>
  </entry>
</search>
